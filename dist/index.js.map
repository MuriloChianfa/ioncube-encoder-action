{"version":3,"file":"index.js","mappings":";;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/UA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1RA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChBA;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1GA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpBA;;;;;;;;;;;;;;;;;;;AAmBA;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACZA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACvDA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7aA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5FA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACngCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1HA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/VA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7EA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5dA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC7JA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC3IA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACt5BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChrBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;AC/XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AC7BA;AACA;;;;;;ACDA;AACA;AACA;AACA;AACA;AACA","sources":[".././node_modules/@actions/core/lib/command.js",".././node_modules/@actions/core/lib/core.js",".././node_modules/@actions/core/lib/file-command.js",".././node_modules/@actions/core/lib/oidc-utils.js",".././node_modules/@actions/core/lib/path-utils.js",".././node_modules/@actions/core/lib/summary.js",".././node_modules/@actions/core/lib/utils.js",".././node_modules/@actions/exec/lib/exec.js",".././node_modules/@actions/exec/lib/toolrunner.js",".././node_modules/@actions/http-client/lib/auth.js",".././node_modules/@actions/http-client/lib/index.js",".././node_modules/@actions/http-client/lib/proxy.js",".././node_modules/@actions/io/lib/io-util.js",".././node_modules/@actions/io/lib/io.js",".././node_modules/mkdirp/dist/cjs/src/find-made.js",".././node_modules/mkdirp/dist/cjs/src/index.js",".././node_modules/mkdirp/dist/cjs/src/mkdirp-manual.js",".././node_modules/mkdirp/dist/cjs/src/mkdirp-native.js",".././node_modules/mkdirp/dist/cjs/src/opts-arg.js",".././node_modules/mkdirp/dist/cjs/src/path-arg.js",".././node_modules/mkdirp/dist/cjs/src/use-native.js",".././node_modules/tunnel/index.js",".././node_modules/tunnel/lib/tunnel.js",".././node_modules/uuid/dist/index.js",".././node_modules/uuid/dist/md5.js",".././node_modules/uuid/dist/nil.js",".././node_modules/uuid/dist/parse.js",".././node_modules/uuid/dist/regex.js",".././node_modules/uuid/dist/rng.js",".././node_modules/uuid/dist/sha1.js",".././node_modules/uuid/dist/stringify.js",".././node_modules/uuid/dist/v1.js",".././node_modules/uuid/dist/v3.js",".././node_modules/uuid/dist/v35.js",".././node_modules/uuid/dist/v4.js",".././node_modules/uuid/dist/v5.js",".././node_modules/uuid/dist/validate.js",".././node_modules/uuid/dist/version.js",".././src/evaluation.js",".././src/inputs/architecture.js",".././src/inputs/binary.js",".././src/inputs/callback.js",".././src/inputs/check.js",".././src/inputs/comments.js",".././src/inputs/encoder-version.js",".././src/inputs/encrypt.js",".././src/inputs/input.js",".././src/inputs/license.js",".././src/inputs/loader.js",".././src/inputs/optimize.js",".././src/inputs/output.js",".././src/inputs/passphrase.js",".././src/inputs/php-target-version.js",".././src/inputs/preamble.js",".././src/inputs/reflection.js",".././src/inputs/template.js",".././src/inputs/trial.js",".././src/main.js",".././src/templates/choose.js",".././src/templates/laravel.js",".././src/validate.js","../external node-commonjs \"assert\"","../external node-commonjs \"buffer\"","../external node-commonjs \"child_process\"","../external node-commonjs \"crypto\"","../external node-commonjs \"events\"","../external node-commonjs \"fs\"","../external node-commonjs \"http\"","../external node-commonjs \"https\"","../external node-commonjs \"net\"","../external node-commonjs \"node:assert\"","../external node-commonjs \"node:crypto\"","../external node-commonjs \"node:events\"","../external node-commonjs \"node:fs\"","../external node-commonjs \"node:path\"","../external node-commonjs \"node:stream\"","../external node-commonjs \"node:string_decoder\"","../external node-commonjs \"os\"","../external node-commonjs \"path\"","../external node-commonjs \"process\"","../external node-commonjs \"string_decoder\"","../external node-commonjs \"timers\"","../external node-commonjs \"tls\"","../external node-commonjs \"util\"","../external node-commonjs \"zlib\"",".././node_modules/@isaacs/fs-minipass/dist/commonjs/index.js",".././node_modules/chownr/dist/commonjs/index.js",".././node_modules/minipass/dist/commonjs/index.js",".././node_modules/minizlib/dist/commonjs/constants.js",".././node_modules/minizlib/dist/commonjs/index.js",".././node_modules/tar/dist/commonjs/create.js",".././node_modules/tar/dist/commonjs/cwd-error.js",".././node_modules/tar/dist/commonjs/extract.js",".././node_modules/tar/dist/commonjs/get-write-flag.js",".././node_modules/tar/dist/commonjs/header.js",".././node_modules/tar/dist/commonjs/index.js",".././node_modules/tar/dist/commonjs/large-numbers.js",".././node_modules/tar/dist/commonjs/list.js",".././node_modules/tar/dist/commonjs/make-command.js",".././node_modules/tar/dist/commonjs/mkdir.js",".././node_modules/tar/dist/commonjs/mode-fix.js",".././node_modules/tar/dist/commonjs/normalize-unicode.js",".././node_modules/tar/dist/commonjs/normalize-windows-path.js",".././node_modules/tar/dist/commonjs/options.js",".././node_modules/tar/dist/commonjs/pack.js",".././node_modules/tar/dist/commonjs/parse.js",".././node_modules/tar/dist/commonjs/path-reservations.js",".././node_modules/tar/dist/commonjs/pax.js",".././node_modules/tar/dist/commonjs/read-entry.js",".././node_modules/tar/dist/commonjs/replace.js",".././node_modules/tar/dist/commonjs/strip-absolute-path.js",".././node_modules/tar/dist/commonjs/strip-trailing-slashes.js",".././node_modules/tar/dist/commonjs/symlink-error.js",".././node_modules/tar/dist/commonjs/types.js",".././node_modules/tar/dist/commonjs/unpack.js",".././node_modules/tar/dist/commonjs/update.js",".././node_modules/tar/dist/commonjs/warn-method.js",".././node_modules/tar/dist/commonjs/winchars.js",".././node_modules/tar/dist/commonjs/write-entry.js",".././node_modules/tar/node_modules/yallist/dist/commonjs/index.js","../webpack/bootstrap","../webpack/runtime/compat",".././src/index.js"],"sourcesContent":["\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.issue = exports.issueCommand = void 0;\nconst os = __importStar(require(\"os\"));\nconst utils_1 = require(\"./utils\");\n/**\n * Commands\n *\n * Command Format:\n *   ::name key=value,key=value::message\n *\n * Examples:\n *   ::warning::This is the message\n *   ::set-env name=MY_VAR::some value\n */\nfunction issueCommand(command, properties, message) {\n    const cmd = new Command(command, properties, message);\n    process.stdout.write(cmd.toString() + os.EOL);\n}\nexports.issueCommand = issueCommand;\nfunction issue(name, message = '') {\n    issueCommand(name, {}, message);\n}\nexports.issue = issue;\nconst CMD_STRING = '::';\nclass Command {\n    constructor(command, properties, message) {\n        if (!command) {\n            command = 'missing.command';\n        }\n        this.command = command;\n        this.properties = properties;\n        this.message = message;\n    }\n    toString() {\n        let cmdStr = CMD_STRING + this.command;\n        if (this.properties && Object.keys(this.properties).length > 0) {\n            cmdStr += ' ';\n            let first = true;\n            for (const key in this.properties) {\n                if (this.properties.hasOwnProperty(key)) {\n                    const val = this.properties[key];\n                    if (val) {\n                        if (first) {\n                            first = false;\n                        }\n                        else {\n                            cmdStr += ',';\n                        }\n                        cmdStr += `${key}=${escapeProperty(val)}`;\n                    }\n                }\n            }\n        }\n        cmdStr += `${CMD_STRING}${escapeData(this.message)}`;\n        return cmdStr;\n    }\n}\nfunction escapeData(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A');\n}\nfunction escapeProperty(s) {\n    return utils_1.toCommandValue(s)\n        .replace(/%/g, '%25')\n        .replace(/\\r/g, '%0D')\n        .replace(/\\n/g, '%0A')\n        .replace(/:/g, '%3A')\n        .replace(/,/g, '%2C');\n}\n//# sourceMappingURL=command.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getIDToken = exports.getState = exports.saveState = exports.group = exports.endGroup = exports.startGroup = exports.info = exports.notice = exports.warning = exports.error = exports.debug = exports.isDebug = exports.setFailed = exports.setCommandEcho = exports.setOutput = exports.getBooleanInput = exports.getMultilineInput = exports.getInput = exports.addPath = exports.setSecret = exports.exportVariable = exports.ExitCode = void 0;\nconst command_1 = require(\"./command\");\nconst file_command_1 = require(\"./file-command\");\nconst utils_1 = require(\"./utils\");\nconst os = __importStar(require(\"os\"));\nconst path = __importStar(require(\"path\"));\nconst oidc_utils_1 = require(\"./oidc-utils\");\n/**\n * The code to exit an action\n */\nvar ExitCode;\n(function (ExitCode) {\n    /**\n     * A code indicating that the action was successful\n     */\n    ExitCode[ExitCode[\"Success\"] = 0] = \"Success\";\n    /**\n     * A code indicating that the action was a failure\n     */\n    ExitCode[ExitCode[\"Failure\"] = 1] = \"Failure\";\n})(ExitCode = exports.ExitCode || (exports.ExitCode = {}));\n//-----------------------------------------------------------------------\n// Variables\n//-----------------------------------------------------------------------\n/**\n * Sets env variable for this action and future actions in the job\n * @param name the name of the variable to set\n * @param val the value of the variable. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction exportVariable(name, val) {\n    const convertedVal = utils_1.toCommandValue(val);\n    process.env[name] = convertedVal;\n    const filePath = process.env['GITHUB_ENV'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('ENV', file_command_1.prepareKeyValueMessage(name, val));\n    }\n    command_1.issueCommand('set-env', { name }, convertedVal);\n}\nexports.exportVariable = exportVariable;\n/**\n * Registers a secret which will get masked from logs\n * @param secret value of the secret\n */\nfunction setSecret(secret) {\n    command_1.issueCommand('add-mask', {}, secret);\n}\nexports.setSecret = setSecret;\n/**\n * Prepends inputPath to the PATH (for this action and future actions)\n * @param inputPath\n */\nfunction addPath(inputPath) {\n    const filePath = process.env['GITHUB_PATH'] || '';\n    if (filePath) {\n        file_command_1.issueFileCommand('PATH', inputPath);\n    }\n    else {\n        command_1.issueCommand('add-path', {}, inputPath);\n    }\n    process.env['PATH'] = `${inputPath}${path.delimiter}${process.env['PATH']}`;\n}\nexports.addPath = addPath;\n/**\n * Gets the value of an input.\n * Unless trimWhitespace is set to false in InputOptions, the value is also trimmed.\n * Returns an empty string if the value is not defined.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string\n */\nfunction getInput(name, options) {\n    const val = process.env[`INPUT_${name.replace(/ /g, '_').toUpperCase()}`] || '';\n    if (options && options.required && !val) {\n        throw new Error(`Input required and not supplied: ${name}`);\n    }\n    if (options && options.trimWhitespace === false) {\n        return val;\n    }\n    return val.trim();\n}\nexports.getInput = getInput;\n/**\n * Gets the values of an multiline input.  Each value is also trimmed.\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   string[]\n *\n */\nfunction getMultilineInput(name, options) {\n    const inputs = getInput(name, options)\n        .split('\\n')\n        .filter(x => x !== '');\n    if (options && options.trimWhitespace === false) {\n        return inputs;\n    }\n    return inputs.map(input => input.trim());\n}\nexports.getMultilineInput = getMultilineInput;\n/**\n * Gets the input value of the boolean type in the YAML 1.2 \"core schema\" specification.\n * Support boolean input list: `true | True | TRUE | false | False | FALSE` .\n * The return value is also in boolean type.\n * ref: https://yaml.org/spec/1.2/spec.html#id2804923\n *\n * @param     name     name of the input to get\n * @param     options  optional. See InputOptions.\n * @returns   boolean\n */\nfunction getBooleanInput(name, options) {\n    const trueValue = ['true', 'True', 'TRUE'];\n    const falseValue = ['false', 'False', 'FALSE'];\n    const val = getInput(name, options);\n    if (trueValue.includes(val))\n        return true;\n    if (falseValue.includes(val))\n        return false;\n    throw new TypeError(`Input does not meet YAML 1.2 \"Core Schema\" specification: ${name}\\n` +\n        `Support boolean input list: \\`true | True | TRUE | false | False | FALSE\\``);\n}\nexports.getBooleanInput = getBooleanInput;\n/**\n * Sets the value of an output.\n *\n * @param     name     name of the output to set\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction setOutput(name, value) {\n    const filePath = process.env['GITHUB_OUTPUT'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('OUTPUT', file_command_1.prepareKeyValueMessage(name, value));\n    }\n    process.stdout.write(os.EOL);\n    command_1.issueCommand('set-output', { name }, utils_1.toCommandValue(value));\n}\nexports.setOutput = setOutput;\n/**\n * Enables or disables the echoing of commands into stdout for the rest of the step.\n * Echoing is disabled by default if ACTIONS_STEP_DEBUG is not set.\n *\n */\nfunction setCommandEcho(enabled) {\n    command_1.issue('echo', enabled ? 'on' : 'off');\n}\nexports.setCommandEcho = setCommandEcho;\n//-----------------------------------------------------------------------\n// Results\n//-----------------------------------------------------------------------\n/**\n * Sets the action status to failed.\n * When the action exits it will be with an exit code of 1\n * @param message add error issue message\n */\nfunction setFailed(message) {\n    process.exitCode = ExitCode.Failure;\n    error(message);\n}\nexports.setFailed = setFailed;\n//-----------------------------------------------------------------------\n// Logging Commands\n//-----------------------------------------------------------------------\n/**\n * Gets whether Actions Step Debug is on or not\n */\nfunction isDebug() {\n    return process.env['RUNNER_DEBUG'] === '1';\n}\nexports.isDebug = isDebug;\n/**\n * Writes debug message to user log\n * @param message debug message\n */\nfunction debug(message) {\n    command_1.issueCommand('debug', {}, message);\n}\nexports.debug = debug;\n/**\n * Adds an error issue\n * @param message error issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction error(message, properties = {}) {\n    command_1.issueCommand('error', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.error = error;\n/**\n * Adds a warning issue\n * @param message warning issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction warning(message, properties = {}) {\n    command_1.issueCommand('warning', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.warning = warning;\n/**\n * Adds a notice issue\n * @param message notice issue message. Errors will be converted to string via toString()\n * @param properties optional properties to add to the annotation.\n */\nfunction notice(message, properties = {}) {\n    command_1.issueCommand('notice', utils_1.toCommandProperties(properties), message instanceof Error ? message.toString() : message);\n}\nexports.notice = notice;\n/**\n * Writes info to log with console.log.\n * @param message info message\n */\nfunction info(message) {\n    process.stdout.write(message + os.EOL);\n}\nexports.info = info;\n/**\n * Begin an output group.\n *\n * Output until the next `groupEnd` will be foldable in this group\n *\n * @param name The name of the output group\n */\nfunction startGroup(name) {\n    command_1.issue('group', name);\n}\nexports.startGroup = startGroup;\n/**\n * End an output group.\n */\nfunction endGroup() {\n    command_1.issue('endgroup');\n}\nexports.endGroup = endGroup;\n/**\n * Wrap an asynchronous function call in a group.\n *\n * Returns the same type as the function itself.\n *\n * @param name The name of the group\n * @param fn The function to wrap in the group\n */\nfunction group(name, fn) {\n    return __awaiter(this, void 0, void 0, function* () {\n        startGroup(name);\n        let result;\n        try {\n            result = yield fn();\n        }\n        finally {\n            endGroup();\n        }\n        return result;\n    });\n}\nexports.group = group;\n//-----------------------------------------------------------------------\n// Wrapper action state\n//-----------------------------------------------------------------------\n/**\n * Saves state for current action, the state can only be retrieved by this action's post job execution.\n *\n * @param     name     name of the state to store\n * @param     value    value to store. Non-string values will be converted to a string via JSON.stringify\n */\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction saveState(name, value) {\n    const filePath = process.env['GITHUB_STATE'] || '';\n    if (filePath) {\n        return file_command_1.issueFileCommand('STATE', file_command_1.prepareKeyValueMessage(name, value));\n    }\n    command_1.issueCommand('save-state', { name }, utils_1.toCommandValue(value));\n}\nexports.saveState = saveState;\n/**\n * Gets the value of an state set by this action's main execution.\n *\n * @param     name     name of the state to get\n * @returns   string\n */\nfunction getState(name) {\n    return process.env[`STATE_${name}`] || '';\n}\nexports.getState = getState;\nfunction getIDToken(aud) {\n    return __awaiter(this, void 0, void 0, function* () {\n        return yield oidc_utils_1.OidcClient.getIDToken(aud);\n    });\n}\nexports.getIDToken = getIDToken;\n/**\n * Summary exports\n */\nvar summary_1 = require(\"./summary\");\nObject.defineProperty(exports, \"summary\", { enumerable: true, get: function () { return summary_1.summary; } });\n/**\n * @deprecated use core.summary\n */\nvar summary_2 = require(\"./summary\");\nObject.defineProperty(exports, \"markdownSummary\", { enumerable: true, get: function () { return summary_2.markdownSummary; } });\n/**\n * Path exports\n */\nvar path_utils_1 = require(\"./path-utils\");\nObject.defineProperty(exports, \"toPosixPath\", { enumerable: true, get: function () { return path_utils_1.toPosixPath; } });\nObject.defineProperty(exports, \"toWin32Path\", { enumerable: true, get: function () { return path_utils_1.toWin32Path; } });\nObject.defineProperty(exports, \"toPlatformPath\", { enumerable: true, get: function () { return path_utils_1.toPlatformPath; } });\n//# sourceMappingURL=core.js.map","\"use strict\";\n// For internal use, subject to change.\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.prepareKeyValueMessage = exports.issueFileCommand = void 0;\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nconst fs = __importStar(require(\"fs\"));\nconst os = __importStar(require(\"os\"));\nconst uuid_1 = require(\"uuid\");\nconst utils_1 = require(\"./utils\");\nfunction issueFileCommand(command, message) {\n    const filePath = process.env[`GITHUB_${command}`];\n    if (!filePath) {\n        throw new Error(`Unable to find environment variable for file command ${command}`);\n    }\n    if (!fs.existsSync(filePath)) {\n        throw new Error(`Missing file at path: ${filePath}`);\n    }\n    fs.appendFileSync(filePath, `${utils_1.toCommandValue(message)}${os.EOL}`, {\n        encoding: 'utf8'\n    });\n}\nexports.issueFileCommand = issueFileCommand;\nfunction prepareKeyValueMessage(key, value) {\n    const delimiter = `ghadelimiter_${uuid_1.v4()}`;\n    const convertedValue = utils_1.toCommandValue(value);\n    // These should realistically never happen, but just in case someone finds a\n    // way to exploit uuid generation let's not allow keys or values that contain\n    // the delimiter.\n    if (key.includes(delimiter)) {\n        throw new Error(`Unexpected input: name should not contain the delimiter \"${delimiter}\"`);\n    }\n    if (convertedValue.includes(delimiter)) {\n        throw new Error(`Unexpected input: value should not contain the delimiter \"${delimiter}\"`);\n    }\n    return `${key}<<${delimiter}${os.EOL}${convertedValue}${os.EOL}${delimiter}`;\n}\nexports.prepareKeyValueMessage = prepareKeyValueMessage;\n//# sourceMappingURL=file-command.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.OidcClient = void 0;\nconst http_client_1 = require(\"@actions/http-client\");\nconst auth_1 = require(\"@actions/http-client/lib/auth\");\nconst core_1 = require(\"./core\");\nclass OidcClient {\n    static createHttpClient(allowRetry = true, maxRetry = 10) {\n        const requestOptions = {\n            allowRetries: allowRetry,\n            maxRetries: maxRetry\n        };\n        return new http_client_1.HttpClient('actions/oidc-client', [new auth_1.BearerCredentialHandler(OidcClient.getRequestToken())], requestOptions);\n    }\n    static getRequestToken() {\n        const token = process.env['ACTIONS_ID_TOKEN_REQUEST_TOKEN'];\n        if (!token) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_TOKEN env variable');\n        }\n        return token;\n    }\n    static getIDTokenUrl() {\n        const runtimeUrl = process.env['ACTIONS_ID_TOKEN_REQUEST_URL'];\n        if (!runtimeUrl) {\n            throw new Error('Unable to get ACTIONS_ID_TOKEN_REQUEST_URL env variable');\n        }\n        return runtimeUrl;\n    }\n    static getCall(id_token_url) {\n        var _a;\n        return __awaiter(this, void 0, void 0, function* () {\n            const httpclient = OidcClient.createHttpClient();\n            const res = yield httpclient\n                .getJson(id_token_url)\n                .catch(error => {\n                throw new Error(`Failed to get ID Token. \\n \n        Error Code : ${error.statusCode}\\n \n        Error Message: ${error.message}`);\n            });\n            const id_token = (_a = res.result) === null || _a === void 0 ? void 0 : _a.value;\n            if (!id_token) {\n                throw new Error('Response json body do not have ID Token field');\n            }\n            return id_token;\n        });\n    }\n    static getIDToken(audience) {\n        return __awaiter(this, void 0, void 0, function* () {\n            try {\n                // New ID Token is requested from action service\n                let id_token_url = OidcClient.getIDTokenUrl();\n                if (audience) {\n                    const encodedAudience = encodeURIComponent(audience);\n                    id_token_url = `${id_token_url}&audience=${encodedAudience}`;\n                }\n                core_1.debug(`ID token url is ${id_token_url}`);\n                const id_token = yield OidcClient.getCall(id_token_url);\n                core_1.setSecret(id_token);\n                return id_token;\n            }\n            catch (error) {\n                throw new Error(`Error message: ${error.message}`);\n            }\n        });\n    }\n}\nexports.OidcClient = OidcClient;\n//# sourceMappingURL=oidc-utils.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toPlatformPath = exports.toWin32Path = exports.toPosixPath = void 0;\nconst path = __importStar(require(\"path\"));\n/**\n * toPosixPath converts the given path to the posix form. On Windows, \\\\ will be\n * replaced with /.\n *\n * @param pth. Path to transform.\n * @return string Posix path.\n */\nfunction toPosixPath(pth) {\n    return pth.replace(/[\\\\]/g, '/');\n}\nexports.toPosixPath = toPosixPath;\n/**\n * toWin32Path converts the given path to the win32 form. On Linux, / will be\n * replaced with \\\\.\n *\n * @param pth. Path to transform.\n * @return string Win32 path.\n */\nfunction toWin32Path(pth) {\n    return pth.replace(/[/]/g, '\\\\');\n}\nexports.toWin32Path = toWin32Path;\n/**\n * toPlatformPath converts the given path to a platform-specific path. It does\n * this by replacing instances of / and \\ with the platform-specific path\n * separator.\n *\n * @param pth The path to platformize.\n * @return string The platform-specific path.\n */\nfunction toPlatformPath(pth) {\n    return pth.replace(/[/\\\\]/g, path.sep);\n}\nexports.toPlatformPath = toPlatformPath;\n//# sourceMappingURL=path-utils.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.summary = exports.markdownSummary = exports.SUMMARY_DOCS_URL = exports.SUMMARY_ENV_VAR = void 0;\nconst os_1 = require(\"os\");\nconst fs_1 = require(\"fs\");\nconst { access, appendFile, writeFile } = fs_1.promises;\nexports.SUMMARY_ENV_VAR = 'GITHUB_STEP_SUMMARY';\nexports.SUMMARY_DOCS_URL = 'https://docs.github.com/actions/using-workflows/workflow-commands-for-github-actions#adding-a-job-summary';\nclass Summary {\n    constructor() {\n        this._buffer = '';\n    }\n    /**\n     * Finds the summary file path from the environment, rejects if env var is not found or file does not exist\n     * Also checks r/w permissions.\n     *\n     * @returns step summary file path\n     */\n    filePath() {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._filePath) {\n                return this._filePath;\n            }\n            const pathFromEnv = process.env[exports.SUMMARY_ENV_VAR];\n            if (!pathFromEnv) {\n                throw new Error(`Unable to find environment variable for $${exports.SUMMARY_ENV_VAR}. Check if your runtime environment supports job summaries.`);\n            }\n            try {\n                yield access(pathFromEnv, fs_1.constants.R_OK | fs_1.constants.W_OK);\n            }\n            catch (_a) {\n                throw new Error(`Unable to access summary file: '${pathFromEnv}'. Check if the file has correct read/write permissions.`);\n            }\n            this._filePath = pathFromEnv;\n            return this._filePath;\n        });\n    }\n    /**\n     * Wraps content in an HTML tag, adding any HTML attributes\n     *\n     * @param {string} tag HTML tag to wrap\n     * @param {string | null} content content within the tag\n     * @param {[attribute: string]: string} attrs key-value list of HTML attributes to add\n     *\n     * @returns {string} content wrapped in HTML element\n     */\n    wrap(tag, content, attrs = {}) {\n        const htmlAttrs = Object.entries(attrs)\n            .map(([key, value]) => ` ${key}=\"${value}\"`)\n            .join('');\n        if (!content) {\n            return `<${tag}${htmlAttrs}>`;\n        }\n        return `<${tag}${htmlAttrs}>${content}</${tag}>`;\n    }\n    /**\n     * Writes text in the buffer to the summary buffer file and empties buffer. Will append by default.\n     *\n     * @param {SummaryWriteOptions} [options] (optional) options for write operation\n     *\n     * @returns {Promise<Summary>} summary instance\n     */\n    write(options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const overwrite = !!(options === null || options === void 0 ? void 0 : options.overwrite);\n            const filePath = yield this.filePath();\n            const writeFunc = overwrite ? writeFile : appendFile;\n            yield writeFunc(filePath, this._buffer, { encoding: 'utf8' });\n            return this.emptyBuffer();\n        });\n    }\n    /**\n     * Clears the summary buffer and wipes the summary file\n     *\n     * @returns {Summary} summary instance\n     */\n    clear() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.emptyBuffer().write({ overwrite: true });\n        });\n    }\n    /**\n     * Returns the current summary buffer as a string\n     *\n     * @returns {string} string of summary buffer\n     */\n    stringify() {\n        return this._buffer;\n    }\n    /**\n     * If the summary buffer is empty\n     *\n     * @returns {boolen} true if the buffer is empty\n     */\n    isEmptyBuffer() {\n        return this._buffer.length === 0;\n    }\n    /**\n     * Resets the summary buffer without writing to summary file\n     *\n     * @returns {Summary} summary instance\n     */\n    emptyBuffer() {\n        this._buffer = '';\n        return this;\n    }\n    /**\n     * Adds raw text to the summary buffer\n     *\n     * @param {string} text content to add\n     * @param {boolean} [addEOL=false] (optional) append an EOL to the raw text (default: false)\n     *\n     * @returns {Summary} summary instance\n     */\n    addRaw(text, addEOL = false) {\n        this._buffer += text;\n        return addEOL ? this.addEOL() : this;\n    }\n    /**\n     * Adds the operating system-specific end-of-line marker to the buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addEOL() {\n        return this.addRaw(os_1.EOL);\n    }\n    /**\n     * Adds an HTML codeblock to the summary buffer\n     *\n     * @param {string} code content to render within fenced code block\n     * @param {string} lang (optional) language to syntax highlight code\n     *\n     * @returns {Summary} summary instance\n     */\n    addCodeBlock(code, lang) {\n        const attrs = Object.assign({}, (lang && { lang }));\n        const element = this.wrap('pre', this.wrap('code', code), attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML list to the summary buffer\n     *\n     * @param {string[]} items list of items to render\n     * @param {boolean} [ordered=false] (optional) if the rendered list should be ordered or not (default: false)\n     *\n     * @returns {Summary} summary instance\n     */\n    addList(items, ordered = false) {\n        const tag = ordered ? 'ol' : 'ul';\n        const listItems = items.map(item => this.wrap('li', item)).join('');\n        const element = this.wrap(tag, listItems);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML table to the summary buffer\n     *\n     * @param {SummaryTableCell[]} rows table rows\n     *\n     * @returns {Summary} summary instance\n     */\n    addTable(rows) {\n        const tableBody = rows\n            .map(row => {\n            const cells = row\n                .map(cell => {\n                if (typeof cell === 'string') {\n                    return this.wrap('td', cell);\n                }\n                const { header, data, colspan, rowspan } = cell;\n                const tag = header ? 'th' : 'td';\n                const attrs = Object.assign(Object.assign({}, (colspan && { colspan })), (rowspan && { rowspan }));\n                return this.wrap(tag, data, attrs);\n            })\n                .join('');\n            return this.wrap('tr', cells);\n        })\n            .join('');\n        const element = this.wrap('table', tableBody);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds a collapsable HTML details element to the summary buffer\n     *\n     * @param {string} label text for the closed state\n     * @param {string} content collapsable content\n     *\n     * @returns {Summary} summary instance\n     */\n    addDetails(label, content) {\n        const element = this.wrap('details', this.wrap('summary', label) + content);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML image tag to the summary buffer\n     *\n     * @param {string} src path to the image you to embed\n     * @param {string} alt text description of the image\n     * @param {SummaryImageOptions} options (optional) addition image attributes\n     *\n     * @returns {Summary} summary instance\n     */\n    addImage(src, alt, options) {\n        const { width, height } = options || {};\n        const attrs = Object.assign(Object.assign({}, (width && { width })), (height && { height }));\n        const element = this.wrap('img', null, Object.assign({ src, alt }, attrs));\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML section heading element\n     *\n     * @param {string} text heading text\n     * @param {number | string} [level=1] (optional) the heading level, default: 1\n     *\n     * @returns {Summary} summary instance\n     */\n    addHeading(text, level) {\n        const tag = `h${level}`;\n        const allowedTag = ['h1', 'h2', 'h3', 'h4', 'h5', 'h6'].includes(tag)\n            ? tag\n            : 'h1';\n        const element = this.wrap(allowedTag, text);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML thematic break (<hr>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addSeparator() {\n        const element = this.wrap('hr', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML line break (<br>) to the summary buffer\n     *\n     * @returns {Summary} summary instance\n     */\n    addBreak() {\n        const element = this.wrap('br', null);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML blockquote to the summary buffer\n     *\n     * @param {string} text quote text\n     * @param {string} cite (optional) citation url\n     *\n     * @returns {Summary} summary instance\n     */\n    addQuote(text, cite) {\n        const attrs = Object.assign({}, (cite && { cite }));\n        const element = this.wrap('blockquote', text, attrs);\n        return this.addRaw(element).addEOL();\n    }\n    /**\n     * Adds an HTML anchor tag to the summary buffer\n     *\n     * @param {string} text link text/content\n     * @param {string} href hyperlink\n     *\n     * @returns {Summary} summary instance\n     */\n    addLink(text, href) {\n        const element = this.wrap('a', text, { href });\n        return this.addRaw(element).addEOL();\n    }\n}\nconst _summary = new Summary();\n/**\n * @deprecated use `core.summary`\n */\nexports.markdownSummary = _summary;\nexports.summary = _summary;\n//# sourceMappingURL=summary.js.map","\"use strict\";\n// We use any as a valid input type\n/* eslint-disable @typescript-eslint/no-explicit-any */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.toCommandProperties = exports.toCommandValue = void 0;\n/**\n * Sanitizes an input into a string so it can be passed into issueCommand safely\n * @param input input to sanitize into a string\n */\nfunction toCommandValue(input) {\n    if (input === null || input === undefined) {\n        return '';\n    }\n    else if (typeof input === 'string' || input instanceof String) {\n        return input;\n    }\n    return JSON.stringify(input);\n}\nexports.toCommandValue = toCommandValue;\n/**\n *\n * @param annotationProperties\n * @returns The command properties to send with the actual annotation command\n * See IssueCommandProperties: https://github.com/actions/runner/blob/main/src/Runner.Worker/ActionCommandManager.cs#L646\n */\nfunction toCommandProperties(annotationProperties) {\n    if (!Object.keys(annotationProperties).length) {\n        return {};\n    }\n    return {\n        title: annotationProperties.title,\n        file: annotationProperties.file,\n        line: annotationProperties.startLine,\n        endLine: annotationProperties.endLine,\n        col: annotationProperties.startColumn,\n        endColumn: annotationProperties.endColumn\n    };\n}\nexports.toCommandProperties = toCommandProperties;\n//# sourceMappingURL=utils.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getExecOutput = exports.exec = void 0;\nconst string_decoder_1 = require(\"string_decoder\");\nconst tr = __importStar(require(\"./toolrunner\"));\n/**\n * Exec a command.\n * Output will be streamed to the live console.\n * Returns promise with return code\n *\n * @param     commandLine        command to execute (can include additional args). Must be correctly escaped.\n * @param     args               optional arguments for tool. Escaping is handled by the lib.\n * @param     options            optional exec options.  See ExecOptions\n * @returns   Promise<number>    exit code\n */\nfunction exec(commandLine, args, options) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const commandArgs = tr.argStringToArray(commandLine);\n        if (commandArgs.length === 0) {\n            throw new Error(`Parameter 'commandLine' cannot be null or empty.`);\n        }\n        // Path to tool to execute should be first arg\n        const toolPath = commandArgs[0];\n        args = commandArgs.slice(1).concat(args || []);\n        const runner = new tr.ToolRunner(toolPath, args, options);\n        return runner.exec();\n    });\n}\nexports.exec = exec;\n/**\n * Exec a command and get the output.\n * Output will be streamed to the live console.\n * Returns promise with the exit code and collected stdout and stderr\n *\n * @param     commandLine           command to execute (can include additional args). Must be correctly escaped.\n * @param     args                  optional arguments for tool. Escaping is handled by the lib.\n * @param     options               optional exec options.  See ExecOptions\n * @returns   Promise<ExecOutput>   exit code, stdout, and stderr\n */\nfunction getExecOutput(commandLine, args, options) {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n        let stdout = '';\n        let stderr = '';\n        //Using string decoder covers the case where a mult-byte character is split\n        const stdoutDecoder = new string_decoder_1.StringDecoder('utf8');\n        const stderrDecoder = new string_decoder_1.StringDecoder('utf8');\n        const originalStdoutListener = (_a = options === null || options === void 0 ? void 0 : options.listeners) === null || _a === void 0 ? void 0 : _a.stdout;\n        const originalStdErrListener = (_b = options === null || options === void 0 ? void 0 : options.listeners) === null || _b === void 0 ? void 0 : _b.stderr;\n        const stdErrListener = (data) => {\n            stderr += stderrDecoder.write(data);\n            if (originalStdErrListener) {\n                originalStdErrListener(data);\n            }\n        };\n        const stdOutListener = (data) => {\n            stdout += stdoutDecoder.write(data);\n            if (originalStdoutListener) {\n                originalStdoutListener(data);\n            }\n        };\n        const listeners = Object.assign(Object.assign({}, options === null || options === void 0 ? void 0 : options.listeners), { stdout: stdOutListener, stderr: stdErrListener });\n        const exitCode = yield exec(commandLine, args, Object.assign(Object.assign({}, options), { listeners }));\n        //flush any remaining characters\n        stdout += stdoutDecoder.end();\n        stderr += stderrDecoder.end();\n        return {\n            exitCode,\n            stdout,\n            stderr\n        };\n    });\n}\nexports.getExecOutput = getExecOutput;\n//# sourceMappingURL=exec.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.argStringToArray = exports.ToolRunner = void 0;\nconst os = __importStar(require(\"os\"));\nconst events = __importStar(require(\"events\"));\nconst child = __importStar(require(\"child_process\"));\nconst path = __importStar(require(\"path\"));\nconst io = __importStar(require(\"@actions/io\"));\nconst ioUtil = __importStar(require(\"@actions/io/lib/io-util\"));\nconst timers_1 = require(\"timers\");\n/* eslint-disable @typescript-eslint/unbound-method */\nconst IS_WINDOWS = process.platform === 'win32';\n/*\n * Class for running command line tools. Handles quoting and arg parsing in a platform agnostic way.\n */\nclass ToolRunner extends events.EventEmitter {\n    constructor(toolPath, args, options) {\n        super();\n        if (!toolPath) {\n            throw new Error(\"Parameter 'toolPath' cannot be null or empty.\");\n        }\n        this.toolPath = toolPath;\n        this.args = args || [];\n        this.options = options || {};\n    }\n    _debug(message) {\n        if (this.options.listeners && this.options.listeners.debug) {\n            this.options.listeners.debug(message);\n        }\n    }\n    _getCommandString(options, noPrefix) {\n        const toolPath = this._getSpawnFileName();\n        const args = this._getSpawnArgs(options);\n        let cmd = noPrefix ? '' : '[command]'; // omit prefix when piped to a second tool\n        if (IS_WINDOWS) {\n            // Windows + cmd file\n            if (this._isCmdFile()) {\n                cmd += toolPath;\n                for (const a of args) {\n                    cmd += ` ${a}`;\n                }\n            }\n            // Windows + verbatim\n            else if (options.windowsVerbatimArguments) {\n                cmd += `\"${toolPath}\"`;\n                for (const a of args) {\n                    cmd += ` ${a}`;\n                }\n            }\n            // Windows (regular)\n            else {\n                cmd += this._windowsQuoteCmdArg(toolPath);\n                for (const a of args) {\n                    cmd += ` ${this._windowsQuoteCmdArg(a)}`;\n                }\n            }\n        }\n        else {\n            // OSX/Linux - this can likely be improved with some form of quoting.\n            // creating processes on Unix is fundamentally different than Windows.\n            // on Unix, execvp() takes an arg array.\n            cmd += toolPath;\n            for (const a of args) {\n                cmd += ` ${a}`;\n            }\n        }\n        return cmd;\n    }\n    _processLineBuffer(data, strBuffer, onLine) {\n        try {\n            let s = strBuffer + data.toString();\n            let n = s.indexOf(os.EOL);\n            while (n > -1) {\n                const line = s.substring(0, n);\n                onLine(line);\n                // the rest of the string ...\n                s = s.substring(n + os.EOL.length);\n                n = s.indexOf(os.EOL);\n            }\n            return s;\n        }\n        catch (err) {\n            // streaming lines to console is best effort.  Don't fail a build.\n            this._debug(`error processing line. Failed with error ${err}`);\n            return '';\n        }\n    }\n    _getSpawnFileName() {\n        if (IS_WINDOWS) {\n            if (this._isCmdFile()) {\n                return process.env['COMSPEC'] || 'cmd.exe';\n            }\n        }\n        return this.toolPath;\n    }\n    _getSpawnArgs(options) {\n        if (IS_WINDOWS) {\n            if (this._isCmdFile()) {\n                let argline = `/D /S /C \"${this._windowsQuoteCmdArg(this.toolPath)}`;\n                for (const a of this.args) {\n                    argline += ' ';\n                    argline += options.windowsVerbatimArguments\n                        ? a\n                        : this._windowsQuoteCmdArg(a);\n                }\n                argline += '\"';\n                return [argline];\n            }\n        }\n        return this.args;\n    }\n    _endsWith(str, end) {\n        return str.endsWith(end);\n    }\n    _isCmdFile() {\n        const upperToolPath = this.toolPath.toUpperCase();\n        return (this._endsWith(upperToolPath, '.CMD') ||\n            this._endsWith(upperToolPath, '.BAT'));\n    }\n    _windowsQuoteCmdArg(arg) {\n        // for .exe, apply the normal quoting rules that libuv applies\n        if (!this._isCmdFile()) {\n            return this._uvQuoteCmdArg(arg);\n        }\n        // otherwise apply quoting rules specific to the cmd.exe command line parser.\n        // the libuv rules are generic and are not designed specifically for cmd.exe\n        // command line parser.\n        //\n        // for a detailed description of the cmd.exe command line parser, refer to\n        // http://stackoverflow.com/questions/4094699/how-does-the-windows-command-interpreter-cmd-exe-parse-scripts/7970912#7970912\n        // need quotes for empty arg\n        if (!arg) {\n            return '\"\"';\n        }\n        // determine whether the arg needs to be quoted\n        const cmdSpecialChars = [\n            ' ',\n            '\\t',\n            '&',\n            '(',\n            ')',\n            '[',\n            ']',\n            '{',\n            '}',\n            '^',\n            '=',\n            ';',\n            '!',\n            \"'\",\n            '+',\n            ',',\n            '`',\n            '~',\n            '|',\n            '<',\n            '>',\n            '\"'\n        ];\n        let needsQuotes = false;\n        for (const char of arg) {\n            if (cmdSpecialChars.some(x => x === char)) {\n                needsQuotes = true;\n                break;\n            }\n        }\n        // short-circuit if quotes not needed\n        if (!needsQuotes) {\n            return arg;\n        }\n        // the following quoting rules are very similar to the rules that by libuv applies.\n        //\n        // 1) wrap the string in quotes\n        //\n        // 2) double-up quotes - i.e. \" => \"\"\n        //\n        //    this is different from the libuv quoting rules. libuv replaces \" with \\\", which unfortunately\n        //    doesn't work well with a cmd.exe command line.\n        //\n        //    note, replacing \" with \"\" also works well if the arg is passed to a downstream .NET console app.\n        //    for example, the command line:\n        //          foo.exe \"myarg:\"\"my val\"\"\"\n        //    is parsed by a .NET console app into an arg array:\n        //          [ \"myarg:\\\"my val\\\"\" ]\n        //    which is the same end result when applying libuv quoting rules. although the actual\n        //    command line from libuv quoting rules would look like:\n        //          foo.exe \"myarg:\\\"my val\\\"\"\n        //\n        // 3) double-up slashes that precede a quote,\n        //    e.g.  hello \\world    => \"hello \\world\"\n        //          hello\\\"world    => \"hello\\\\\"\"world\"\n        //          hello\\\\\"world   => \"hello\\\\\\\\\"\"world\"\n        //          hello world\\    => \"hello world\\\\\"\n        //\n        //    technically this is not required for a cmd.exe command line, or the batch argument parser.\n        //    the reasons for including this as a .cmd quoting rule are:\n        //\n        //    a) this is optimized for the scenario where the argument is passed from the .cmd file to an\n        //       external program. many programs (e.g. .NET console apps) rely on the slash-doubling rule.\n        //\n        //    b) it's what we've been doing previously (by deferring to node default behavior) and we\n        //       haven't heard any complaints about that aspect.\n        //\n        // note, a weakness of the quoting rules chosen here, is that % is not escaped. in fact, % cannot be\n        // escaped when used on the command line directly - even though within a .cmd file % can be escaped\n        // by using %%.\n        //\n        // the saving grace is, on the command line, %var% is left as-is if var is not defined. this contrasts\n        // the line parsing rules within a .cmd file, where if var is not defined it is replaced with nothing.\n        //\n        // one option that was explored was replacing % with ^% - i.e. %var% => ^%var^%. this hack would\n        // often work, since it is unlikely that var^ would exist, and the ^ character is removed when the\n        // variable is used. the problem, however, is that ^ is not removed when %* is used to pass the args\n        // to an external program.\n        //\n        // an unexplored potential solution for the % escaping problem, is to create a wrapper .cmd file.\n        // % can be escaped within a .cmd file.\n        let reverse = '\"';\n        let quoteHit = true;\n        for (let i = arg.length; i > 0; i--) {\n            // walk the string in reverse\n            reverse += arg[i - 1];\n            if (quoteHit && arg[i - 1] === '\\\\') {\n                reverse += '\\\\'; // double the slash\n            }\n            else if (arg[i - 1] === '\"') {\n                quoteHit = true;\n                reverse += '\"'; // double the quote\n            }\n            else {\n                quoteHit = false;\n            }\n        }\n        reverse += '\"';\n        return reverse\n            .split('')\n            .reverse()\n            .join('');\n    }\n    _uvQuoteCmdArg(arg) {\n        // Tool runner wraps child_process.spawn() and needs to apply the same quoting as\n        // Node in certain cases where the undocumented spawn option windowsVerbatimArguments\n        // is used.\n        //\n        // Since this function is a port of quote_cmd_arg from Node 4.x (technically, lib UV,\n        // see https://github.com/nodejs/node/blob/v4.x/deps/uv/src/win/process.c for details),\n        // pasting copyright notice from Node within this function:\n        //\n        //      Copyright Joyent, Inc. and other Node contributors. All rights reserved.\n        //\n        //      Permission is hereby granted, free of charge, to any person obtaining a copy\n        //      of this software and associated documentation files (the \"Software\"), to\n        //      deal in the Software without restriction, including without limitation the\n        //      rights to use, copy, modify, merge, publish, distribute, sublicense, and/or\n        //      sell copies of the Software, and to permit persons to whom the Software is\n        //      furnished to do so, subject to the following conditions:\n        //\n        //      The above copyright notice and this permission notice shall be included in\n        //      all copies or substantial portions of the Software.\n        //\n        //      THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n        //      IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n        //      FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n        //      AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n        //      LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n        //      FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS\n        //      IN THE SOFTWARE.\n        if (!arg) {\n            // Need double quotation for empty argument\n            return '\"\"';\n        }\n        if (!arg.includes(' ') && !arg.includes('\\t') && !arg.includes('\"')) {\n            // No quotation needed\n            return arg;\n        }\n        if (!arg.includes('\"') && !arg.includes('\\\\')) {\n            // No embedded double quotes or backslashes, so I can just wrap\n            // quote marks around the whole thing.\n            return `\"${arg}\"`;\n        }\n        // Expected input/output:\n        //   input : hello\"world\n        //   output: \"hello\\\"world\"\n        //   input : hello\"\"world\n        //   output: \"hello\\\"\\\"world\"\n        //   input : hello\\world\n        //   output: hello\\world\n        //   input : hello\\\\world\n        //   output: hello\\\\world\n        //   input : hello\\\"world\n        //   output: \"hello\\\\\\\"world\"\n        //   input : hello\\\\\"world\n        //   output: \"hello\\\\\\\\\\\"world\"\n        //   input : hello world\\\n        //   output: \"hello world\\\\\" - note the comment in libuv actually reads \"hello world\\\"\n        //                             but it appears the comment is wrong, it should be \"hello world\\\\\"\n        let reverse = '\"';\n        let quoteHit = true;\n        for (let i = arg.length; i > 0; i--) {\n            // walk the string in reverse\n            reverse += arg[i - 1];\n            if (quoteHit && arg[i - 1] === '\\\\') {\n                reverse += '\\\\';\n            }\n            else if (arg[i - 1] === '\"') {\n                quoteHit = true;\n                reverse += '\\\\';\n            }\n            else {\n                quoteHit = false;\n            }\n        }\n        reverse += '\"';\n        return reverse\n            .split('')\n            .reverse()\n            .join('');\n    }\n    _cloneExecOptions(options) {\n        options = options || {};\n        const result = {\n            cwd: options.cwd || process.cwd(),\n            env: options.env || process.env,\n            silent: options.silent || false,\n            windowsVerbatimArguments: options.windowsVerbatimArguments || false,\n            failOnStdErr: options.failOnStdErr || false,\n            ignoreReturnCode: options.ignoreReturnCode || false,\n            delay: options.delay || 10000\n        };\n        result.outStream = options.outStream || process.stdout;\n        result.errStream = options.errStream || process.stderr;\n        return result;\n    }\n    _getSpawnOptions(options, toolPath) {\n        options = options || {};\n        const result = {};\n        result.cwd = options.cwd;\n        result.env = options.env;\n        result['windowsVerbatimArguments'] =\n            options.windowsVerbatimArguments || this._isCmdFile();\n        if (options.windowsVerbatimArguments) {\n            result.argv0 = `\"${toolPath}\"`;\n        }\n        return result;\n    }\n    /**\n     * Exec a tool.\n     * Output will be streamed to the live console.\n     * Returns promise with return code\n     *\n     * @param     tool     path to tool to exec\n     * @param     options  optional exec options.  See ExecOptions\n     * @returns   number\n     */\n    exec() {\n        return __awaiter(this, void 0, void 0, function* () {\n            // root the tool path if it is unrooted and contains relative pathing\n            if (!ioUtil.isRooted(this.toolPath) &&\n                (this.toolPath.includes('/') ||\n                    (IS_WINDOWS && this.toolPath.includes('\\\\')))) {\n                // prefer options.cwd if it is specified, however options.cwd may also need to be rooted\n                this.toolPath = path.resolve(process.cwd(), this.options.cwd || process.cwd(), this.toolPath);\n            }\n            // if the tool is only a file name, then resolve it from the PATH\n            // otherwise verify it exists (add extension on Windows if necessary)\n            this.toolPath = yield io.which(this.toolPath, true);\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                this._debug(`exec tool: ${this.toolPath}`);\n                this._debug('arguments:');\n                for (const arg of this.args) {\n                    this._debug(`   ${arg}`);\n                }\n                const optionsNonNull = this._cloneExecOptions(this.options);\n                if (!optionsNonNull.silent && optionsNonNull.outStream) {\n                    optionsNonNull.outStream.write(this._getCommandString(optionsNonNull) + os.EOL);\n                }\n                const state = new ExecState(optionsNonNull, this.toolPath);\n                state.on('debug', (message) => {\n                    this._debug(message);\n                });\n                if (this.options.cwd && !(yield ioUtil.exists(this.options.cwd))) {\n                    return reject(new Error(`The cwd: ${this.options.cwd} does not exist!`));\n                }\n                const fileName = this._getSpawnFileName();\n                const cp = child.spawn(fileName, this._getSpawnArgs(optionsNonNull), this._getSpawnOptions(this.options, fileName));\n                let stdbuffer = '';\n                if (cp.stdout) {\n                    cp.stdout.on('data', (data) => {\n                        if (this.options.listeners && this.options.listeners.stdout) {\n                            this.options.listeners.stdout(data);\n                        }\n                        if (!optionsNonNull.silent && optionsNonNull.outStream) {\n                            optionsNonNull.outStream.write(data);\n                        }\n                        stdbuffer = this._processLineBuffer(data, stdbuffer, (line) => {\n                            if (this.options.listeners && this.options.listeners.stdline) {\n                                this.options.listeners.stdline(line);\n                            }\n                        });\n                    });\n                }\n                let errbuffer = '';\n                if (cp.stderr) {\n                    cp.stderr.on('data', (data) => {\n                        state.processStderr = true;\n                        if (this.options.listeners && this.options.listeners.stderr) {\n                            this.options.listeners.stderr(data);\n                        }\n                        if (!optionsNonNull.silent &&\n                            optionsNonNull.errStream &&\n                            optionsNonNull.outStream) {\n                            const s = optionsNonNull.failOnStdErr\n                                ? optionsNonNull.errStream\n                                : optionsNonNull.outStream;\n                            s.write(data);\n                        }\n                        errbuffer = this._processLineBuffer(data, errbuffer, (line) => {\n                            if (this.options.listeners && this.options.listeners.errline) {\n                                this.options.listeners.errline(line);\n                            }\n                        });\n                    });\n                }\n                cp.on('error', (err) => {\n                    state.processError = err.message;\n                    state.processExited = true;\n                    state.processClosed = true;\n                    state.CheckComplete();\n                });\n                cp.on('exit', (code) => {\n                    state.processExitCode = code;\n                    state.processExited = true;\n                    this._debug(`Exit code ${code} received from tool '${this.toolPath}'`);\n                    state.CheckComplete();\n                });\n                cp.on('close', (code) => {\n                    state.processExitCode = code;\n                    state.processExited = true;\n                    state.processClosed = true;\n                    this._debug(`STDIO streams have closed for tool '${this.toolPath}'`);\n                    state.CheckComplete();\n                });\n                state.on('done', (error, exitCode) => {\n                    if (stdbuffer.length > 0) {\n                        this.emit('stdline', stdbuffer);\n                    }\n                    if (errbuffer.length > 0) {\n                        this.emit('errline', errbuffer);\n                    }\n                    cp.removeAllListeners();\n                    if (error) {\n                        reject(error);\n                    }\n                    else {\n                        resolve(exitCode);\n                    }\n                });\n                if (this.options.input) {\n                    if (!cp.stdin) {\n                        throw new Error('child process missing stdin');\n                    }\n                    cp.stdin.end(this.options.input);\n                }\n            }));\n        });\n    }\n}\nexports.ToolRunner = ToolRunner;\n/**\n * Convert an arg string to an array of args. Handles escaping\n *\n * @param    argString   string of arguments\n * @returns  string[]    array of arguments\n */\nfunction argStringToArray(argString) {\n    const args = [];\n    let inQuotes = false;\n    let escaped = false;\n    let arg = '';\n    function append(c) {\n        // we only escape double quotes.\n        if (escaped && c !== '\"') {\n            arg += '\\\\';\n        }\n        arg += c;\n        escaped = false;\n    }\n    for (let i = 0; i < argString.length; i++) {\n        const c = argString.charAt(i);\n        if (c === '\"') {\n            if (!escaped) {\n                inQuotes = !inQuotes;\n            }\n            else {\n                append(c);\n            }\n            continue;\n        }\n        if (c === '\\\\' && escaped) {\n            append(c);\n            continue;\n        }\n        if (c === '\\\\' && inQuotes) {\n            escaped = true;\n            continue;\n        }\n        if (c === ' ' && !inQuotes) {\n            if (arg.length > 0) {\n                args.push(arg);\n                arg = '';\n            }\n            continue;\n        }\n        append(c);\n    }\n    if (arg.length > 0) {\n        args.push(arg.trim());\n    }\n    return args;\n}\nexports.argStringToArray = argStringToArray;\nclass ExecState extends events.EventEmitter {\n    constructor(options, toolPath) {\n        super();\n        this.processClosed = false; // tracks whether the process has exited and stdio is closed\n        this.processError = '';\n        this.processExitCode = 0;\n        this.processExited = false; // tracks whether the process has exited\n        this.processStderr = false; // tracks whether stderr was written to\n        this.delay = 10000; // 10 seconds\n        this.done = false;\n        this.timeout = null;\n        if (!toolPath) {\n            throw new Error('toolPath must not be empty');\n        }\n        this.options = options;\n        this.toolPath = toolPath;\n        if (options.delay) {\n            this.delay = options.delay;\n        }\n    }\n    CheckComplete() {\n        if (this.done) {\n            return;\n        }\n        if (this.processClosed) {\n            this._setResult();\n        }\n        else if (this.processExited) {\n            this.timeout = timers_1.setTimeout(ExecState.HandleTimeout, this.delay, this);\n        }\n    }\n    _debug(message) {\n        this.emit('debug', message);\n    }\n    _setResult() {\n        // determine whether there is an error\n        let error;\n        if (this.processExited) {\n            if (this.processError) {\n                error = new Error(`There was an error when attempting to execute the process '${this.toolPath}'. This may indicate the process failed to start. Error: ${this.processError}`);\n            }\n            else if (this.processExitCode !== 0 && !this.options.ignoreReturnCode) {\n                error = new Error(`The process '${this.toolPath}' failed with exit code ${this.processExitCode}`);\n            }\n            else if (this.processStderr && this.options.failOnStdErr) {\n                error = new Error(`The process '${this.toolPath}' failed because one or more lines were written to the STDERR stream`);\n            }\n        }\n        // clear the timeout\n        if (this.timeout) {\n            clearTimeout(this.timeout);\n            this.timeout = null;\n        }\n        this.done = true;\n        this.emit('done', error, this.processExitCode);\n    }\n    static HandleTimeout(state) {\n        if (state.done) {\n            return;\n        }\n        if (!state.processClosed && state.processExited) {\n            const message = `The STDIO streams did not close within ${state.delay /\n                1000} seconds of the exit event from process '${state.toolPath}'. This may indicate a child process inherited the STDIO streams and has not yet exited.`;\n            state._debug(message);\n        }\n        state._setResult();\n    }\n}\n//# sourceMappingURL=toolrunner.js.map","\"use strict\";\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PersonalAccessTokenCredentialHandler = exports.BearerCredentialHandler = exports.BasicCredentialHandler = void 0;\nclass BasicCredentialHandler {\n    constructor(username, password) {\n        this.username = username;\n        this.password = password;\n    }\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Basic ${Buffer.from(`${this.username}:${this.password}`).toString('base64')}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.BasicCredentialHandler = BasicCredentialHandler;\nclass BearerCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Bearer ${this.token}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.BearerCredentialHandler = BearerCredentialHandler;\nclass PersonalAccessTokenCredentialHandler {\n    constructor(token) {\n        this.token = token;\n    }\n    // currently implements pre-authorization\n    // TODO: support preAuth = false where it hooks on 401\n    prepareRequest(options) {\n        if (!options.headers) {\n            throw Error('The request has no headers');\n        }\n        options.headers['Authorization'] = `Basic ${Buffer.from(`PAT:${this.token}`).toString('base64')}`;\n    }\n    // This handler cannot handle 401\n    canHandleAuthentication() {\n        return false;\n    }\n    handleAuthentication() {\n        return __awaiter(this, void 0, void 0, function* () {\n            throw new Error('not implemented');\n        });\n    }\n}\nexports.PersonalAccessTokenCredentialHandler = PersonalAccessTokenCredentialHandler;\n//# sourceMappingURL=auth.js.map","\"use strict\";\n/* eslint-disable @typescript-eslint/no-explicit-any */\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HttpClient = exports.isHttps = exports.HttpClientResponse = exports.HttpClientError = exports.getProxyUrl = exports.MediaTypes = exports.Headers = exports.HttpCodes = void 0;\nconst http = __importStar(require(\"http\"));\nconst https = __importStar(require(\"https\"));\nconst pm = __importStar(require(\"./proxy\"));\nconst tunnel = __importStar(require(\"tunnel\"));\nvar HttpCodes;\n(function (HttpCodes) {\n    HttpCodes[HttpCodes[\"OK\"] = 200] = \"OK\";\n    HttpCodes[HttpCodes[\"MultipleChoices\"] = 300] = \"MultipleChoices\";\n    HttpCodes[HttpCodes[\"MovedPermanently\"] = 301] = \"MovedPermanently\";\n    HttpCodes[HttpCodes[\"ResourceMoved\"] = 302] = \"ResourceMoved\";\n    HttpCodes[HttpCodes[\"SeeOther\"] = 303] = \"SeeOther\";\n    HttpCodes[HttpCodes[\"NotModified\"] = 304] = \"NotModified\";\n    HttpCodes[HttpCodes[\"UseProxy\"] = 305] = \"UseProxy\";\n    HttpCodes[HttpCodes[\"SwitchProxy\"] = 306] = \"SwitchProxy\";\n    HttpCodes[HttpCodes[\"TemporaryRedirect\"] = 307] = \"TemporaryRedirect\";\n    HttpCodes[HttpCodes[\"PermanentRedirect\"] = 308] = \"PermanentRedirect\";\n    HttpCodes[HttpCodes[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpCodes[HttpCodes[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpCodes[HttpCodes[\"PaymentRequired\"] = 402] = \"PaymentRequired\";\n    HttpCodes[HttpCodes[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpCodes[HttpCodes[\"NotFound\"] = 404] = \"NotFound\";\n    HttpCodes[HttpCodes[\"MethodNotAllowed\"] = 405] = \"MethodNotAllowed\";\n    HttpCodes[HttpCodes[\"NotAcceptable\"] = 406] = \"NotAcceptable\";\n    HttpCodes[HttpCodes[\"ProxyAuthenticationRequired\"] = 407] = \"ProxyAuthenticationRequired\";\n    HttpCodes[HttpCodes[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpCodes[HttpCodes[\"Conflict\"] = 409] = \"Conflict\";\n    HttpCodes[HttpCodes[\"Gone\"] = 410] = \"Gone\";\n    HttpCodes[HttpCodes[\"TooManyRequests\"] = 429] = \"TooManyRequests\";\n    HttpCodes[HttpCodes[\"InternalServerError\"] = 500] = \"InternalServerError\";\n    HttpCodes[HttpCodes[\"NotImplemented\"] = 501] = \"NotImplemented\";\n    HttpCodes[HttpCodes[\"BadGateway\"] = 502] = \"BadGateway\";\n    HttpCodes[HttpCodes[\"ServiceUnavailable\"] = 503] = \"ServiceUnavailable\";\n    HttpCodes[HttpCodes[\"GatewayTimeout\"] = 504] = \"GatewayTimeout\";\n})(HttpCodes = exports.HttpCodes || (exports.HttpCodes = {}));\nvar Headers;\n(function (Headers) {\n    Headers[\"Accept\"] = \"accept\";\n    Headers[\"ContentType\"] = \"content-type\";\n})(Headers = exports.Headers || (exports.Headers = {}));\nvar MediaTypes;\n(function (MediaTypes) {\n    MediaTypes[\"ApplicationJson\"] = \"application/json\";\n})(MediaTypes = exports.MediaTypes || (exports.MediaTypes = {}));\n/**\n * Returns the proxy URL, depending upon the supplied url and proxy environment variables.\n * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n */\nfunction getProxyUrl(serverUrl) {\n    const proxyUrl = pm.getProxyUrl(new URL(serverUrl));\n    return proxyUrl ? proxyUrl.href : '';\n}\nexports.getProxyUrl = getProxyUrl;\nconst HttpRedirectCodes = [\n    HttpCodes.MovedPermanently,\n    HttpCodes.ResourceMoved,\n    HttpCodes.SeeOther,\n    HttpCodes.TemporaryRedirect,\n    HttpCodes.PermanentRedirect\n];\nconst HttpResponseRetryCodes = [\n    HttpCodes.BadGateway,\n    HttpCodes.ServiceUnavailable,\n    HttpCodes.GatewayTimeout\n];\nconst RetryableHttpVerbs = ['OPTIONS', 'GET', 'DELETE', 'HEAD'];\nconst ExponentialBackoffCeiling = 10;\nconst ExponentialBackoffTimeSlice = 5;\nclass HttpClientError extends Error {\n    constructor(message, statusCode) {\n        super(message);\n        this.name = 'HttpClientError';\n        this.statusCode = statusCode;\n        Object.setPrototypeOf(this, HttpClientError.prototype);\n    }\n}\nexports.HttpClientError = HttpClientError;\nclass HttpClientResponse {\n    constructor(message) {\n        this.message = message;\n    }\n    readBody() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                let output = Buffer.alloc(0);\n                this.message.on('data', (chunk) => {\n                    output = Buffer.concat([output, chunk]);\n                });\n                this.message.on('end', () => {\n                    resolve(output.toString());\n                });\n            }));\n        });\n    }\n    readBodyBuffer() {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve) => __awaiter(this, void 0, void 0, function* () {\n                const chunks = [];\n                this.message.on('data', (chunk) => {\n                    chunks.push(chunk);\n                });\n                this.message.on('end', () => {\n                    resolve(Buffer.concat(chunks));\n                });\n            }));\n        });\n    }\n}\nexports.HttpClientResponse = HttpClientResponse;\nfunction isHttps(requestUrl) {\n    const parsedUrl = new URL(requestUrl);\n    return parsedUrl.protocol === 'https:';\n}\nexports.isHttps = isHttps;\nclass HttpClient {\n    constructor(userAgent, handlers, requestOptions) {\n        this._ignoreSslError = false;\n        this._allowRedirects = true;\n        this._allowRedirectDowngrade = false;\n        this._maxRedirects = 50;\n        this._allowRetries = false;\n        this._maxRetries = 1;\n        this._keepAlive = false;\n        this._disposed = false;\n        this.userAgent = userAgent;\n        this.handlers = handlers || [];\n        this.requestOptions = requestOptions;\n        if (requestOptions) {\n            if (requestOptions.ignoreSslError != null) {\n                this._ignoreSslError = requestOptions.ignoreSslError;\n            }\n            this._socketTimeout = requestOptions.socketTimeout;\n            if (requestOptions.allowRedirects != null) {\n                this._allowRedirects = requestOptions.allowRedirects;\n            }\n            if (requestOptions.allowRedirectDowngrade != null) {\n                this._allowRedirectDowngrade = requestOptions.allowRedirectDowngrade;\n            }\n            if (requestOptions.maxRedirects != null) {\n                this._maxRedirects = Math.max(requestOptions.maxRedirects, 0);\n            }\n            if (requestOptions.keepAlive != null) {\n                this._keepAlive = requestOptions.keepAlive;\n            }\n            if (requestOptions.allowRetries != null) {\n                this._allowRetries = requestOptions.allowRetries;\n            }\n            if (requestOptions.maxRetries != null) {\n                this._maxRetries = requestOptions.maxRetries;\n            }\n        }\n    }\n    options(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('OPTIONS', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    get(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('GET', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    del(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('DELETE', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    post(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('POST', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    patch(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('PATCH', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    put(requestUrl, data, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('PUT', requestUrl, data, additionalHeaders || {});\n        });\n    }\n    head(requestUrl, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request('HEAD', requestUrl, null, additionalHeaders || {});\n        });\n    }\n    sendStream(verb, requestUrl, stream, additionalHeaders) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return this.request(verb, requestUrl, stream, additionalHeaders);\n        });\n    }\n    /**\n     * Gets a typed object from an endpoint\n     * Be aware that not found returns a null.  Other errors (4xx, 5xx) reject the promise\n     */\n    getJson(requestUrl, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            const res = yield this.get(requestUrl, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    postJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.post(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    putJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.put(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    patchJson(requestUrl, obj, additionalHeaders = {}) {\n        return __awaiter(this, void 0, void 0, function* () {\n            const data = JSON.stringify(obj, null, 2);\n            additionalHeaders[Headers.Accept] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.Accept, MediaTypes.ApplicationJson);\n            additionalHeaders[Headers.ContentType] = this._getExistingOrDefaultHeader(additionalHeaders, Headers.ContentType, MediaTypes.ApplicationJson);\n            const res = yield this.patch(requestUrl, data, additionalHeaders);\n            return this._processResponse(res, this.requestOptions);\n        });\n    }\n    /**\n     * Makes a raw http request.\n     * All other methods such as get, post, patch, and request ultimately call this.\n     * Prefer get, del, post and patch\n     */\n    request(verb, requestUrl, data, headers) {\n        return __awaiter(this, void 0, void 0, function* () {\n            if (this._disposed) {\n                throw new Error('Client has already been disposed.');\n            }\n            const parsedUrl = new URL(requestUrl);\n            let info = this._prepareRequest(verb, parsedUrl, headers);\n            // Only perform retries on reads since writes may not be idempotent.\n            const maxTries = this._allowRetries && RetryableHttpVerbs.includes(verb)\n                ? this._maxRetries + 1\n                : 1;\n            let numTries = 0;\n            let response;\n            do {\n                response = yield this.requestRaw(info, data);\n                // Check if it's an authentication challenge\n                if (response &&\n                    response.message &&\n                    response.message.statusCode === HttpCodes.Unauthorized) {\n                    let authenticationHandler;\n                    for (const handler of this.handlers) {\n                        if (handler.canHandleAuthentication(response)) {\n                            authenticationHandler = handler;\n                            break;\n                        }\n                    }\n                    if (authenticationHandler) {\n                        return authenticationHandler.handleAuthentication(this, info, data);\n                    }\n                    else {\n                        // We have received an unauthorized response but have no handlers to handle it.\n                        // Let the response return to the caller.\n                        return response;\n                    }\n                }\n                let redirectsRemaining = this._maxRedirects;\n                while (response.message.statusCode &&\n                    HttpRedirectCodes.includes(response.message.statusCode) &&\n                    this._allowRedirects &&\n                    redirectsRemaining > 0) {\n                    const redirectUrl = response.message.headers['location'];\n                    if (!redirectUrl) {\n                        // if there's no location to redirect to, we won't\n                        break;\n                    }\n                    const parsedRedirectUrl = new URL(redirectUrl);\n                    if (parsedUrl.protocol === 'https:' &&\n                        parsedUrl.protocol !== parsedRedirectUrl.protocol &&\n                        !this._allowRedirectDowngrade) {\n                        throw new Error('Redirect from HTTPS to HTTP protocol. This downgrade is not allowed for security reasons. If you want to allow this behavior, set the allowRedirectDowngrade option to true.');\n                    }\n                    // we need to finish reading the response before reassigning response\n                    // which will leak the open socket.\n                    yield response.readBody();\n                    // strip authorization header if redirected to a different hostname\n                    if (parsedRedirectUrl.hostname !== parsedUrl.hostname) {\n                        for (const header in headers) {\n                            // header names are case insensitive\n                            if (header.toLowerCase() === 'authorization') {\n                                delete headers[header];\n                            }\n                        }\n                    }\n                    // let's make the request with the new redirectUrl\n                    info = this._prepareRequest(verb, parsedRedirectUrl, headers);\n                    response = yield this.requestRaw(info, data);\n                    redirectsRemaining--;\n                }\n                if (!response.message.statusCode ||\n                    !HttpResponseRetryCodes.includes(response.message.statusCode)) {\n                    // If not a retry code, return immediately instead of retrying\n                    return response;\n                }\n                numTries += 1;\n                if (numTries < maxTries) {\n                    yield response.readBody();\n                    yield this._performExponentialBackoff(numTries);\n                }\n            } while (numTries < maxTries);\n            return response;\n        });\n    }\n    /**\n     * Needs to be called if keepAlive is set to true in request options.\n     */\n    dispose() {\n        if (this._agent) {\n            this._agent.destroy();\n        }\n        this._disposed = true;\n    }\n    /**\n     * Raw request.\n     * @param info\n     * @param data\n     */\n    requestRaw(info, data) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => {\n                function callbackForResult(err, res) {\n                    if (err) {\n                        reject(err);\n                    }\n                    else if (!res) {\n                        // If `err` is not passed, then `res` must be passed.\n                        reject(new Error('Unknown error'));\n                    }\n                    else {\n                        resolve(res);\n                    }\n                }\n                this.requestRawWithCallback(info, data, callbackForResult);\n            });\n        });\n    }\n    /**\n     * Raw request with callback.\n     * @param info\n     * @param data\n     * @param onResult\n     */\n    requestRawWithCallback(info, data, onResult) {\n        if (typeof data === 'string') {\n            if (!info.options.headers) {\n                info.options.headers = {};\n            }\n            info.options.headers['Content-Length'] = Buffer.byteLength(data, 'utf8');\n        }\n        let callbackCalled = false;\n        function handleResult(err, res) {\n            if (!callbackCalled) {\n                callbackCalled = true;\n                onResult(err, res);\n            }\n        }\n        const req = info.httpModule.request(info.options, (msg) => {\n            const res = new HttpClientResponse(msg);\n            handleResult(undefined, res);\n        });\n        let socket;\n        req.on('socket', sock => {\n            socket = sock;\n        });\n        // If we ever get disconnected, we want the socket to timeout eventually\n        req.setTimeout(this._socketTimeout || 3 * 60000, () => {\n            if (socket) {\n                socket.end();\n            }\n            handleResult(new Error(`Request timeout: ${info.options.path}`));\n        });\n        req.on('error', function (err) {\n            // err has statusCode property\n            // res should have headers\n            handleResult(err);\n        });\n        if (data && typeof data === 'string') {\n            req.write(data, 'utf8');\n        }\n        if (data && typeof data !== 'string') {\n            data.on('close', function () {\n                req.end();\n            });\n            data.pipe(req);\n        }\n        else {\n            req.end();\n        }\n    }\n    /**\n     * Gets an http agent. This function is useful when you need an http agent that handles\n     * routing through a proxy server - depending upon the url and proxy environment variables.\n     * @param serverUrl  The server URL where the request will be sent. For example, https://api.github.com\n     */\n    getAgent(serverUrl) {\n        const parsedUrl = new URL(serverUrl);\n        return this._getAgent(parsedUrl);\n    }\n    _prepareRequest(method, requestUrl, headers) {\n        const info = {};\n        info.parsedUrl = requestUrl;\n        const usingSsl = info.parsedUrl.protocol === 'https:';\n        info.httpModule = usingSsl ? https : http;\n        const defaultPort = usingSsl ? 443 : 80;\n        info.options = {};\n        info.options.host = info.parsedUrl.hostname;\n        info.options.port = info.parsedUrl.port\n            ? parseInt(info.parsedUrl.port)\n            : defaultPort;\n        info.options.path =\n            (info.parsedUrl.pathname || '') + (info.parsedUrl.search || '');\n        info.options.method = method;\n        info.options.headers = this._mergeHeaders(headers);\n        if (this.userAgent != null) {\n            info.options.headers['user-agent'] = this.userAgent;\n        }\n        info.options.agent = this._getAgent(info.parsedUrl);\n        // gives handlers an opportunity to participate\n        if (this.handlers) {\n            for (const handler of this.handlers) {\n                handler.prepareRequest(info.options);\n            }\n        }\n        return info;\n    }\n    _mergeHeaders(headers) {\n        if (this.requestOptions && this.requestOptions.headers) {\n            return Object.assign({}, lowercaseKeys(this.requestOptions.headers), lowercaseKeys(headers || {}));\n        }\n        return lowercaseKeys(headers || {});\n    }\n    _getExistingOrDefaultHeader(additionalHeaders, header, _default) {\n        let clientHeader;\n        if (this.requestOptions && this.requestOptions.headers) {\n            clientHeader = lowercaseKeys(this.requestOptions.headers)[header];\n        }\n        return additionalHeaders[header] || clientHeader || _default;\n    }\n    _getAgent(parsedUrl) {\n        let agent;\n        const proxyUrl = pm.getProxyUrl(parsedUrl);\n        const useProxy = proxyUrl && proxyUrl.hostname;\n        if (this._keepAlive && useProxy) {\n            agent = this._proxyAgent;\n        }\n        if (this._keepAlive && !useProxy) {\n            agent = this._agent;\n        }\n        // if agent is already assigned use that agent.\n        if (agent) {\n            return agent;\n        }\n        const usingSsl = parsedUrl.protocol === 'https:';\n        let maxSockets = 100;\n        if (this.requestOptions) {\n            maxSockets = this.requestOptions.maxSockets || http.globalAgent.maxSockets;\n        }\n        // This is `useProxy` again, but we need to check `proxyURl` directly for TypeScripts's flow analysis.\n        if (proxyUrl && proxyUrl.hostname) {\n            const agentOptions = {\n                maxSockets,\n                keepAlive: this._keepAlive,\n                proxy: Object.assign(Object.assign({}, ((proxyUrl.username || proxyUrl.password) && {\n                    proxyAuth: `${proxyUrl.username}:${proxyUrl.password}`\n                })), { host: proxyUrl.hostname, port: proxyUrl.port })\n            };\n            let tunnelAgent;\n            const overHttps = proxyUrl.protocol === 'https:';\n            if (usingSsl) {\n                tunnelAgent = overHttps ? tunnel.httpsOverHttps : tunnel.httpsOverHttp;\n            }\n            else {\n                tunnelAgent = overHttps ? tunnel.httpOverHttps : tunnel.httpOverHttp;\n            }\n            agent = tunnelAgent(agentOptions);\n            this._proxyAgent = agent;\n        }\n        // if reusing agent across request and tunneling agent isn't assigned create a new agent\n        if (this._keepAlive && !agent) {\n            const options = { keepAlive: this._keepAlive, maxSockets };\n            agent = usingSsl ? new https.Agent(options) : new http.Agent(options);\n            this._agent = agent;\n        }\n        // if not using private agent and tunnel agent isn't setup then use global agent\n        if (!agent) {\n            agent = usingSsl ? https.globalAgent : http.globalAgent;\n        }\n        if (usingSsl && this._ignoreSslError) {\n            // we don't want to set NODE_TLS_REJECT_UNAUTHORIZED=0 since that will affect request for entire process\n            // http.RequestOptions doesn't expose a way to modify RequestOptions.agent.options\n            // we have to cast it to any and change it directly\n            agent.options = Object.assign(agent.options || {}, {\n                rejectUnauthorized: false\n            });\n        }\n        return agent;\n    }\n    _performExponentialBackoff(retryNumber) {\n        return __awaiter(this, void 0, void 0, function* () {\n            retryNumber = Math.min(ExponentialBackoffCeiling, retryNumber);\n            const ms = ExponentialBackoffTimeSlice * Math.pow(2, retryNumber);\n            return new Promise(resolve => setTimeout(() => resolve(), ms));\n        });\n    }\n    _processResponse(res, options) {\n        return __awaiter(this, void 0, void 0, function* () {\n            return new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n                const statusCode = res.message.statusCode || 0;\n                const response = {\n                    statusCode,\n                    result: null,\n                    headers: {}\n                };\n                // not found leads to null obj returned\n                if (statusCode === HttpCodes.NotFound) {\n                    resolve(response);\n                }\n                // get the result from the body\n                function dateTimeDeserializer(key, value) {\n                    if (typeof value === 'string') {\n                        const a = new Date(value);\n                        if (!isNaN(a.valueOf())) {\n                            return a;\n                        }\n                    }\n                    return value;\n                }\n                let obj;\n                let contents;\n                try {\n                    contents = yield res.readBody();\n                    if (contents && contents.length > 0) {\n                        if (options && options.deserializeDates) {\n                            obj = JSON.parse(contents, dateTimeDeserializer);\n                        }\n                        else {\n                            obj = JSON.parse(contents);\n                        }\n                        response.result = obj;\n                    }\n                    response.headers = res.message.headers;\n                }\n                catch (err) {\n                    // Invalid resource (contents not json);  leaving result obj null\n                }\n                // note that 3xx redirects are handled by the http layer.\n                if (statusCode > 299) {\n                    let msg;\n                    // if exception/error in body, attempt to get better error\n                    if (obj && obj.message) {\n                        msg = obj.message;\n                    }\n                    else if (contents && contents.length > 0) {\n                        // it may be the case that the exception is in the body message as string\n                        msg = contents;\n                    }\n                    else {\n                        msg = `Failed request: (${statusCode})`;\n                    }\n                    const err = new HttpClientError(msg, statusCode);\n                    err.result = response.result;\n                    reject(err);\n                }\n                else {\n                    resolve(response);\n                }\n            }));\n        });\n    }\n}\nexports.HttpClient = HttpClient;\nconst lowercaseKeys = (obj) => Object.keys(obj).reduce((c, k) => ((c[k.toLowerCase()] = obj[k]), c), {});\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.checkBypass = exports.getProxyUrl = void 0;\nfunction getProxyUrl(reqUrl) {\n    const usingSsl = reqUrl.protocol === 'https:';\n    if (checkBypass(reqUrl)) {\n        return undefined;\n    }\n    const proxyVar = (() => {\n        if (usingSsl) {\n            return process.env['https_proxy'] || process.env['HTTPS_PROXY'];\n        }\n        else {\n            return process.env['http_proxy'] || process.env['HTTP_PROXY'];\n        }\n    })();\n    if (proxyVar) {\n        try {\n            return new URL(proxyVar);\n        }\n        catch (_a) {\n            if (!proxyVar.startsWith('http://') && !proxyVar.startsWith('https://'))\n                return new URL(`http://${proxyVar}`);\n        }\n    }\n    else {\n        return undefined;\n    }\n}\nexports.getProxyUrl = getProxyUrl;\nfunction checkBypass(reqUrl) {\n    if (!reqUrl.hostname) {\n        return false;\n    }\n    const reqHost = reqUrl.hostname;\n    if (isLoopbackAddress(reqHost)) {\n        return true;\n    }\n    const noProxy = process.env['no_proxy'] || process.env['NO_PROXY'] || '';\n    if (!noProxy) {\n        return false;\n    }\n    // Determine the request port\n    let reqPort;\n    if (reqUrl.port) {\n        reqPort = Number(reqUrl.port);\n    }\n    else if (reqUrl.protocol === 'http:') {\n        reqPort = 80;\n    }\n    else if (reqUrl.protocol === 'https:') {\n        reqPort = 443;\n    }\n    // Format the request hostname and hostname with port\n    const upperReqHosts = [reqUrl.hostname.toUpperCase()];\n    if (typeof reqPort === 'number') {\n        upperReqHosts.push(`${upperReqHosts[0]}:${reqPort}`);\n    }\n    // Compare request host against noproxy\n    for (const upperNoProxyItem of noProxy\n        .split(',')\n        .map(x => x.trim().toUpperCase())\n        .filter(x => x)) {\n        if (upperNoProxyItem === '*' ||\n            upperReqHosts.some(x => x === upperNoProxyItem ||\n                x.endsWith(`.${upperNoProxyItem}`) ||\n                (upperNoProxyItem.startsWith('.') &&\n                    x.endsWith(`${upperNoProxyItem}`)))) {\n            return true;\n        }\n    }\n    return false;\n}\nexports.checkBypass = checkBypass;\nfunction isLoopbackAddress(host) {\n    const hostLower = host.toLowerCase();\n    return (hostLower === 'localhost' ||\n        hostLower.startsWith('127.') ||\n        hostLower.startsWith('[::1]') ||\n        hostLower.startsWith('[0:0:0:0:0:0:0:1]'));\n}\n//# sourceMappingURL=proxy.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getCmdPath = exports.tryGetExecutablePath = exports.isRooted = exports.isDirectory = exports.exists = exports.READONLY = exports.UV_FS_O_EXLOCK = exports.IS_WINDOWS = exports.unlink = exports.symlink = exports.stat = exports.rmdir = exports.rm = exports.rename = exports.readlink = exports.readdir = exports.open = exports.mkdir = exports.lstat = exports.copyFile = exports.chmod = void 0;\nconst fs = __importStar(require(\"fs\"));\nconst path = __importStar(require(\"path\"));\n_a = fs.promises\n// export const {open} = 'fs'\n, exports.chmod = _a.chmod, exports.copyFile = _a.copyFile, exports.lstat = _a.lstat, exports.mkdir = _a.mkdir, exports.open = _a.open, exports.readdir = _a.readdir, exports.readlink = _a.readlink, exports.rename = _a.rename, exports.rm = _a.rm, exports.rmdir = _a.rmdir, exports.stat = _a.stat, exports.symlink = _a.symlink, exports.unlink = _a.unlink;\n// export const {open} = 'fs'\nexports.IS_WINDOWS = process.platform === 'win32';\n// See https://github.com/nodejs/node/blob/d0153aee367422d0858105abec186da4dff0a0c5/deps/uv/include/uv/win.h#L691\nexports.UV_FS_O_EXLOCK = 0x10000000;\nexports.READONLY = fs.constants.O_RDONLY;\nfunction exists(fsPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        try {\n            yield exports.stat(fsPath);\n        }\n        catch (err) {\n            if (err.code === 'ENOENT') {\n                return false;\n            }\n            throw err;\n        }\n        return true;\n    });\n}\nexports.exists = exists;\nfunction isDirectory(fsPath, useStat = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const stats = useStat ? yield exports.stat(fsPath) : yield exports.lstat(fsPath);\n        return stats.isDirectory();\n    });\n}\nexports.isDirectory = isDirectory;\n/**\n * On OSX/Linux, true if path starts with '/'. On Windows, true for paths like:\n * \\, \\hello, \\\\hello\\share, C:, and C:\\hello (and corresponding alternate separator cases).\n */\nfunction isRooted(p) {\n    p = normalizeSeparators(p);\n    if (!p) {\n        throw new Error('isRooted() parameter \"p\" cannot be empty');\n    }\n    if (exports.IS_WINDOWS) {\n        return (p.startsWith('\\\\') || /^[A-Z]:/i.test(p) // e.g. \\ or \\hello or \\\\hello\n        ); // e.g. C: or C:\\hello\n    }\n    return p.startsWith('/');\n}\nexports.isRooted = isRooted;\n/**\n * Best effort attempt to determine whether a file exists and is executable.\n * @param filePath    file path to check\n * @param extensions  additional file extensions to try\n * @return if file exists and is executable, returns the file path. otherwise empty string.\n */\nfunction tryGetExecutablePath(filePath, extensions) {\n    return __awaiter(this, void 0, void 0, function* () {\n        let stats = undefined;\n        try {\n            // test file exists\n            stats = yield exports.stat(filePath);\n        }\n        catch (err) {\n            if (err.code !== 'ENOENT') {\n                // eslint-disable-next-line no-console\n                console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);\n            }\n        }\n        if (stats && stats.isFile()) {\n            if (exports.IS_WINDOWS) {\n                // on Windows, test for valid extension\n                const upperExt = path.extname(filePath).toUpperCase();\n                if (extensions.some(validExt => validExt.toUpperCase() === upperExt)) {\n                    return filePath;\n                }\n            }\n            else {\n                if (isUnixExecutable(stats)) {\n                    return filePath;\n                }\n            }\n        }\n        // try each extension\n        const originalFilePath = filePath;\n        for (const extension of extensions) {\n            filePath = originalFilePath + extension;\n            stats = undefined;\n            try {\n                stats = yield exports.stat(filePath);\n            }\n            catch (err) {\n                if (err.code !== 'ENOENT') {\n                    // eslint-disable-next-line no-console\n                    console.log(`Unexpected error attempting to determine if executable file exists '${filePath}': ${err}`);\n                }\n            }\n            if (stats && stats.isFile()) {\n                if (exports.IS_WINDOWS) {\n                    // preserve the case of the actual file (since an extension was appended)\n                    try {\n                        const directory = path.dirname(filePath);\n                        const upperName = path.basename(filePath).toUpperCase();\n                        for (const actualName of yield exports.readdir(directory)) {\n                            if (upperName === actualName.toUpperCase()) {\n                                filePath = path.join(directory, actualName);\n                                break;\n                            }\n                        }\n                    }\n                    catch (err) {\n                        // eslint-disable-next-line no-console\n                        console.log(`Unexpected error attempting to determine the actual case of the file '${filePath}': ${err}`);\n                    }\n                    return filePath;\n                }\n                else {\n                    if (isUnixExecutable(stats)) {\n                        return filePath;\n                    }\n                }\n            }\n        }\n        return '';\n    });\n}\nexports.tryGetExecutablePath = tryGetExecutablePath;\nfunction normalizeSeparators(p) {\n    p = p || '';\n    if (exports.IS_WINDOWS) {\n        // convert slashes on Windows\n        p = p.replace(/\\//g, '\\\\');\n        // remove redundant slashes\n        return p.replace(/\\\\\\\\+/g, '\\\\');\n    }\n    // remove redundant slashes\n    return p.replace(/\\/\\/+/g, '/');\n}\n// on Mac/Linux, test the execute bit\n//     R   W  X  R  W X R W X\n//   256 128 64 32 16 8 4 2 1\nfunction isUnixExecutable(stats) {\n    return ((stats.mode & 1) > 0 ||\n        ((stats.mode & 8) > 0 && stats.gid === process.getgid()) ||\n        ((stats.mode & 64) > 0 && stats.uid === process.getuid()));\n}\n// Get the path of cmd.exe in windows\nfunction getCmdPath() {\n    var _a;\n    return (_a = process.env['COMSPEC']) !== null && _a !== void 0 ? _a : `cmd.exe`;\n}\nexports.getCmdPath = getCmdPath;\n//# sourceMappingURL=io-util.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findInPath = exports.which = exports.mkdirP = exports.rmRF = exports.mv = exports.cp = void 0;\nconst assert_1 = require(\"assert\");\nconst path = __importStar(require(\"path\"));\nconst ioUtil = __importStar(require(\"./io-util\"));\n/**\n * Copies a file or folder.\n * Based off of shelljs - https://github.com/shelljs/shelljs/blob/9237f66c52e5daa40458f94f9565e18e8132f5a6/src/cp.js\n *\n * @param     source    source path\n * @param     dest      destination path\n * @param     options   optional. See CopyOptions.\n */\nfunction cp(source, dest, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const { force, recursive, copySourceDirectory } = readCopyOptions(options);\n        const destStat = (yield ioUtil.exists(dest)) ? yield ioUtil.stat(dest) : null;\n        // Dest is an existing file, but not forcing\n        if (destStat && destStat.isFile() && !force) {\n            return;\n        }\n        // If dest is an existing directory, should copy inside.\n        const newDest = destStat && destStat.isDirectory() && copySourceDirectory\n            ? path.join(dest, path.basename(source))\n            : dest;\n        if (!(yield ioUtil.exists(source))) {\n            throw new Error(`no such file or directory: ${source}`);\n        }\n        const sourceStat = yield ioUtil.stat(source);\n        if (sourceStat.isDirectory()) {\n            if (!recursive) {\n                throw new Error(`Failed to copy. ${source} is a directory, but tried to copy without recursive flag.`);\n            }\n            else {\n                yield cpDirRecursive(source, newDest, 0, force);\n            }\n        }\n        else {\n            if (path.relative(source, newDest) === '') {\n                // a file cannot be copied to itself\n                throw new Error(`'${newDest}' and '${source}' are the same file`);\n            }\n            yield copyFile(source, newDest, force);\n        }\n    });\n}\nexports.cp = cp;\n/**\n * Moves a path.\n *\n * @param     source    source path\n * @param     dest      destination path\n * @param     options   optional. See MoveOptions.\n */\nfunction mv(source, dest, options = {}) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (yield ioUtil.exists(dest)) {\n            let destExists = true;\n            if (yield ioUtil.isDirectory(dest)) {\n                // If dest is directory copy src into dest\n                dest = path.join(dest, path.basename(source));\n                destExists = yield ioUtil.exists(dest);\n            }\n            if (destExists) {\n                if (options.force == null || options.force) {\n                    yield rmRF(dest);\n                }\n                else {\n                    throw new Error('Destination already exists');\n                }\n            }\n        }\n        yield mkdirP(path.dirname(dest));\n        yield ioUtil.rename(source, dest);\n    });\n}\nexports.mv = mv;\n/**\n * Remove a path recursively with force\n *\n * @param inputPath path to remove\n */\nfunction rmRF(inputPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (ioUtil.IS_WINDOWS) {\n            // Check for invalid characters\n            // https://docs.microsoft.com/en-us/windows/win32/fileio/naming-a-file\n            if (/[*\"<>|]/.test(inputPath)) {\n                throw new Error('File path must not contain `*`, `\"`, `<`, `>` or `|` on Windows');\n            }\n        }\n        try {\n            // note if path does not exist, error is silent\n            yield ioUtil.rm(inputPath, {\n                force: true,\n                maxRetries: 3,\n                recursive: true,\n                retryDelay: 300\n            });\n        }\n        catch (err) {\n            throw new Error(`File was unable to be removed ${err}`);\n        }\n    });\n}\nexports.rmRF = rmRF;\n/**\n * Make a directory.  Creates the full path with folders in between\n * Will throw if it fails\n *\n * @param   fsPath        path to create\n * @returns Promise<void>\n */\nfunction mkdirP(fsPath) {\n    return __awaiter(this, void 0, void 0, function* () {\n        assert_1.ok(fsPath, 'a path argument must be provided');\n        yield ioUtil.mkdir(fsPath, { recursive: true });\n    });\n}\nexports.mkdirP = mkdirP;\n/**\n * Returns path of a tool had the tool actually been invoked.  Resolves via paths.\n * If you check and the tool does not exist, it will throw.\n *\n * @param     tool              name of the tool\n * @param     check             whether to check if tool exists\n * @returns   Promise<string>   path to tool\n */\nfunction which(tool, check) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!tool) {\n            throw new Error(\"parameter 'tool' is required\");\n        }\n        // recursive when check=true\n        if (check) {\n            const result = yield which(tool, false);\n            if (!result) {\n                if (ioUtil.IS_WINDOWS) {\n                    throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also verify the file has a valid extension for an executable file.`);\n                }\n                else {\n                    throw new Error(`Unable to locate executable file: ${tool}. Please verify either the file path exists or the file can be found within a directory specified by the PATH environment variable. Also check the file mode to verify the file is executable.`);\n                }\n            }\n            return result;\n        }\n        const matches = yield findInPath(tool);\n        if (matches && matches.length > 0) {\n            return matches[0];\n        }\n        return '';\n    });\n}\nexports.which = which;\n/**\n * Returns a list of all occurrences of the given tool on the system path.\n *\n * @returns   Promise<string[]>  the paths of the tool\n */\nfunction findInPath(tool) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (!tool) {\n            throw new Error(\"parameter 'tool' is required\");\n        }\n        // build the list of extensions to try\n        const extensions = [];\n        if (ioUtil.IS_WINDOWS && process.env['PATHEXT']) {\n            for (const extension of process.env['PATHEXT'].split(path.delimiter)) {\n                if (extension) {\n                    extensions.push(extension);\n                }\n            }\n        }\n        // if it's rooted, return it if exists. otherwise return empty.\n        if (ioUtil.isRooted(tool)) {\n            const filePath = yield ioUtil.tryGetExecutablePath(tool, extensions);\n            if (filePath) {\n                return [filePath];\n            }\n            return [];\n        }\n        // if any path separators, return empty\n        if (tool.includes(path.sep)) {\n            return [];\n        }\n        // build the list of directories\n        //\n        // Note, technically \"where\" checks the current directory on Windows. From a toolkit perspective,\n        // it feels like we should not do this. Checking the current directory seems like more of a use\n        // case of a shell, and the which() function exposed by the toolkit should strive for consistency\n        // across platforms.\n        const directories = [];\n        if (process.env.PATH) {\n            for (const p of process.env.PATH.split(path.delimiter)) {\n                if (p) {\n                    directories.push(p);\n                }\n            }\n        }\n        // find all matches\n        const matches = [];\n        for (const directory of directories) {\n            const filePath = yield ioUtil.tryGetExecutablePath(path.join(directory, tool), extensions);\n            if (filePath) {\n                matches.push(filePath);\n            }\n        }\n        return matches;\n    });\n}\nexports.findInPath = findInPath;\nfunction readCopyOptions(options) {\n    const force = options.force == null ? true : options.force;\n    const recursive = Boolean(options.recursive);\n    const copySourceDirectory = options.copySourceDirectory == null\n        ? true\n        : Boolean(options.copySourceDirectory);\n    return { force, recursive, copySourceDirectory };\n}\nfunction cpDirRecursive(sourceDir, destDir, currentDepth, force) {\n    return __awaiter(this, void 0, void 0, function* () {\n        // Ensure there is not a run away recursive copy\n        if (currentDepth >= 255)\n            return;\n        currentDepth++;\n        yield mkdirP(destDir);\n        const files = yield ioUtil.readdir(sourceDir);\n        for (const fileName of files) {\n            const srcFile = `${sourceDir}/${fileName}`;\n            const destFile = `${destDir}/${fileName}`;\n            const srcFileStat = yield ioUtil.lstat(srcFile);\n            if (srcFileStat.isDirectory()) {\n                // Recurse\n                yield cpDirRecursive(srcFile, destFile, currentDepth, force);\n            }\n            else {\n                yield copyFile(srcFile, destFile, force);\n            }\n        }\n        // Change the mode for the newly created directory\n        yield ioUtil.chmod(destDir, (yield ioUtil.stat(sourceDir)).mode);\n    });\n}\n// Buffered file copy\nfunction copyFile(srcFile, destFile, force) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if ((yield ioUtil.lstat(srcFile)).isSymbolicLink()) {\n            // unlink/re-link it\n            try {\n                yield ioUtil.lstat(destFile);\n                yield ioUtil.unlink(destFile);\n            }\n            catch (e) {\n                // Try to override file permission\n                if (e.code === 'EPERM') {\n                    yield ioUtil.chmod(destFile, '0666');\n                    yield ioUtil.unlink(destFile);\n                }\n                // other errors = it doesn't exist, no work to do\n            }\n            // Copy over symlink\n            const symlinkFull = yield ioUtil.readlink(srcFile);\n            yield ioUtil.symlink(symlinkFull, destFile, ioUtil.IS_WINDOWS ? 'junction' : null);\n        }\n        else if (!(yield ioUtil.exists(destFile)) || force) {\n            yield ioUtil.copyFile(srcFile, destFile);\n        }\n    });\n}\n//# sourceMappingURL=io.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.findMadeSync = exports.findMade = void 0;\nconst path_1 = require(\"path\");\nconst findMade = async (opts, parent, path) => {\n    // we never want the 'made' return value to be a root directory\n    if (path === parent) {\n        return;\n    }\n    return opts.statAsync(parent).then(st => (st.isDirectory() ? path : undefined), // will fail later\n    // will fail later\n    er => {\n        const fer = er;\n        return fer && fer.code === 'ENOENT'\n            ? (0, exports.findMade)(opts, (0, path_1.dirname)(parent), parent)\n            : undefined;\n    });\n};\nexports.findMade = findMade;\nconst findMadeSync = (opts, parent, path) => {\n    if (path === parent) {\n        return undefined;\n    }\n    try {\n        return opts.statSync(parent).isDirectory() ? path : undefined;\n    }\n    catch (er) {\n        const fer = er;\n        return fer && fer.code === 'ENOENT'\n            ? (0, exports.findMadeSync)(opts, (0, path_1.dirname)(parent), parent)\n            : undefined;\n    }\n};\nexports.findMadeSync = findMadeSync;\n//# sourceMappingURL=find-made.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mkdirp = exports.nativeSync = exports.native = exports.manualSync = exports.manual = exports.sync = exports.mkdirpSync = exports.useNativeSync = exports.useNative = exports.mkdirpNativeSync = exports.mkdirpNative = exports.mkdirpManualSync = exports.mkdirpManual = void 0;\nconst mkdirp_manual_js_1 = require(\"./mkdirp-manual.js\");\nconst mkdirp_native_js_1 = require(\"./mkdirp-native.js\");\nconst opts_arg_js_1 = require(\"./opts-arg.js\");\nconst path_arg_js_1 = require(\"./path-arg.js\");\nconst use_native_js_1 = require(\"./use-native.js\");\n/* c8 ignore start */\nvar mkdirp_manual_js_2 = require(\"./mkdirp-manual.js\");\nObject.defineProperty(exports, \"mkdirpManual\", { enumerable: true, get: function () { return mkdirp_manual_js_2.mkdirpManual; } });\nObject.defineProperty(exports, \"mkdirpManualSync\", { enumerable: true, get: function () { return mkdirp_manual_js_2.mkdirpManualSync; } });\nvar mkdirp_native_js_2 = require(\"./mkdirp-native.js\");\nObject.defineProperty(exports, \"mkdirpNative\", { enumerable: true, get: function () { return mkdirp_native_js_2.mkdirpNative; } });\nObject.defineProperty(exports, \"mkdirpNativeSync\", { enumerable: true, get: function () { return mkdirp_native_js_2.mkdirpNativeSync; } });\nvar use_native_js_2 = require(\"./use-native.js\");\nObject.defineProperty(exports, \"useNative\", { enumerable: true, get: function () { return use_native_js_2.useNative; } });\nObject.defineProperty(exports, \"useNativeSync\", { enumerable: true, get: function () { return use_native_js_2.useNativeSync; } });\n/* c8 ignore stop */\nconst mkdirpSync = (path, opts) => {\n    path = (0, path_arg_js_1.pathArg)(path);\n    const resolved = (0, opts_arg_js_1.optsArg)(opts);\n    return (0, use_native_js_1.useNativeSync)(resolved)\n        ? (0, mkdirp_native_js_1.mkdirpNativeSync)(path, resolved)\n        : (0, mkdirp_manual_js_1.mkdirpManualSync)(path, resolved);\n};\nexports.mkdirpSync = mkdirpSync;\nexports.sync = exports.mkdirpSync;\nexports.manual = mkdirp_manual_js_1.mkdirpManual;\nexports.manualSync = mkdirp_manual_js_1.mkdirpManualSync;\nexports.native = mkdirp_native_js_1.mkdirpNative;\nexports.nativeSync = mkdirp_native_js_1.mkdirpNativeSync;\nexports.mkdirp = Object.assign(async (path, opts) => {\n    path = (0, path_arg_js_1.pathArg)(path);\n    const resolved = (0, opts_arg_js_1.optsArg)(opts);\n    return (0, use_native_js_1.useNative)(resolved)\n        ? (0, mkdirp_native_js_1.mkdirpNative)(path, resolved)\n        : (0, mkdirp_manual_js_1.mkdirpManual)(path, resolved);\n}, {\n    mkdirpSync: exports.mkdirpSync,\n    mkdirpNative: mkdirp_native_js_1.mkdirpNative,\n    mkdirpNativeSync: mkdirp_native_js_1.mkdirpNativeSync,\n    mkdirpManual: mkdirp_manual_js_1.mkdirpManual,\n    mkdirpManualSync: mkdirp_manual_js_1.mkdirpManualSync,\n    sync: exports.mkdirpSync,\n    native: mkdirp_native_js_1.mkdirpNative,\n    nativeSync: mkdirp_native_js_1.mkdirpNativeSync,\n    manual: mkdirp_manual_js_1.mkdirpManual,\n    manualSync: mkdirp_manual_js_1.mkdirpManualSync,\n    useNative: use_native_js_1.useNative,\n    useNativeSync: use_native_js_1.useNativeSync,\n});\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mkdirpManual = exports.mkdirpManualSync = void 0;\nconst path_1 = require(\"path\");\nconst opts_arg_js_1 = require(\"./opts-arg.js\");\nconst mkdirpManualSync = (path, options, made) => {\n    const parent = (0, path_1.dirname)(path);\n    const opts = { ...(0, opts_arg_js_1.optsArg)(options), recursive: false };\n    if (parent === path) {\n        try {\n            return opts.mkdirSync(path, opts);\n        }\n        catch (er) {\n            // swallowed by recursive implementation on posix systems\n            // any other error is a failure\n            const fer = er;\n            if (fer && fer.code !== 'EISDIR') {\n                throw er;\n            }\n            return;\n        }\n    }\n    try {\n        opts.mkdirSync(path, opts);\n        return made || path;\n    }\n    catch (er) {\n        const fer = er;\n        if (fer && fer.code === 'ENOENT') {\n            return (0, exports.mkdirpManualSync)(path, opts, (0, exports.mkdirpManualSync)(parent, opts, made));\n        }\n        if (fer && fer.code !== 'EEXIST' && fer && fer.code !== 'EROFS') {\n            throw er;\n        }\n        try {\n            if (!opts.statSync(path).isDirectory())\n                throw er;\n        }\n        catch (_) {\n            throw er;\n        }\n    }\n};\nexports.mkdirpManualSync = mkdirpManualSync;\nexports.mkdirpManual = Object.assign(async (path, options, made) => {\n    const opts = (0, opts_arg_js_1.optsArg)(options);\n    opts.recursive = false;\n    const parent = (0, path_1.dirname)(path);\n    if (parent === path) {\n        return opts.mkdirAsync(path, opts).catch(er => {\n            // swallowed by recursive implementation on posix systems\n            // any other error is a failure\n            const fer = er;\n            if (fer && fer.code !== 'EISDIR') {\n                throw er;\n            }\n        });\n    }\n    return opts.mkdirAsync(path, opts).then(() => made || path, async (er) => {\n        const fer = er;\n        if (fer && fer.code === 'ENOENT') {\n            return (0, exports.mkdirpManual)(parent, opts).then((made) => (0, exports.mkdirpManual)(path, opts, made));\n        }\n        if (fer && fer.code !== 'EEXIST' && fer.code !== 'EROFS') {\n            throw er;\n        }\n        return opts.statAsync(path).then(st => {\n            if (st.isDirectory()) {\n                return made;\n            }\n            else {\n                throw er;\n            }\n        }, () => {\n            throw er;\n        });\n    });\n}, { sync: exports.mkdirpManualSync });\n//# sourceMappingURL=mkdirp-manual.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mkdirpNative = exports.mkdirpNativeSync = void 0;\nconst path_1 = require(\"path\");\nconst find_made_js_1 = require(\"./find-made.js\");\nconst mkdirp_manual_js_1 = require(\"./mkdirp-manual.js\");\nconst opts_arg_js_1 = require(\"./opts-arg.js\");\nconst mkdirpNativeSync = (path, options) => {\n    const opts = (0, opts_arg_js_1.optsArg)(options);\n    opts.recursive = true;\n    const parent = (0, path_1.dirname)(path);\n    if (parent === path) {\n        return opts.mkdirSync(path, opts);\n    }\n    const made = (0, find_made_js_1.findMadeSync)(opts, path);\n    try {\n        opts.mkdirSync(path, opts);\n        return made;\n    }\n    catch (er) {\n        const fer = er;\n        if (fer && fer.code === 'ENOENT') {\n            return (0, mkdirp_manual_js_1.mkdirpManualSync)(path, opts);\n        }\n        else {\n            throw er;\n        }\n    }\n};\nexports.mkdirpNativeSync = mkdirpNativeSync;\nexports.mkdirpNative = Object.assign(async (path, options) => {\n    const opts = { ...(0, opts_arg_js_1.optsArg)(options), recursive: true };\n    const parent = (0, path_1.dirname)(path);\n    if (parent === path) {\n        return await opts.mkdirAsync(path, opts);\n    }\n    return (0, find_made_js_1.findMade)(opts, path).then((made) => opts\n        .mkdirAsync(path, opts)\n        .then(m => made || m)\n        .catch(er => {\n        const fer = er;\n        if (fer && fer.code === 'ENOENT') {\n            return (0, mkdirp_manual_js_1.mkdirpManual)(path, opts);\n        }\n        else {\n            throw er;\n        }\n    }));\n}, { sync: exports.mkdirpNativeSync });\n//# sourceMappingURL=mkdirp-native.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.optsArg = void 0;\nconst fs_1 = require(\"fs\");\nconst optsArg = (opts) => {\n    if (!opts) {\n        opts = { mode: 0o777 };\n    }\n    else if (typeof opts === 'object') {\n        opts = { mode: 0o777, ...opts };\n    }\n    else if (typeof opts === 'number') {\n        opts = { mode: opts };\n    }\n    else if (typeof opts === 'string') {\n        opts = { mode: parseInt(opts, 8) };\n    }\n    else {\n        throw new TypeError('invalid options argument');\n    }\n    const resolved = opts;\n    const optsFs = opts.fs || {};\n    opts.mkdir = opts.mkdir || optsFs.mkdir || fs_1.mkdir;\n    opts.mkdirAsync = opts.mkdirAsync\n        ? opts.mkdirAsync\n        : async (path, options) => {\n            return new Promise((res, rej) => resolved.mkdir(path, options, (er, made) => er ? rej(er) : res(made)));\n        };\n    opts.stat = opts.stat || optsFs.stat || fs_1.stat;\n    opts.statAsync = opts.statAsync\n        ? opts.statAsync\n        : async (path) => new Promise((res, rej) => resolved.stat(path, (err, stats) => (err ? rej(err) : res(stats))));\n    opts.statSync = opts.statSync || optsFs.statSync || fs_1.statSync;\n    opts.mkdirSync = opts.mkdirSync || optsFs.mkdirSync || fs_1.mkdirSync;\n    return resolved;\n};\nexports.optsArg = optsArg;\n//# sourceMappingURL=opts-arg.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.pathArg = void 0;\nconst platform = process.env.__TESTING_MKDIRP_PLATFORM__ || process.platform;\nconst path_1 = require(\"path\");\nconst pathArg = (path) => {\n    if (/\\0/.test(path)) {\n        // simulate same failure that node raises\n        throw Object.assign(new TypeError('path must be a string without null bytes'), {\n            path,\n            code: 'ERR_INVALID_ARG_VALUE',\n        });\n    }\n    path = (0, path_1.resolve)(path);\n    if (platform === 'win32') {\n        const badWinChars = /[*|\"<>?:]/;\n        const { root } = (0, path_1.parse)(path);\n        if (badWinChars.test(path.substring(root.length))) {\n            throw Object.assign(new Error('Illegal characters in path.'), {\n                path,\n                code: 'EINVAL',\n            });\n        }\n    }\n    return path;\n};\nexports.pathArg = pathArg;\n//# sourceMappingURL=path-arg.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.useNative = exports.useNativeSync = void 0;\nconst fs_1 = require(\"fs\");\nconst opts_arg_js_1 = require(\"./opts-arg.js\");\nconst version = process.env.__TESTING_MKDIRP_NODE_VERSION__ || process.version;\nconst versArr = version.replace(/^v/, '').split('.');\nconst hasNative = +versArr[0] > 10 || (+versArr[0] === 10 && +versArr[1] >= 12);\nexports.useNativeSync = !hasNative\n    ? () => false\n    : (opts) => (0, opts_arg_js_1.optsArg)(opts).mkdirSync === fs_1.mkdirSync;\nexports.useNative = Object.assign(!hasNative\n    ? () => false\n    : (opts) => (0, opts_arg_js_1.optsArg)(opts).mkdir === fs_1.mkdir, {\n    sync: exports.useNativeSync,\n});\n//# sourceMappingURL=use-native.js.map","module.exports = require('./lib/tunnel');\n","'use strict';\n\nvar net = require('net');\nvar tls = require('tls');\nvar http = require('http');\nvar https = require('https');\nvar events = require('events');\nvar assert = require('assert');\nvar util = require('util');\n\n\nexports.httpOverHttp = httpOverHttp;\nexports.httpsOverHttp = httpsOverHttp;\nexports.httpOverHttps = httpOverHttps;\nexports.httpsOverHttps = httpsOverHttps;\n\n\nfunction httpOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  return agent;\n}\n\nfunction httpsOverHttp(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = http.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\nfunction httpOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  return agent;\n}\n\nfunction httpsOverHttps(options) {\n  var agent = new TunnelingAgent(options);\n  agent.request = https.request;\n  agent.createSocket = createSecureSocket;\n  agent.defaultPort = 443;\n  return agent;\n}\n\n\nfunction TunnelingAgent(options) {\n  var self = this;\n  self.options = options || {};\n  self.proxyOptions = self.options.proxy || {};\n  self.maxSockets = self.options.maxSockets || http.Agent.defaultMaxSockets;\n  self.requests = [];\n  self.sockets = [];\n\n  self.on('free', function onFree(socket, host, port, localAddress) {\n    var options = toOptions(host, port, localAddress);\n    for (var i = 0, len = self.requests.length; i < len; ++i) {\n      var pending = self.requests[i];\n      if (pending.host === options.host && pending.port === options.port) {\n        // Detect the request to connect same origin server,\n        // reuse the connection.\n        self.requests.splice(i, 1);\n        pending.request.onSocket(socket);\n        return;\n      }\n    }\n    socket.destroy();\n    self.removeSocket(socket);\n  });\n}\nutil.inherits(TunnelingAgent, events.EventEmitter);\n\nTunnelingAgent.prototype.addRequest = function addRequest(req, host, port, localAddress) {\n  var self = this;\n  var options = mergeOptions({request: req}, self.options, toOptions(host, port, localAddress));\n\n  if (self.sockets.length >= this.maxSockets) {\n    // We are over limit so we'll add it to the queue.\n    self.requests.push(options);\n    return;\n  }\n\n  // If we are under maxSockets create a new one.\n  self.createSocket(options, function(socket) {\n    socket.on('free', onFree);\n    socket.on('close', onCloseOrRemove);\n    socket.on('agentRemove', onCloseOrRemove);\n    req.onSocket(socket);\n\n    function onFree() {\n      self.emit('free', socket, options);\n    }\n\n    function onCloseOrRemove(err) {\n      self.removeSocket(socket);\n      socket.removeListener('free', onFree);\n      socket.removeListener('close', onCloseOrRemove);\n      socket.removeListener('agentRemove', onCloseOrRemove);\n    }\n  });\n};\n\nTunnelingAgent.prototype.createSocket = function createSocket(options, cb) {\n  var self = this;\n  var placeholder = {};\n  self.sockets.push(placeholder);\n\n  var connectOptions = mergeOptions({}, self.proxyOptions, {\n    method: 'CONNECT',\n    path: options.host + ':' + options.port,\n    agent: false,\n    headers: {\n      host: options.host + ':' + options.port\n    }\n  });\n  if (options.localAddress) {\n    connectOptions.localAddress = options.localAddress;\n  }\n  if (connectOptions.proxyAuth) {\n    connectOptions.headers = connectOptions.headers || {};\n    connectOptions.headers['Proxy-Authorization'] = 'Basic ' +\n        new Buffer(connectOptions.proxyAuth).toString('base64');\n  }\n\n  debug('making CONNECT request');\n  var connectReq = self.request(connectOptions);\n  connectReq.useChunkedEncodingByDefault = false; // for v0.6\n  connectReq.once('response', onResponse); // for v0.6\n  connectReq.once('upgrade', onUpgrade);   // for v0.6\n  connectReq.once('connect', onConnect);   // for v0.7 or later\n  connectReq.once('error', onError);\n  connectReq.end();\n\n  function onResponse(res) {\n    // Very hacky. This is necessary to avoid http-parser leaks.\n    res.upgrade = true;\n  }\n\n  function onUpgrade(res, socket, head) {\n    // Hacky.\n    process.nextTick(function() {\n      onConnect(res, socket, head);\n    });\n  }\n\n  function onConnect(res, socket, head) {\n    connectReq.removeAllListeners();\n    socket.removeAllListeners();\n\n    if (res.statusCode !== 200) {\n      debug('tunneling socket could not be established, statusCode=%d',\n        res.statusCode);\n      socket.destroy();\n      var error = new Error('tunneling socket could not be established, ' +\n        'statusCode=' + res.statusCode);\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    if (head.length > 0) {\n      debug('got illegal response body from proxy');\n      socket.destroy();\n      var error = new Error('got illegal response body from proxy');\n      error.code = 'ECONNRESET';\n      options.request.emit('error', error);\n      self.removeSocket(placeholder);\n      return;\n    }\n    debug('tunneling connection has established');\n    self.sockets[self.sockets.indexOf(placeholder)] = socket;\n    return cb(socket);\n  }\n\n  function onError(cause) {\n    connectReq.removeAllListeners();\n\n    debug('tunneling socket could not be established, cause=%s\\n',\n          cause.message, cause.stack);\n    var error = new Error('tunneling socket could not be established, ' +\n                          'cause=' + cause.message);\n    error.code = 'ECONNRESET';\n    options.request.emit('error', error);\n    self.removeSocket(placeholder);\n  }\n};\n\nTunnelingAgent.prototype.removeSocket = function removeSocket(socket) {\n  var pos = this.sockets.indexOf(socket)\n  if (pos === -1) {\n    return;\n  }\n  this.sockets.splice(pos, 1);\n\n  var pending = this.requests.shift();\n  if (pending) {\n    // If we have pending requests and a socket gets closed a new one\n    // needs to be created to take over in the pool for the one that closed.\n    this.createSocket(pending, function(socket) {\n      pending.request.onSocket(socket);\n    });\n  }\n};\n\nfunction createSecureSocket(options, cb) {\n  var self = this;\n  TunnelingAgent.prototype.createSocket.call(self, options, function(socket) {\n    var hostHeader = options.request.getHeader('host');\n    var tlsOptions = mergeOptions({}, self.options, {\n      socket: socket,\n      servername: hostHeader ? hostHeader.replace(/:.*$/, '') : options.host\n    });\n\n    // 0 is dummy port for v0.6\n    var secureSocket = tls.connect(0, tlsOptions);\n    self.sockets[self.sockets.indexOf(socket)] = secureSocket;\n    cb(secureSocket);\n  });\n}\n\n\nfunction toOptions(host, port, localAddress) {\n  if (typeof host === 'string') { // since v0.10\n    return {\n      host: host,\n      port: port,\n      localAddress: localAddress\n    };\n  }\n  return host; // for v0.11 or later\n}\n\nfunction mergeOptions(target) {\n  for (var i = 1, len = arguments.length; i < len; ++i) {\n    var overrides = arguments[i];\n    if (typeof overrides === 'object') {\n      var keys = Object.keys(overrides);\n      for (var j = 0, keyLen = keys.length; j < keyLen; ++j) {\n        var k = keys[j];\n        if (overrides[k] !== undefined) {\n          target[k] = overrides[k];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nvar debug;\nif (process.env.NODE_DEBUG && /\\btunnel\\b/.test(process.env.NODE_DEBUG)) {\n  debug = function() {\n    var args = Array.prototype.slice.call(arguments);\n    if (typeof args[0] === 'string') {\n      args[0] = 'TUNNEL: ' + args[0];\n    } else {\n      args.unshift('TUNNEL:');\n    }\n    console.error.apply(console, args);\n  }\n} else {\n  debug = function() {};\n}\nexports.debug = debug; // for test\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nObject.defineProperty(exports, \"v1\", {\n  enumerable: true,\n  get: function () {\n    return _v.default;\n  }\n});\nObject.defineProperty(exports, \"v3\", {\n  enumerable: true,\n  get: function () {\n    return _v2.default;\n  }\n});\nObject.defineProperty(exports, \"v4\", {\n  enumerable: true,\n  get: function () {\n    return _v3.default;\n  }\n});\nObject.defineProperty(exports, \"v5\", {\n  enumerable: true,\n  get: function () {\n    return _v4.default;\n  }\n});\nObject.defineProperty(exports, \"NIL\", {\n  enumerable: true,\n  get: function () {\n    return _nil.default;\n  }\n});\nObject.defineProperty(exports, \"version\", {\n  enumerable: true,\n  get: function () {\n    return _version.default;\n  }\n});\nObject.defineProperty(exports, \"validate\", {\n  enumerable: true,\n  get: function () {\n    return _validate.default;\n  }\n});\nObject.defineProperty(exports, \"stringify\", {\n  enumerable: true,\n  get: function () {\n    return _stringify.default;\n  }\n});\nObject.defineProperty(exports, \"parse\", {\n  enumerable: true,\n  get: function () {\n    return _parse.default;\n  }\n});\n\nvar _v = _interopRequireDefault(require(\"./v1.js\"));\n\nvar _v2 = _interopRequireDefault(require(\"./v3.js\"));\n\nvar _v3 = _interopRequireDefault(require(\"./v4.js\"));\n\nvar _v4 = _interopRequireDefault(require(\"./v5.js\"));\n\nvar _nil = _interopRequireDefault(require(\"./nil.js\"));\n\nvar _version = _interopRequireDefault(require(\"./version.js\"));\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction md5(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return _crypto.default.createHash('md5').update(bytes).digest();\n}\n\nvar _default = md5;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = '00000000-0000-0000-0000-000000000000';\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction parse(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  let v;\n  const arr = new Uint8Array(16); // Parse ########-....-....-....-............\n\n  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;\n  arr[1] = v >>> 16 & 0xff;\n  arr[2] = v >>> 8 & 0xff;\n  arr[3] = v & 0xff; // Parse ........-####-....-....-............\n\n  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;\n  arr[5] = v & 0xff; // Parse ........-....-####-....-............\n\n  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;\n  arr[7] = v & 0xff; // Parse ........-....-....-####-............\n\n  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;\n  arr[9] = v & 0xff; // Parse ........-....-....-....-############\n  // (Use \"/\" to avoid 32-bit truncation when bit-shifting high-order bytes)\n\n  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;\n  arr[11] = v / 0x100000000 & 0xff;\n  arr[12] = v >>> 24 & 0xff;\n  arr[13] = v >>> 16 & 0xff;\n  arr[14] = v >>> 8 & 0xff;\n  arr[15] = v & 0xff;\n  return arr;\n}\n\nvar _default = parse;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\nvar _default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = rng;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate\n\nlet poolPtr = rnds8Pool.length;\n\nfunction rng() {\n  if (poolPtr > rnds8Pool.length - 16) {\n    _crypto.default.randomFillSync(rnds8Pool);\n\n    poolPtr = 0;\n  }\n\n  return rnds8Pool.slice(poolPtr, poolPtr += 16);\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _crypto = _interopRequireDefault(require(\"crypto\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction sha1(bytes) {\n  if (Array.isArray(bytes)) {\n    bytes = Buffer.from(bytes);\n  } else if (typeof bytes === 'string') {\n    bytes = Buffer.from(bytes, 'utf8');\n  }\n\n  return _crypto.default.createHash('sha1').update(bytes).digest();\n}\n\nvar _default = sha1;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/**\n * Convert array of 16 byte values to UUID string format of the form:\n * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX\n */\nconst byteToHex = [];\n\nfor (let i = 0; i < 256; ++i) {\n  byteToHex.push((i + 0x100).toString(16).substr(1));\n}\n\nfunction stringify(arr, offset = 0) {\n  // Note: Be careful editing this code!  It's been tuned for performance\n  // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434\n  const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + '-' + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + '-' + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + '-' + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + '-' + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one\n  // of the following:\n  // - One or more input array values don't map to a hex octet (leading to\n  // \"undefined\" in the uuid)\n  // - Invalid input values for the RFC `version` or `variant` fields\n\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Stringified UUID is invalid');\n  }\n\n  return uuid;\n}\n\nvar _default = stringify;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _rng = _interopRequireDefault(require(\"./rng.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// **`v1()` - Generate time-based UUID**\n//\n// Inspired by https://github.com/LiosK/UUID.js\n// and http://docs.python.org/library/uuid.html\nlet _nodeId;\n\nlet _clockseq; // Previous uuid creation time\n\n\nlet _lastMSecs = 0;\nlet _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details\n\nfunction v1(options, buf, offset) {\n  let i = buf && offset || 0;\n  const b = buf || new Array(16);\n  options = options || {};\n  let node = options.node || _nodeId;\n  let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not\n  // specified.  We do this lazily to minimize issues related to insufficient\n  // system entropy.  See #189\n\n  if (node == null || clockseq == null) {\n    const seedBytes = options.random || (options.rng || _rng.default)();\n\n    if (node == null) {\n      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)\n      node = _nodeId = [seedBytes[0] | 0x01, seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]];\n    }\n\n    if (clockseq == null) {\n      // Per 4.2.2, randomize (14 bit) clockseq\n      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;\n    }\n  } // UUID timestamps are 100 nano-second units since the Gregorian epoch,\n  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so\n  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'\n  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.\n\n\n  let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock\n  // cycle to simulate higher resolution clock\n\n  let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)\n\n  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression\n\n  if (dt < 0 && options.clockseq === undefined) {\n    clockseq = clockseq + 1 & 0x3fff;\n  } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new\n  // time interval\n\n\n  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {\n    nsecs = 0;\n  } // Per 4.2.1.2 Throw error if too many uuids are requested\n\n\n  if (nsecs >= 10000) {\n    throw new Error(\"uuid.v1(): Can't create more than 10M uuids/sec\");\n  }\n\n  _lastMSecs = msecs;\n  _lastNSecs = nsecs;\n  _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch\n\n  msecs += 12219292800000; // `time_low`\n\n  const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;\n  b[i++] = tl >>> 24 & 0xff;\n  b[i++] = tl >>> 16 & 0xff;\n  b[i++] = tl >>> 8 & 0xff;\n  b[i++] = tl & 0xff; // `time_mid`\n\n  const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;\n  b[i++] = tmh >>> 8 & 0xff;\n  b[i++] = tmh & 0xff; // `time_high_and_version`\n\n  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version\n\n  b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)\n\n  b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`\n\n  b[i++] = clockseq & 0xff; // `node`\n\n  for (let n = 0; n < 6; ++n) {\n    b[i + n] = node[n];\n  }\n\n  return buf || (0, _stringify.default)(b);\n}\n\nvar _default = v1;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _v = _interopRequireDefault(require(\"./v35.js\"));\n\nvar _md = _interopRequireDefault(require(\"./md5.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v3 = (0, _v.default)('v3', 0x30, _md.default);\nvar _default = v3;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = _default;\nexports.URL = exports.DNS = void 0;\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nvar _parse = _interopRequireDefault(require(\"./parse.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction stringToBytes(str) {\n  str = unescape(encodeURIComponent(str)); // UTF8 escape\n\n  const bytes = [];\n\n  for (let i = 0; i < str.length; ++i) {\n    bytes.push(str.charCodeAt(i));\n  }\n\n  return bytes;\n}\n\nconst DNS = '6ba7b810-9dad-11d1-80b4-00c04fd430c8';\nexports.DNS = DNS;\nconst URL = '6ba7b811-9dad-11d1-80b4-00c04fd430c8';\nexports.URL = URL;\n\nfunction _default(name, version, hashfunc) {\n  function generateUUID(value, namespace, buf, offset) {\n    if (typeof value === 'string') {\n      value = stringToBytes(value);\n    }\n\n    if (typeof namespace === 'string') {\n      namespace = (0, _parse.default)(namespace);\n    }\n\n    if (namespace.length !== 16) {\n      throw TypeError('Namespace must be array-like (16 iterable integer values, 0-255)');\n    } // Compute hash of namespace and value, Per 4.3\n    // Future: Use spread syntax when supported on all platforms, e.g. `bytes =\n    // hashfunc([...namespace, ... value])`\n\n\n    let bytes = new Uint8Array(16 + value.length);\n    bytes.set(namespace);\n    bytes.set(value, namespace.length);\n    bytes = hashfunc(bytes);\n    bytes[6] = bytes[6] & 0x0f | version;\n    bytes[8] = bytes[8] & 0x3f | 0x80;\n\n    if (buf) {\n      offset = offset || 0;\n\n      for (let i = 0; i < 16; ++i) {\n        buf[offset + i] = bytes[i];\n      }\n\n      return buf;\n    }\n\n    return (0, _stringify.default)(bytes);\n  } // Function#name is not settable on some platforms (#270)\n\n\n  try {\n    generateUUID.name = name; // eslint-disable-next-line no-empty\n  } catch (err) {} // For CommonJS default export support\n\n\n  generateUUID.DNS = DNS;\n  generateUUID.URL = URL;\n  return generateUUID;\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _rng = _interopRequireDefault(require(\"./rng.js\"));\n\nvar _stringify = _interopRequireDefault(require(\"./stringify.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction v4(options, buf, offset) {\n  options = options || {};\n\n  const rnds = options.random || (options.rng || _rng.default)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`\n\n\n  rnds[6] = rnds[6] & 0x0f | 0x40;\n  rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided\n\n  if (buf) {\n    offset = offset || 0;\n\n    for (let i = 0; i < 16; ++i) {\n      buf[offset + i] = rnds[i];\n    }\n\n    return buf;\n  }\n\n  return (0, _stringify.default)(rnds);\n}\n\nvar _default = v4;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _v = _interopRequireDefault(require(\"./v35.js\"));\n\nvar _sha = _interopRequireDefault(require(\"./sha1.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nconst v5 = (0, _v.default)('v5', 0x50, _sha.default);\nvar _default = v5;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _regex = _interopRequireDefault(require(\"./regex.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction validate(uuid) {\n  return typeof uuid === 'string' && _regex.default.test(uuid);\n}\n\nvar _default = validate;\nexports.default = _default;","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _validate = _interopRequireDefault(require(\"./validate.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction version(uuid) {\n  if (!(0, _validate.default)(uuid)) {\n    throw TypeError('Invalid UUID');\n  }\n\n  return parseInt(uuid.substr(14, 1), 16);\n}\n\nvar _default = version;\nexports.default = _default;",null,"const core = require('@actions/core')\n\n/**\n * Validate arch input values.\n * @returns {string} Returns a validated arch input.\n */\nmodule.exports = function validateArchitecture(standard = '64') {\n  let arch = core.getInput('arch', { required: false }) ?? standard\n\n  if (arch === '86') {\n    arch = 'x86'\n  } else {\n    arch = 'x86-64'\n  }\n\n  core.debug(`Using target architecture: ${arch}`)\n\n  return arch\n}\n","const core = require('@actions/core')\n\n/**\n * Validate binary input values.\n * @returns {bool|string} Returns a validated binary input.\n */\nmodule.exports = function validateBinary(standard = false) {\n  const binary = core.getInput('binary') ?? standard\n  core.debug(\n    binary === true\n      ? 'Encoding into binary format'\n      : 'Encoding into ASCII format'\n  )\n  return binary\n}\n","const core = require('@actions/core')\n\n/**\n * Validate callback input values.\n * @returns {bool|string} Returns a validated callback input.\n */\nmodule.exports = function validateCallback(standard = '') {\n  const callback = core.getInput('callback-file') ?? standard\n  core.debug(\n    `Using callback file in runtime path: ${\n      callback === '' ? 'NONE' : callback\n    }`\n  )\n  return callback\n}\n","const core = require('@actions/core')\n\n/**\n * Validate check input values.\n * @returns {bool|string} Returns a validated check input.\n */\nmodule.exports = function validateCheck(standard = 'auto') {\n  let check = core.getInput('license-check') ?? standard\n\n  if (check === 'auto') {\n    check = 'auto'\n  } else {\n    check = 'script'\n  }\n\n  core.debug(`Using license check: ${check}`)\n  return check\n}\n","const core = require('@actions/core')\n\n/**\n * Validate comments input values.\n * @returns {bool|string} Returns a validated comments input.\n */\nmodule.exports = function validateComments(standard = true) {\n  const comments = !(core.getInput('no-doc-comments') ?? standard)\n  core.debug(\n    comments === true ? 'Allowing doc comments' : 'Now allow doc comments'\n  )\n  return comments\n}\n","const core = require('@actions/core')\n\n/**\n * Validate encoder-version input values.\n * @returns {string} Returns a validated encoder-version input.\n */\nmodule.exports = function validateEncoderVersion(standard = 'current') {\n  let encoderVersion =\n    core.getInput('encoder-version', { required: false }) ?? standard\n\n  core.debug(`Using encoder version: ${encoderVersion}`)\n\n  if (encoderVersion === 'obsolete') {\n    encoderVersion = 'O'\n  } else if (encoderVersion === 'legacy') {\n    encoderVersion = 'L'\n  } else {\n    encoderVersion = 'C'\n  }\n\n  return encoderVersion\n}\n","const core = require('@actions/core')\n\n/**\n * Validate encrypt input values.\n * @returns {bool|string} Returns a validated encrypt input.\n */\nmodule.exports = function validateEncrypt(standard = '') {\n  const encrypt = core.getInput('encrypt') ?? standard\n  core.debug(`Encrypting files: ${encrypt === '' ? 'NONE' : encrypt}`)\n  return encrypt\n}\n","const core = require('@actions/core')\n\n/**\n * Validate input input values.\n * @returns {string} Returns a validated input input.\n */\nmodule.exports = function validateInput(standard = '') {\n  let input = core.getInput('source') ?? standard\n\n  core.debug(`Using input files: ${input === '' ? '.' : input}`)\n\n  if (input === '') {\n    input = __dirname\n  }\n\n  return input.replace(/\\/$/, '')\n}\n","const core = require('@actions/core')\n\n/**\n * Validate license input values.\n * @returns {bool|string} Returns a validated license input.\n */\nmodule.exports = function validateLicense(standard = '') {\n  const license = core.getInput('with-license') ?? standard\n  core.debug(\n    `Using license file in runtime path: ${license === '' ? 'NONE' : license}`\n  )\n  return license\n}\n","const core = require('@actions/core')\n\n/**\n * Validate loader input values.\n * @returns {bool|string} Returns a validated loader input.\n */\nmodule.exports = function validateLoader(standard = true) {\n  const loader = !(core.getInput('without-loader-check') ?? standard)\n  core.debug(\n    loader === true\n      ? 'Checking for loader in environment'\n      : 'Not checking for loader in environment'\n  )\n  return loader\n}\n","const core = require('@actions/core')\n\n/**\n * Validate optimize input values.\n * @returns {bool|string} Returns a validated optimize input.\n */\nmodule.exports = function validateOptimize(standard = 'more') {\n  let optimize = core.getInput('optimize') ?? standard\n\n  if (optimize === 'more') {\n    optimize = 'more'\n  } else {\n    optimize = 'max'\n  }\n\n  core.debug(`Using optimization: ${optimize}`)\n  return optimize\n}\n","const core = require('@actions/core')\n\n/**\n * Validate output input values.\n * @returns {string} Returns a validated output input.\n */\nmodule.exports = function validateOutput(standard = 'encrypted') {\n  const output = core.getInput('output') ?? standard\n\n  core.debug(`Using output path: ${output}`)\n\n  return output\n}\n","const core = require('@actions/core')\n\n/**\n * Validate passphrase input values.\n * @returns {bool|string} Returns a validated passphrase input.\n */\nmodule.exports = function validatePassphrase(standard = '') {\n  const passphrase = core.getInput('passphrase') ?? standard\n  core.debug(`Using passphrase: ${passphrase === '' ? 'NONE' : passphrase}`)\n  return passphrase\n}\n","const core = require('@actions/core')\n\n/**\n * Validate php-target-version input values.\n * @returns {string} Returns a validated php-target-version input.\n */\nmodule.exports = function validatePhpTargetVersion(standard = '8.2') {\n  let phpTargetVersion =\n    core.getInput('php-target-version', { required: false }) ?? standard\n\n  core.debug(`Using PHP target version: ${phpTargetVersion}`)\n\n  if (phpTargetVersion === '8.0') {\n    phpTargetVersion = '80'\n  } else if (phpTargetVersion === '8.1') {\n    phpTargetVersion = '81'\n  } else {\n    phpTargetVersion = '82'\n  }\n\n  return phpTargetVersion\n}\n","const core = require('@actions/core')\n\n/**\n * Validate preamble input values.\n * @returns {bool|string} Returns a validated preamble input.\n */\nmodule.exports = function validatePreamble(standard = '') {\n  const preamble = core.getInput('preamble-file') ?? standard\n  core.debug(`Adding preamble file: ${preamble === '' ? 'NONE' : preamble}`)\n  return preamble\n}\n","const core = require('@actions/core')\n\n/**\n * Validate reflection input values.\n * @returns {bool|string} Returns a validated reflection input.\n */\nmodule.exports = function validateReflection(standard = false) {\n  const reflectionAll = core.getInput('allow-reflection-all') ?? standard\n\n  if (reflectionAll === true) {\n    core.debug('Allowing reflection for all')\n    return true\n  }\n\n  const reflection =\n    core.getInput('allow-reflection') ?? (standard === false ? '' : standard)\n  core.debug(`Using reflection for: ${reflection === '' ? 'NONE' : reflection}`)\n  return reflection\n}\n","const core = require('@actions/core')\n\n/**\n * Validate template input values.\n * @returns {string} Returns a validated template input.\n */\nmodule.exports = function validateTemplate() {\n  const template = core.getInput('template', { required: false }) ?? 'php'\n  core.debug(`Encoding files using template: ${template}`)\n\n  // TODO: validate template values\n\n  return template\n}\n","const core = require('@actions/core')\nconst evaluation = require('../evaluation')\nconst encoder = require('../evaluation')\n\n/**\n * Validate trial input values.\n * @returns {Promise<string>} Returns a validated trial input.\n */\nmodule.exports = async function validateTrial() {\n  const trial = core.getInput('trial', { required: false }) ?? true\n\n  if (trial) {\n    return await evaluation()\n  }\n\n  return await encoder()\n}\n","const core = require('@actions/core')\nconst exec = require('@actions/exec')\nconst validate = require('./validate')\n\n/**\n * The main function for the action.\n * @returns {Promise<void>} Resolves when the action is complete.\n */\nasync function run() {\n  const inputs = await validate()\n\n  let myOutput = ''\n  let myError = ''\n\n  const options = {}\n  options.listeners = {\n    stdout: data => {\n      myOutput += data.toString()\n    },\n    stderr: data => {\n      myError += data.toString()\n    }\n  }\n  options.silent = false\n  options.failOnStdErr = false\n  options.ignoreReturnCode = false\n\n  if (!inputs.trial && process.env.IONCUBE_DOWNLOAD_URL) {\n    try {\n      const exitCode = await exec.exec(\n        `${inputs.ioncube} --activate`,\n        [],\n        options\n      )\n      core.debug(exitCode)\n    } catch (error) {\n      core.error(error)\n    }\n  }\n\n  myOutput = ''\n  myError = ''\n\n  let customOptions = ''\n\n  if (inputs.binary === true) {\n    customOptions += ' --binary'\n  }\n\n  if (inputs.comments === false) {\n    customOptions += ' --no-doc-comments'\n  }\n\n  if (inputs.encrypt !== '') {\n    customOptions += ` --encrypt \"${inputs.encrypt}\"`\n  }\n\n  if (inputs.optimize === 'more' || inputs.optimize === 'max') {\n    customOptions += ` --optimize ${inputs.optimize}`\n  }\n\n  if (inputs.reflection === true) {\n    customOptions += ` --allow-reflection-all`\n  } else if (inputs.reflection !== '') {\n    customOptions += ` --allow-reflection ${inputs.reflection}`\n  }\n\n  if (inputs.preamble !== '') {\n    customOptions += ` --preamble-file ${inputs.preamble}`\n  }\n\n  if (inputs.passphrase !== '') {\n    customOptions += ` --passphrase \"${inputs.passphrase}\"`\n  }\n\n  if (inputs.license !== '') {\n    customOptions += ` --with-license ${inputs.license}`\n  }\n\n  if (inputs.callback !== '') {\n    customOptions += ` --callback-file \"${inputs.callback}\"`\n  }\n\n  if (inputs.check === 'auto' || inputs.check === 'script') {\n    customOptions += ` --license-check ${inputs.check}`\n  }\n\n  customOptions.trim()\n\n  try {\n    const command = `${inputs.ioncube} -${inputs.encoderVersion} -${inputs.phpTargetVersion} -${inputs.arch} ${inputs.input} -o ${inputs.output} ${customOptions} --create-target --replace-target`\n\n    let exitCode = await exec.exec(command, [], options)\n    core.debug(exitCode)\n    core.debug(myOutput)\n    core.debug(myError)\n\n    if (!inputs.trial && process.env.IONCUBE_DOWNLOAD_URL) {\n      myOutput = ''\n      myError = ''\n\n      exitCode = await exec.exec(`${inputs.ioncube} --deactivate`, [], options)\n\n      core.debug(exitCode)\n      core.debug(myOutput)\n      core.debug(myError)\n    }\n\n    core.setOutput('status', 'Project encoded with success')\n  } catch (error) {\n    if (!inputs.trial && process.env.IONCUBE_DOWNLOAD_URL) {\n      myOutput = ''\n      myError = ''\n\n      const exitCode = await exec.exec(\n        `${inputs.ioncube} --deactivate`,\n        [],\n        options\n      )\n\n      core.debug(exitCode)\n      core.debug(myOutput)\n      core.debug(myError)\n    }\n\n    core.setFailed(error.message)\n  }\n}\n\nmodule.exports = {\n  run\n}\n","const laravel = require('./laravel')\n\nconst templates = {\n  laravel\n}\n\n/**\n * Choose correct template based on template input value.\n * @returns {object} Returns defaults values based on templates.\n */\nmodule.exports = function choose(template = 'php') {\n  const standard = {\n    encoderVersion: 'current',\n    phpTargetVersion: '8.2',\n    arch: 64,\n    input: '',\n    output: 'encrypted',\n    reflection: false,\n    encrypt: '',\n    binary: false,\n    optimize: 'more',\n    comments: true,\n    loader: false,\n    preamble: '',\n    passphrase: '',\n    check: 'auto',\n    license: '',\n    callback: ''\n  }\n\n  const args = templates[template]?.()\n  return args ?? standard\n}\n","/**\n * Input values for laravel projects.\n * @returns {object} Returns defaults values for laravel template.\n */\nmodule.exports = function laravel() {\n  return {\n    encoderVersion: 'current',\n    phpTargetVersion: '8.2',\n    arch: 64,\n    input: '',\n    output: 'encrypted',\n    reflection: true,\n    encrypt: '*.blade.php',\n    binary: true,\n    optimize: 'max',\n    comments: true, // without\n    loader: true, // without\n    preamble: '',\n    passphrase: 'CHANGEME',\n    check: 'script',\n    license: '/opt/license',\n    callback: 'public/ioncube.php'\n  }\n}\n","const core = require('@actions/core')\n\nconst EVALUATION_PATH = require('./evaluation')\nconst choose = require('./templates/choose')\nconst validateTrial = require('./inputs/trial')\nconst validateTemplate = require('./inputs/template')\nconst validateEncoderVersion = require('./inputs/encoder-version')\nconst validatePhpTargetVersion = require('./inputs/php-target-version')\nconst validateArchitecture = require('./inputs/architecture')\nconst validateInput = require('./inputs/input')\nconst validateOutput = require('./inputs/output')\nconst validateReflection = require('./inputs/reflection')\nconst validateEncrypt = require('./inputs/encrypt')\nconst validateBinary = require('./inputs/binary')\nconst validateOptimize = require('./inputs/optimize')\nconst validateComments = require('./inputs/comments')\nconst validateLoader = require('./inputs/loader')\nconst validatePreamble = require('./inputs/preamble')\nconst validatePassphrase = require('./inputs/passphrase')\nconst validateCheck = require('./inputs/check')\nconst validateLicense = require('./inputs/license')\nconst validateCallback = require('./inputs/callback')\n\n/**\n * Set default arguments depending on inputed template.\n * @returns {Promise<object>} Inputs based on templates.\n */\nmodule.exports = async function validate() {\n  const ioncube = await validateTrial()\n  const trial = ioncube === EVALUATION_PATH ? true : false\n\n  const template = validateTemplate()\n  const defaults = choose(template)\n\n  return {\n    template,\n    ioncube,\n    trial,\n    encoderVersion: validateEncoderVersion(defaults.encoderVersion),\n    phpTargetVersion: validatePhpTargetVersion(defaults.phpTargetVersion),\n    arch: validateArchitecture(defaults.arch),\n    input: validateInput(defaults.input),\n    output: validateOutput(defaults.output),\n    reflection: validateReflection(defaults.reflection),\n    encrypt: validateEncrypt(defaults.encrypt),\n    binary: validateBinary(defaults.binary),\n    optimize: validateOptimize(defaults.optimize),\n    comments: validateComments(defaults.comments),\n    loader: validateLoader(defaults.loader),\n    preamble: validatePreamble(defaults.preamble),\n    passphrase: validatePassphrase(defaults.passphrase),\n    check: validateCheck(defaults.check),\n    license: validateLicense(defaults.license),\n    callback: validateCallback(defaults.callback)\n  }\n}\n","module.exports = require(\"assert\");","module.exports = require(\"buffer\");","module.exports = require(\"child_process\");","module.exports = require(\"crypto\");","module.exports = require(\"events\");","module.exports = require(\"fs\");","module.exports = require(\"http\");","module.exports = require(\"https\");","module.exports = require(\"net\");","module.exports = require(\"node:assert\");","module.exports = require(\"node:crypto\");","module.exports = require(\"node:events\");","module.exports = require(\"node:fs\");","module.exports = require(\"node:path\");","module.exports = require(\"node:stream\");","module.exports = require(\"node:string_decoder\");","module.exports = require(\"os\");","module.exports = require(\"path\");","module.exports = require(\"process\");","module.exports = require(\"string_decoder\");","module.exports = require(\"timers\");","module.exports = require(\"tls\");","module.exports = require(\"util\");","module.exports = require(\"zlib\");","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WriteStreamSync = exports.WriteStream = exports.ReadStreamSync = exports.ReadStream = void 0;\nconst events_1 = __importDefault(require(\"events\"));\nconst fs_1 = __importDefault(require(\"fs\"));\nconst minipass_1 = require(\"minipass\");\nconst writev = fs_1.default.writev;\nconst _autoClose = Symbol('_autoClose');\nconst _close = Symbol('_close');\nconst _ended = Symbol('_ended');\nconst _fd = Symbol('_fd');\nconst _finished = Symbol('_finished');\nconst _flags = Symbol('_flags');\nconst _flush = Symbol('_flush');\nconst _handleChunk = Symbol('_handleChunk');\nconst _makeBuf = Symbol('_makeBuf');\nconst _mode = Symbol('_mode');\nconst _needDrain = Symbol('_needDrain');\nconst _onerror = Symbol('_onerror');\nconst _onopen = Symbol('_onopen');\nconst _onread = Symbol('_onread');\nconst _onwrite = Symbol('_onwrite');\nconst _open = Symbol('_open');\nconst _path = Symbol('_path');\nconst _pos = Symbol('_pos');\nconst _queue = Symbol('_queue');\nconst _read = Symbol('_read');\nconst _readSize = Symbol('_readSize');\nconst _reading = Symbol('_reading');\nconst _remain = Symbol('_remain');\nconst _size = Symbol('_size');\nconst _write = Symbol('_write');\nconst _writing = Symbol('_writing');\nconst _defaultFlag = Symbol('_defaultFlag');\nconst _errored = Symbol('_errored');\nclass ReadStream extends minipass_1.Minipass {\n    [_errored] = false;\n    [_fd];\n    [_path];\n    [_readSize];\n    [_reading] = false;\n    [_size];\n    [_remain];\n    [_autoClose];\n    constructor(path, opt) {\n        opt = opt || {};\n        super(opt);\n        this.readable = true;\n        this.writable = false;\n        if (typeof path !== 'string') {\n            throw new TypeError('path must be a string');\n        }\n        this[_errored] = false;\n        this[_fd] = typeof opt.fd === 'number' ? opt.fd : undefined;\n        this[_path] = path;\n        this[_readSize] = opt.readSize || 16 * 1024 * 1024;\n        this[_reading] = false;\n        this[_size] = typeof opt.size === 'number' ? opt.size : Infinity;\n        this[_remain] = this[_size];\n        this[_autoClose] =\n            typeof opt.autoClose === 'boolean' ? opt.autoClose : true;\n        if (typeof this[_fd] === 'number') {\n            this[_read]();\n        }\n        else {\n            this[_open]();\n        }\n    }\n    get fd() {\n        return this[_fd];\n    }\n    get path() {\n        return this[_path];\n    }\n    //@ts-ignore\n    write() {\n        throw new TypeError('this is a readable stream');\n    }\n    //@ts-ignore\n    end() {\n        throw new TypeError('this is a readable stream');\n    }\n    [_open]() {\n        fs_1.default.open(this[_path], 'r', (er, fd) => this[_onopen](er, fd));\n    }\n    [_onopen](er, fd) {\n        if (er) {\n            this[_onerror](er);\n        }\n        else {\n            this[_fd] = fd;\n            this.emit('open', fd);\n            this[_read]();\n        }\n    }\n    [_makeBuf]() {\n        return Buffer.allocUnsafe(Math.min(this[_readSize], this[_remain]));\n    }\n    [_read]() {\n        if (!this[_reading]) {\n            this[_reading] = true;\n            const buf = this[_makeBuf]();\n            /* c8 ignore start */\n            if (buf.length === 0) {\n                return process.nextTick(() => this[_onread](null, 0, buf));\n            }\n            /* c8 ignore stop */\n            fs_1.default.read(this[_fd], buf, 0, buf.length, null, (er, br, b) => this[_onread](er, br, b));\n        }\n    }\n    [_onread](er, br, buf) {\n        this[_reading] = false;\n        if (er) {\n            this[_onerror](er);\n        }\n        else if (this[_handleChunk](br, buf)) {\n            this[_read]();\n        }\n    }\n    [_close]() {\n        if (this[_autoClose] && typeof this[_fd] === 'number') {\n            const fd = this[_fd];\n            this[_fd] = undefined;\n            fs_1.default.close(fd, er => er ? this.emit('error', er) : this.emit('close'));\n        }\n    }\n    [_onerror](er) {\n        this[_reading] = true;\n        this[_close]();\n        this.emit('error', er);\n    }\n    [_handleChunk](br, buf) {\n        let ret = false;\n        // no effect if infinite\n        this[_remain] -= br;\n        if (br > 0) {\n            ret = super.write(br < buf.length ? buf.subarray(0, br) : buf);\n        }\n        if (br === 0 || this[_remain] <= 0) {\n            ret = false;\n            this[_close]();\n            super.end();\n        }\n        return ret;\n    }\n    emit(ev, ...args) {\n        switch (ev) {\n            case 'prefinish':\n            case 'finish':\n                return false;\n            case 'drain':\n                if (typeof this[_fd] === 'number') {\n                    this[_read]();\n                }\n                return false;\n            case 'error':\n                if (this[_errored]) {\n                    return false;\n                }\n                this[_errored] = true;\n                return super.emit(ev, ...args);\n            default:\n                return super.emit(ev, ...args);\n        }\n    }\n}\nexports.ReadStream = ReadStream;\nclass ReadStreamSync extends ReadStream {\n    [_open]() {\n        let threw = true;\n        try {\n            this[_onopen](null, fs_1.default.openSync(this[_path], 'r'));\n            threw = false;\n        }\n        finally {\n            if (threw) {\n                this[_close]();\n            }\n        }\n    }\n    [_read]() {\n        let threw = true;\n        try {\n            if (!this[_reading]) {\n                this[_reading] = true;\n                do {\n                    const buf = this[_makeBuf]();\n                    /* c8 ignore start */\n                    const br = buf.length === 0\n                        ? 0\n                        : fs_1.default.readSync(this[_fd], buf, 0, buf.length, null);\n                    /* c8 ignore stop */\n                    if (!this[_handleChunk](br, buf)) {\n                        break;\n                    }\n                } while (true);\n                this[_reading] = false;\n            }\n            threw = false;\n        }\n        finally {\n            if (threw) {\n                this[_close]();\n            }\n        }\n    }\n    [_close]() {\n        if (this[_autoClose] && typeof this[_fd] === 'number') {\n            const fd = this[_fd];\n            this[_fd] = undefined;\n            fs_1.default.closeSync(fd);\n            this.emit('close');\n        }\n    }\n}\nexports.ReadStreamSync = ReadStreamSync;\nclass WriteStream extends events_1.default {\n    readable = false;\n    writable = true;\n    [_errored] = false;\n    [_writing] = false;\n    [_ended] = false;\n    [_queue] = [];\n    [_needDrain] = false;\n    [_path];\n    [_mode];\n    [_autoClose];\n    [_fd];\n    [_defaultFlag];\n    [_flags];\n    [_finished] = false;\n    [_pos];\n    constructor(path, opt) {\n        opt = opt || {};\n        super(opt);\n        this[_path] = path;\n        this[_fd] = typeof opt.fd === 'number' ? opt.fd : undefined;\n        this[_mode] = opt.mode === undefined ? 0o666 : opt.mode;\n        this[_pos] = typeof opt.start === 'number' ? opt.start : undefined;\n        this[_autoClose] =\n            typeof opt.autoClose === 'boolean' ? opt.autoClose : true;\n        // truncating makes no sense when writing into the middle\n        const defaultFlag = this[_pos] !== undefined ? 'r+' : 'w';\n        this[_defaultFlag] = opt.flags === undefined;\n        this[_flags] = opt.flags === undefined ? defaultFlag : opt.flags;\n        if (this[_fd] === undefined) {\n            this[_open]();\n        }\n    }\n    emit(ev, ...args) {\n        if (ev === 'error') {\n            if (this[_errored]) {\n                return false;\n            }\n            this[_errored] = true;\n        }\n        return super.emit(ev, ...args);\n    }\n    get fd() {\n        return this[_fd];\n    }\n    get path() {\n        return this[_path];\n    }\n    [_onerror](er) {\n        this[_close]();\n        this[_writing] = true;\n        this.emit('error', er);\n    }\n    [_open]() {\n        fs_1.default.open(this[_path], this[_flags], this[_mode], (er, fd) => this[_onopen](er, fd));\n    }\n    [_onopen](er, fd) {\n        if (this[_defaultFlag] &&\n            this[_flags] === 'r+' &&\n            er &&\n            er.code === 'ENOENT') {\n            this[_flags] = 'w';\n            this[_open]();\n        }\n        else if (er) {\n            this[_onerror](er);\n        }\n        else {\n            this[_fd] = fd;\n            this.emit('open', fd);\n            if (!this[_writing]) {\n                this[_flush]();\n            }\n        }\n    }\n    end(buf, enc) {\n        if (buf) {\n            //@ts-ignore\n            this.write(buf, enc);\n        }\n        this[_ended] = true;\n        // synthetic after-write logic, where drain/finish live\n        if (!this[_writing] &&\n            !this[_queue].length &&\n            typeof this[_fd] === 'number') {\n            this[_onwrite](null, 0);\n        }\n        return this;\n    }\n    write(buf, enc) {\n        if (typeof buf === 'string') {\n            buf = Buffer.from(buf, enc);\n        }\n        if (this[_ended]) {\n            this.emit('error', new Error('write() after end()'));\n            return false;\n        }\n        if (this[_fd] === undefined || this[_writing] || this[_queue].length) {\n            this[_queue].push(buf);\n            this[_needDrain] = true;\n            return false;\n        }\n        this[_writing] = true;\n        this[_write](buf);\n        return true;\n    }\n    [_write](buf) {\n        fs_1.default.write(this[_fd], buf, 0, buf.length, this[_pos], (er, bw) => this[_onwrite](er, bw));\n    }\n    [_onwrite](er, bw) {\n        if (er) {\n            this[_onerror](er);\n        }\n        else {\n            if (this[_pos] !== undefined && typeof bw === 'number') {\n                this[_pos] += bw;\n            }\n            if (this[_queue].length) {\n                this[_flush]();\n            }\n            else {\n                this[_writing] = false;\n                if (this[_ended] && !this[_finished]) {\n                    this[_finished] = true;\n                    this[_close]();\n                    this.emit('finish');\n                }\n                else if (this[_needDrain]) {\n                    this[_needDrain] = false;\n                    this.emit('drain');\n                }\n            }\n        }\n    }\n    [_flush]() {\n        if (this[_queue].length === 0) {\n            if (this[_ended]) {\n                this[_onwrite](null, 0);\n            }\n        }\n        else if (this[_queue].length === 1) {\n            this[_write](this[_queue].pop());\n        }\n        else {\n            const iovec = this[_queue];\n            this[_queue] = [];\n            writev(this[_fd], iovec, this[_pos], (er, bw) => this[_onwrite](er, bw));\n        }\n    }\n    [_close]() {\n        if (this[_autoClose] && typeof this[_fd] === 'number') {\n            const fd = this[_fd];\n            this[_fd] = undefined;\n            fs_1.default.close(fd, er => er ? this.emit('error', er) : this.emit('close'));\n        }\n    }\n}\nexports.WriteStream = WriteStream;\nclass WriteStreamSync extends WriteStream {\n    [_open]() {\n        let fd;\n        // only wrap in a try{} block if we know we'll retry, to avoid\n        // the rethrow obscuring the error's source frame in most cases.\n        if (this[_defaultFlag] && this[_flags] === 'r+') {\n            try {\n                fd = fs_1.default.openSync(this[_path], this[_flags], this[_mode]);\n            }\n            catch (er) {\n                if (er?.code === 'ENOENT') {\n                    this[_flags] = 'w';\n                    return this[_open]();\n                }\n                else {\n                    throw er;\n                }\n            }\n        }\n        else {\n            fd = fs_1.default.openSync(this[_path], this[_flags], this[_mode]);\n        }\n        this[_onopen](null, fd);\n    }\n    [_close]() {\n        if (this[_autoClose] && typeof this[_fd] === 'number') {\n            const fd = this[_fd];\n            this[_fd] = undefined;\n            fs_1.default.closeSync(fd);\n            this.emit('close');\n        }\n    }\n    [_write](buf) {\n        // throw the original, but try to close if it fails\n        let threw = true;\n        try {\n            this[_onwrite](null, fs_1.default.writeSync(this[_fd], buf, 0, buf.length, this[_pos]));\n            threw = false;\n        }\n        finally {\n            if (threw) {\n                try {\n                    this[_close]();\n                }\n                catch {\n                    // ok error\n                }\n            }\n        }\n    }\n}\nexports.WriteStreamSync = WriteStreamSync;\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.chownrSync = exports.chownr = void 0;\nconst node_fs_1 = __importDefault(require(\"node:fs\"));\nconst node_path_1 = __importDefault(require(\"node:path\"));\nconst lchownSync = (path, uid, gid) => {\n    try {\n        return node_fs_1.default.lchownSync(path, uid, gid);\n    }\n    catch (er) {\n        if (er?.code !== 'ENOENT')\n            throw er;\n    }\n};\nconst chown = (cpath, uid, gid, cb) => {\n    node_fs_1.default.lchown(cpath, uid, gid, er => {\n        // Skip ENOENT error\n        cb(er && er?.code !== 'ENOENT' ? er : null);\n    });\n};\nconst chownrKid = (p, child, uid, gid, cb) => {\n    if (child.isDirectory()) {\n        (0, exports.chownr)(node_path_1.default.resolve(p, child.name), uid, gid, (er) => {\n            if (er)\n                return cb(er);\n            const cpath = node_path_1.default.resolve(p, child.name);\n            chown(cpath, uid, gid, cb);\n        });\n    }\n    else {\n        const cpath = node_path_1.default.resolve(p, child.name);\n        chown(cpath, uid, gid, cb);\n    }\n};\nconst chownr = (p, uid, gid, cb) => {\n    node_fs_1.default.readdir(p, { withFileTypes: true }, (er, children) => {\n        // any error other than ENOTDIR or ENOTSUP means it's not readable,\n        // or doesn't exist.  give up.\n        if (er) {\n            if (er.code === 'ENOENT')\n                return cb();\n            else if (er.code !== 'ENOTDIR' && er.code !== 'ENOTSUP')\n                return cb(er);\n        }\n        if (er || !children.length)\n            return chown(p, uid, gid, cb);\n        let len = children.length;\n        let errState = null;\n        const then = (er) => {\n            /* c8 ignore start */\n            if (errState)\n                return;\n            /* c8 ignore stop */\n            if (er)\n                return cb((errState = er));\n            if (--len === 0)\n                return chown(p, uid, gid, cb);\n        };\n        for (const child of children) {\n            chownrKid(p, child, uid, gid, then);\n        }\n    });\n};\nexports.chownr = chownr;\nconst chownrKidSync = (p, child, uid, gid) => {\n    if (child.isDirectory())\n        (0, exports.chownrSync)(node_path_1.default.resolve(p, child.name), uid, gid);\n    lchownSync(node_path_1.default.resolve(p, child.name), uid, gid);\n};\nconst chownrSync = (p, uid, gid) => {\n    let children;\n    try {\n        children = node_fs_1.default.readdirSync(p, { withFileTypes: true });\n    }\n    catch (er) {\n        const e = er;\n        if (e?.code === 'ENOENT')\n            return;\n        else if (e?.code === 'ENOTDIR' || e?.code === 'ENOTSUP')\n            return lchownSync(p, uid, gid);\n        else\n            throw e;\n    }\n    for (const child of children) {\n        chownrKidSync(p, child, uid, gid);\n    }\n    return lchownSync(p, uid, gid);\n};\nexports.chownrSync = chownrSync;\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Minipass = exports.isWritable = exports.isReadable = exports.isStream = void 0;\nconst proc = typeof process === 'object' && process\n    ? process\n    : {\n        stdout: null,\n        stderr: null,\n    };\nconst node_events_1 = require(\"node:events\");\nconst node_stream_1 = __importDefault(require(\"node:stream\"));\nconst node_string_decoder_1 = require(\"node:string_decoder\");\n/**\n * Return true if the argument is a Minipass stream, Node stream, or something\n * else that Minipass can interact with.\n */\nconst isStream = (s) => !!s &&\n    typeof s === 'object' &&\n    (s instanceof Minipass ||\n        s instanceof node_stream_1.default ||\n        (0, exports.isReadable)(s) ||\n        (0, exports.isWritable)(s));\nexports.isStream = isStream;\n/**\n * Return true if the argument is a valid {@link Minipass.Readable}\n */\nconst isReadable = (s) => !!s &&\n    typeof s === 'object' &&\n    s instanceof node_events_1.EventEmitter &&\n    typeof s.pipe === 'function' &&\n    // node core Writable streams have a pipe() method, but it throws\n    s.pipe !== node_stream_1.default.Writable.prototype.pipe;\nexports.isReadable = isReadable;\n/**\n * Return true if the argument is a valid {@link Minipass.Writable}\n */\nconst isWritable = (s) => !!s &&\n    typeof s === 'object' &&\n    s instanceof node_events_1.EventEmitter &&\n    typeof s.write === 'function' &&\n    typeof s.end === 'function';\nexports.isWritable = isWritable;\nconst EOF = Symbol('EOF');\nconst MAYBE_EMIT_END = Symbol('maybeEmitEnd');\nconst EMITTED_END = Symbol('emittedEnd');\nconst EMITTING_END = Symbol('emittingEnd');\nconst EMITTED_ERROR = Symbol('emittedError');\nconst CLOSED = Symbol('closed');\nconst READ = Symbol('read');\nconst FLUSH = Symbol('flush');\nconst FLUSHCHUNK = Symbol('flushChunk');\nconst ENCODING = Symbol('encoding');\nconst DECODER = Symbol('decoder');\nconst FLOWING = Symbol('flowing');\nconst PAUSED = Symbol('paused');\nconst RESUME = Symbol('resume');\nconst BUFFER = Symbol('buffer');\nconst PIPES = Symbol('pipes');\nconst BUFFERLENGTH = Symbol('bufferLength');\nconst BUFFERPUSH = Symbol('bufferPush');\nconst BUFFERSHIFT = Symbol('bufferShift');\nconst OBJECTMODE = Symbol('objectMode');\n// internal event when stream is destroyed\nconst DESTROYED = Symbol('destroyed');\n// internal event when stream has an error\nconst ERROR = Symbol('error');\nconst EMITDATA = Symbol('emitData');\nconst EMITEND = Symbol('emitEnd');\nconst EMITEND2 = Symbol('emitEnd2');\nconst ASYNC = Symbol('async');\nconst ABORT = Symbol('abort');\nconst ABORTED = Symbol('aborted');\nconst SIGNAL = Symbol('signal');\nconst DATALISTENERS = Symbol('dataListeners');\nconst DISCARDED = Symbol('discarded');\nconst defer = (fn) => Promise.resolve().then(fn);\nconst nodefer = (fn) => fn();\nconst isEndish = (ev) => ev === 'end' || ev === 'finish' || ev === 'prefinish';\nconst isArrayBufferLike = (b) => b instanceof ArrayBuffer ||\n    (!!b &&\n        typeof b === 'object' &&\n        b.constructor &&\n        b.constructor.name === 'ArrayBuffer' &&\n        b.byteLength >= 0);\nconst isArrayBufferView = (b) => !Buffer.isBuffer(b) && ArrayBuffer.isView(b);\n/**\n * Internal class representing a pipe to a destination stream.\n *\n * @internal\n */\nclass Pipe {\n    src;\n    dest;\n    opts;\n    ondrain;\n    constructor(src, dest, opts) {\n        this.src = src;\n        this.dest = dest;\n        this.opts = opts;\n        this.ondrain = () => src[RESUME]();\n        this.dest.on('drain', this.ondrain);\n    }\n    unpipe() {\n        this.dest.removeListener('drain', this.ondrain);\n    }\n    // only here for the prototype\n    /* c8 ignore start */\n    proxyErrors(_er) { }\n    /* c8 ignore stop */\n    end() {\n        this.unpipe();\n        if (this.opts.end)\n            this.dest.end();\n    }\n}\n/**\n * Internal class representing a pipe to a destination stream where\n * errors are proxied.\n *\n * @internal\n */\nclass PipeProxyErrors extends Pipe {\n    unpipe() {\n        this.src.removeListener('error', this.proxyErrors);\n        super.unpipe();\n    }\n    constructor(src, dest, opts) {\n        super(src, dest, opts);\n        this.proxyErrors = er => dest.emit('error', er);\n        src.on('error', this.proxyErrors);\n    }\n}\nconst isObjectModeOptions = (o) => !!o.objectMode;\nconst isEncodingOptions = (o) => !o.objectMode && !!o.encoding && o.encoding !== 'buffer';\n/**\n * Main export, the Minipass class\n *\n * `RType` is the type of data emitted, defaults to Buffer\n *\n * `WType` is the type of data to be written, if RType is buffer or string,\n * then any {@link Minipass.ContiguousData} is allowed.\n *\n * `Events` is the set of event handler signatures that this object\n * will emit, see {@link Minipass.Events}\n */\nclass Minipass extends node_events_1.EventEmitter {\n    [FLOWING] = false;\n    [PAUSED] = false;\n    [PIPES] = [];\n    [BUFFER] = [];\n    [OBJECTMODE];\n    [ENCODING];\n    [ASYNC];\n    [DECODER];\n    [EOF] = false;\n    [EMITTED_END] = false;\n    [EMITTING_END] = false;\n    [CLOSED] = false;\n    [EMITTED_ERROR] = null;\n    [BUFFERLENGTH] = 0;\n    [DESTROYED] = false;\n    [SIGNAL];\n    [ABORTED] = false;\n    [DATALISTENERS] = 0;\n    [DISCARDED] = false;\n    /**\n     * true if the stream can be written\n     */\n    writable = true;\n    /**\n     * true if the stream can be read\n     */\n    readable = true;\n    /**\n     * If `RType` is Buffer, then options do not need to be provided.\n     * Otherwise, an options object must be provided to specify either\n     * {@link Minipass.SharedOptions.objectMode} or\n     * {@link Minipass.SharedOptions.encoding}, as appropriate.\n     */\n    constructor(...args) {\n        const options = (args[0] ||\n            {});\n        super();\n        if (options.objectMode && typeof options.encoding === 'string') {\n            throw new TypeError('Encoding and objectMode may not be used together');\n        }\n        if (isObjectModeOptions(options)) {\n            this[OBJECTMODE] = true;\n            this[ENCODING] = null;\n        }\n        else if (isEncodingOptions(options)) {\n            this[ENCODING] = options.encoding;\n            this[OBJECTMODE] = false;\n        }\n        else {\n            this[OBJECTMODE] = false;\n            this[ENCODING] = null;\n        }\n        this[ASYNC] = !!options.async;\n        this[DECODER] = this[ENCODING]\n            ? new node_string_decoder_1.StringDecoder(this[ENCODING])\n            : null;\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposeBuffer === true) {\n            Object.defineProperty(this, 'buffer', { get: () => this[BUFFER] });\n        }\n        //@ts-ignore - private option for debugging and testing\n        if (options && options.debugExposePipes === true) {\n            Object.defineProperty(this, 'pipes', { get: () => this[PIPES] });\n        }\n        const { signal } = options;\n        if (signal) {\n            this[SIGNAL] = signal;\n            if (signal.aborted) {\n                this[ABORT]();\n            }\n            else {\n                signal.addEventListener('abort', () => this[ABORT]());\n            }\n        }\n    }\n    /**\n     * The amount of data stored in the buffer waiting to be read.\n     *\n     * For Buffer strings, this will be the total byte length.\n     * For string encoding streams, this will be the string character length,\n     * according to JavaScript's `string.length` logic.\n     * For objectMode streams, this is a count of the items waiting to be\n     * emitted.\n     */\n    get bufferLength() {\n        return this[BUFFERLENGTH];\n    }\n    /**\n     * The `BufferEncoding` currently in use, or `null`\n     */\n    get encoding() {\n        return this[ENCODING];\n    }\n    /**\n     * @deprecated - This is a read only property\n     */\n    set encoding(_enc) {\n        throw new Error('Encoding must be set at instantiation time');\n    }\n    /**\n     * @deprecated - Encoding may only be set at instantiation time\n     */\n    setEncoding(_enc) {\n        throw new Error('Encoding must be set at instantiation time');\n    }\n    /**\n     * True if this is an objectMode stream\n     */\n    get objectMode() {\n        return this[OBJECTMODE];\n    }\n    /**\n     * @deprecated - This is a read-only property\n     */\n    set objectMode(_om) {\n        throw new Error('objectMode must be set at instantiation time');\n    }\n    /**\n     * true if this is an async stream\n     */\n    get ['async']() {\n        return this[ASYNC];\n    }\n    /**\n     * Set to true to make this stream async.\n     *\n     * Once set, it cannot be unset, as this would potentially cause incorrect\n     * behavior.  Ie, a sync stream can be made async, but an async stream\n     * cannot be safely made sync.\n     */\n    set ['async'](a) {\n        this[ASYNC] = this[ASYNC] || !!a;\n    }\n    // drop everything and get out of the flow completely\n    [ABORT]() {\n        this[ABORTED] = true;\n        this.emit('abort', this[SIGNAL]?.reason);\n        this.destroy(this[SIGNAL]?.reason);\n    }\n    /**\n     * True if the stream has been aborted.\n     */\n    get aborted() {\n        return this[ABORTED];\n    }\n    /**\n     * No-op setter. Stream aborted status is set via the AbortSignal provided\n     * in the constructor options.\n     */\n    set aborted(_) { }\n    write(chunk, encoding, cb) {\n        if (this[ABORTED])\n            return false;\n        if (this[EOF])\n            throw new Error('write after end');\n        if (this[DESTROYED]) {\n            this.emit('error', Object.assign(new Error('Cannot call write after a stream was destroyed'), { code: 'ERR_STREAM_DESTROYED' }));\n            return true;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = 'utf8';\n        }\n        if (!encoding)\n            encoding = 'utf8';\n        const fn = this[ASYNC] ? defer : nodefer;\n        // convert array buffers and typed array views into buffers\n        // at some point in the future, we may want to do the opposite!\n        // leave strings and buffers as-is\n        // anything is only allowed if in object mode, so throw\n        if (!this[OBJECTMODE] && !Buffer.isBuffer(chunk)) {\n            if (isArrayBufferView(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk.buffer, chunk.byteOffset, chunk.byteLength);\n            }\n            else if (isArrayBufferLike(chunk)) {\n                //@ts-ignore - sinful unsafe type changing\n                chunk = Buffer.from(chunk);\n            }\n            else if (typeof chunk !== 'string') {\n                throw new Error('Non-contiguous data written to non-objectMode stream');\n            }\n        }\n        // handle object mode up front, since it's simpler\n        // this yields better performance, fewer checks later.\n        if (this[OBJECTMODE]) {\n            // maybe impossible?\n            /* c8 ignore start */\n            if (this[FLOWING] && this[BUFFERLENGTH] !== 0)\n                this[FLUSH](true);\n            /* c8 ignore stop */\n            if (this[FLOWING])\n                this.emit('data', chunk);\n            else\n                this[BUFFERPUSH](chunk);\n            if (this[BUFFERLENGTH] !== 0)\n                this.emit('readable');\n            if (cb)\n                fn(cb);\n            return this[FLOWING];\n        }\n        // at this point the chunk is a buffer or string\n        // don't buffer it up or send it to the decoder\n        if (!chunk.length) {\n            if (this[BUFFERLENGTH] !== 0)\n                this.emit('readable');\n            if (cb)\n                fn(cb);\n            return this[FLOWING];\n        }\n        // fast-path writing strings of same encoding to a stream with\n        // an empty buffer, skipping the buffer/decoder dance\n        if (typeof chunk === 'string' &&\n            // unless it is a string already ready for us to use\n            !(encoding === this[ENCODING] && !this[DECODER]?.lastNeed)) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = Buffer.from(chunk, encoding);\n        }\n        if (Buffer.isBuffer(chunk) && this[ENCODING]) {\n            //@ts-ignore - sinful unsafe type change\n            chunk = this[DECODER].write(chunk);\n        }\n        // Note: flushing CAN potentially switch us into not-flowing mode\n        if (this[FLOWING] && this[BUFFERLENGTH] !== 0)\n            this[FLUSH](true);\n        if (this[FLOWING])\n            this.emit('data', chunk);\n        else\n            this[BUFFERPUSH](chunk);\n        if (this[BUFFERLENGTH] !== 0)\n            this.emit('readable');\n        if (cb)\n            fn(cb);\n        return this[FLOWING];\n    }\n    /**\n     * Low-level explicit read method.\n     *\n     * In objectMode, the argument is ignored, and one item is returned if\n     * available.\n     *\n     * `n` is the number of bytes (or in the case of encoding streams,\n     * characters) to consume. If `n` is not provided, then the entire buffer\n     * is returned, or `null` is returned if no data is available.\n     *\n     * If `n` is greater that the amount of data in the internal buffer,\n     * then `null` is returned.\n     */\n    read(n) {\n        if (this[DESTROYED])\n            return null;\n        this[DISCARDED] = false;\n        if (this[BUFFERLENGTH] === 0 ||\n            n === 0 ||\n            (n && n > this[BUFFERLENGTH])) {\n            this[MAYBE_EMIT_END]();\n            return null;\n        }\n        if (this[OBJECTMODE])\n            n = null;\n        if (this[BUFFER].length > 1 && !this[OBJECTMODE]) {\n            // not object mode, so if we have an encoding, then RType is string\n            // otherwise, must be Buffer\n            this[BUFFER] = [\n                (this[ENCODING]\n                    ? this[BUFFER].join('')\n                    : Buffer.concat(this[BUFFER], this[BUFFERLENGTH])),\n            ];\n        }\n        const ret = this[READ](n || null, this[BUFFER][0]);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [READ](n, chunk) {\n        if (this[OBJECTMODE])\n            this[BUFFERSHIFT]();\n        else {\n            const c = chunk;\n            if (n === c.length || n === null)\n                this[BUFFERSHIFT]();\n            else if (typeof c === 'string') {\n                this[BUFFER][0] = c.slice(n);\n                chunk = c.slice(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n            else {\n                this[BUFFER][0] = c.subarray(n);\n                chunk = c.subarray(0, n);\n                this[BUFFERLENGTH] -= n;\n            }\n        }\n        this.emit('data', chunk);\n        if (!this[BUFFER].length && !this[EOF])\n            this.emit('drain');\n        return chunk;\n    }\n    end(chunk, encoding, cb) {\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = 'utf8';\n        }\n        if (chunk !== undefined)\n            this.write(chunk, encoding);\n        if (cb)\n            this.once('end', cb);\n        this[EOF] = true;\n        this.writable = false;\n        // if we haven't written anything, then go ahead and emit,\n        // even if we're not reading.\n        // we'll re-emit if a new 'end' listener is added anyway.\n        // This makes MP more suitable to write-only use cases.\n        if (this[FLOWING] || !this[PAUSED])\n            this[MAYBE_EMIT_END]();\n        return this;\n    }\n    // don't let the internal resume be overwritten\n    [RESUME]() {\n        if (this[DESTROYED])\n            return;\n        if (!this[DATALISTENERS] && !this[PIPES].length) {\n            this[DISCARDED] = true;\n        }\n        this[PAUSED] = false;\n        this[FLOWING] = true;\n        this.emit('resume');\n        if (this[BUFFER].length)\n            this[FLUSH]();\n        else if (this[EOF])\n            this[MAYBE_EMIT_END]();\n        else\n            this.emit('drain');\n    }\n    /**\n     * Resume the stream if it is currently in a paused state\n     *\n     * If called when there are no pipe destinations or `data` event listeners,\n     * this will place the stream in a \"discarded\" state, where all data will\n     * be thrown away. The discarded state is removed if a pipe destination or\n     * data handler is added, if pause() is called, or if any synchronous or\n     * asynchronous iteration is started.\n     */\n    resume() {\n        return this[RESUME]();\n    }\n    /**\n     * Pause the stream\n     */\n    pause() {\n        this[FLOWING] = false;\n        this[PAUSED] = true;\n        this[DISCARDED] = false;\n    }\n    /**\n     * true if the stream has been forcibly destroyed\n     */\n    get destroyed() {\n        return this[DESTROYED];\n    }\n    /**\n     * true if the stream is currently in a flowing state, meaning that\n     * any writes will be immediately emitted.\n     */\n    get flowing() {\n        return this[FLOWING];\n    }\n    /**\n     * true if the stream is currently in a paused state\n     */\n    get paused() {\n        return this[PAUSED];\n    }\n    [BUFFERPUSH](chunk) {\n        if (this[OBJECTMODE])\n            this[BUFFERLENGTH] += 1;\n        else\n            this[BUFFERLENGTH] += chunk.length;\n        this[BUFFER].push(chunk);\n    }\n    [BUFFERSHIFT]() {\n        if (this[OBJECTMODE])\n            this[BUFFERLENGTH] -= 1;\n        else\n            this[BUFFERLENGTH] -= this[BUFFER][0].length;\n        return this[BUFFER].shift();\n    }\n    [FLUSH](noDrain = false) {\n        do { } while (this[FLUSHCHUNK](this[BUFFERSHIFT]()) &&\n            this[BUFFER].length);\n        if (!noDrain && !this[BUFFER].length && !this[EOF])\n            this.emit('drain');\n    }\n    [FLUSHCHUNK](chunk) {\n        this.emit('data', chunk);\n        return this[FLOWING];\n    }\n    /**\n     * Pipe all data emitted by this stream into the destination provided.\n     *\n     * Triggers the flow of data.\n     */\n    pipe(dest, opts) {\n        if (this[DESTROYED])\n            return dest;\n        this[DISCARDED] = false;\n        const ended = this[EMITTED_END];\n        opts = opts || {};\n        if (dest === proc.stdout || dest === proc.stderr)\n            opts.end = false;\n        else\n            opts.end = opts.end !== false;\n        opts.proxyErrors = !!opts.proxyErrors;\n        // piping an ended stream ends immediately\n        if (ended) {\n            if (opts.end)\n                dest.end();\n        }\n        else {\n            // \"as\" here just ignores the WType, which pipes don't care about,\n            // since they're only consuming from us, and writing to the dest\n            this[PIPES].push(!opts.proxyErrors\n                ? new Pipe(this, dest, opts)\n                : new PipeProxyErrors(this, dest, opts));\n            if (this[ASYNC])\n                defer(() => this[RESUME]());\n            else\n                this[RESUME]();\n        }\n        return dest;\n    }\n    /**\n     * Fully unhook a piped destination stream.\n     *\n     * If the destination stream was the only consumer of this stream (ie,\n     * there are no other piped destinations or `'data'` event listeners)\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */\n    unpipe(dest) {\n        const p = this[PIPES].find(p => p.dest === dest);\n        if (p) {\n            if (this[PIPES].length === 1) {\n                if (this[FLOWING] && this[DATALISTENERS] === 0) {\n                    this[FLOWING] = false;\n                }\n                this[PIPES] = [];\n            }\n            else\n                this[PIPES].splice(this[PIPES].indexOf(p), 1);\n            p.unpipe();\n        }\n    }\n    /**\n     * Alias for {@link Minipass#on}\n     */\n    addListener(ev, handler) {\n        return this.on(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.on`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * - Adding a 'data' event handler will trigger the flow of data\n     *\n     * - Adding a 'readable' event handler when there is data waiting to be read\n     *   will cause 'readable' to be emitted immediately.\n     *\n     * - Adding an 'endish' event handler ('end', 'finish', etc.) which has\n     *   already passed will cause the event to be emitted immediately and all\n     *   handlers removed.\n     *\n     * - Adding an 'error' event handler after an error has been emitted will\n     *   cause the event to be re-emitted immediately with the error previously\n     *   raised.\n     */\n    on(ev, handler) {\n        const ret = super.on(ev, handler);\n        if (ev === 'data') {\n            this[DISCARDED] = false;\n            this[DATALISTENERS]++;\n            if (!this[PIPES].length && !this[FLOWING]) {\n                this[RESUME]();\n            }\n        }\n        else if (ev === 'readable' && this[BUFFERLENGTH] !== 0) {\n            super.emit('readable');\n        }\n        else if (isEndish(ev) && this[EMITTED_END]) {\n            super.emit(ev);\n            this.removeAllListeners(ev);\n        }\n        else if (ev === 'error' && this[EMITTED_ERROR]) {\n            const h = handler;\n            if (this[ASYNC])\n                defer(() => h.call(this, this[EMITTED_ERROR]));\n            else\n                h.call(this, this[EMITTED_ERROR]);\n        }\n        return ret;\n    }\n    /**\n     * Alias for {@link Minipass#off}\n     */\n    removeListener(ev, handler) {\n        return this.off(ev, handler);\n    }\n    /**\n     * Mostly identical to `EventEmitter.off`\n     *\n     * If a 'data' event handler is removed, and it was the last consumer\n     * (ie, there are no pipe destinations or other 'data' event listeners),\n     * then the flow of data will stop until there is another consumer or\n     * {@link Minipass#resume} is explicitly called.\n     */\n    off(ev, handler) {\n        const ret = super.off(ev, handler);\n        // if we previously had listeners, and now we don't, and we don't\n        // have any pipes, then stop the flow, unless it's been explicitly\n        // put in a discarded flowing state via stream.resume().\n        if (ev === 'data') {\n            this[DATALISTENERS] = this.listeners('data').length;\n            if (this[DATALISTENERS] === 0 &&\n                !this[DISCARDED] &&\n                !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * Mostly identical to `EventEmitter.removeAllListeners`\n     *\n     * If all 'data' event handlers are removed, and they were the last consumer\n     * (ie, there are no pipe destinations), then the flow of data will stop\n     * until there is another consumer or {@link Minipass#resume} is explicitly\n     * called.\n     */\n    removeAllListeners(ev) {\n        const ret = super.removeAllListeners(ev);\n        if (ev === 'data' || ev === undefined) {\n            this[DATALISTENERS] = 0;\n            if (!this[DISCARDED] && !this[PIPES].length) {\n                this[FLOWING] = false;\n            }\n        }\n        return ret;\n    }\n    /**\n     * true if the 'end' event has been emitted\n     */\n    get emittedEnd() {\n        return this[EMITTED_END];\n    }\n    [MAYBE_EMIT_END]() {\n        if (!this[EMITTING_END] &&\n            !this[EMITTED_END] &&\n            !this[DESTROYED] &&\n            this[BUFFER].length === 0 &&\n            this[EOF]) {\n            this[EMITTING_END] = true;\n            this.emit('end');\n            this.emit('prefinish');\n            this.emit('finish');\n            if (this[CLOSED])\n                this.emit('close');\n            this[EMITTING_END] = false;\n        }\n    }\n    /**\n     * Mostly identical to `EventEmitter.emit`, with the following\n     * behavior differences to prevent data loss and unnecessary hangs:\n     *\n     * If the stream has been destroyed, and the event is something other\n     * than 'close' or 'error', then `false` is returned and no handlers\n     * are called.\n     *\n     * If the event is 'end', and has already been emitted, then the event\n     * is ignored. If the stream is in a paused or non-flowing state, then\n     * the event will be deferred until data flow resumes. If the stream is\n     * async, then handlers will be called on the next tick rather than\n     * immediately.\n     *\n     * If the event is 'close', and 'end' has not yet been emitted, then\n     * the event will be deferred until after 'end' is emitted.\n     *\n     * If the event is 'error', and an AbortSignal was provided for the stream,\n     * and there are no listeners, then the event is ignored, matching the\n     * behavior of node core streams in the presense of an AbortSignal.\n     *\n     * If the event is 'finish' or 'prefinish', then all listeners will be\n     * removed after emitting the event, to prevent double-firing.\n     */\n    emit(ev, ...args) {\n        const data = args[0];\n        // error and close are only events allowed after calling destroy()\n        if (ev !== 'error' &&\n            ev !== 'close' &&\n            ev !== DESTROYED &&\n            this[DESTROYED]) {\n            return false;\n        }\n        else if (ev === 'data') {\n            return !this[OBJECTMODE] && !data\n                ? false\n                : this[ASYNC]\n                    ? (defer(() => this[EMITDATA](data)), true)\n                    : this[EMITDATA](data);\n        }\n        else if (ev === 'end') {\n            return this[EMITEND]();\n        }\n        else if (ev === 'close') {\n            this[CLOSED] = true;\n            // don't emit close before 'end' and 'finish'\n            if (!this[EMITTED_END] && !this[DESTROYED])\n                return false;\n            const ret = super.emit('close');\n            this.removeAllListeners('close');\n            return ret;\n        }\n        else if (ev === 'error') {\n            this[EMITTED_ERROR] = data;\n            super.emit(ERROR, data);\n            const ret = !this[SIGNAL] || this.listeners('error').length\n                ? super.emit('error', data)\n                : false;\n            this[MAYBE_EMIT_END]();\n            return ret;\n        }\n        else if (ev === 'resume') {\n            const ret = super.emit('resume');\n            this[MAYBE_EMIT_END]();\n            return ret;\n        }\n        else if (ev === 'finish' || ev === 'prefinish') {\n            const ret = super.emit(ev);\n            this.removeAllListeners(ev);\n            return ret;\n        }\n        // Some other unknown event\n        const ret = super.emit(ev, ...args);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITDATA](data) {\n        for (const p of this[PIPES]) {\n            if (p.dest.write(data) === false)\n                this.pause();\n        }\n        const ret = this[DISCARDED] ? false : super.emit('data', data);\n        this[MAYBE_EMIT_END]();\n        return ret;\n    }\n    [EMITEND]() {\n        if (this[EMITTED_END])\n            return false;\n        this[EMITTED_END] = true;\n        this.readable = false;\n        return this[ASYNC]\n            ? (defer(() => this[EMITEND2]()), true)\n            : this[EMITEND2]();\n    }\n    [EMITEND2]() {\n        if (this[DECODER]) {\n            const data = this[DECODER].end();\n            if (data) {\n                for (const p of this[PIPES]) {\n                    p.dest.write(data);\n                }\n                if (!this[DISCARDED])\n                    super.emit('data', data);\n            }\n        }\n        for (const p of this[PIPES]) {\n            p.end();\n        }\n        const ret = super.emit('end');\n        this.removeAllListeners('end');\n        return ret;\n    }\n    /**\n     * Return a Promise that resolves to an array of all emitted data once\n     * the stream ends.\n     */\n    async collect() {\n        const buf = Object.assign([], {\n            dataLength: 0,\n        });\n        if (!this[OBJECTMODE])\n            buf.dataLength = 0;\n        // set the promise first, in case an error is raised\n        // by triggering the flow here.\n        const p = this.promise();\n        this.on('data', c => {\n            buf.push(c);\n            if (!this[OBJECTMODE])\n                buf.dataLength += c.length;\n        });\n        await p;\n        return buf;\n    }\n    /**\n     * Return a Promise that resolves to the concatenation of all emitted data\n     * once the stream ends.\n     *\n     * Not allowed on objectMode streams.\n     */\n    async concat() {\n        if (this[OBJECTMODE]) {\n            throw new Error('cannot concat in objectMode');\n        }\n        const buf = await this.collect();\n        return (this[ENCODING]\n            ? buf.join('')\n            : Buffer.concat(buf, buf.dataLength));\n    }\n    /**\n     * Return a void Promise that resolves once the stream ends.\n     */\n    async promise() {\n        return new Promise((resolve, reject) => {\n            this.on(DESTROYED, () => reject(new Error('stream destroyed')));\n            this.on('error', er => reject(er));\n            this.on('end', () => resolve());\n        });\n    }\n    /**\n     * Asynchronous `for await of` iteration.\n     *\n     * This will continue emitting all chunks until the stream terminates.\n     */\n    [Symbol.asyncIterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = async () => {\n            this.pause();\n            stopped = true;\n            return { value: undefined, done: true };\n        };\n        const next = () => {\n            if (stopped)\n                return stop();\n            const res = this.read();\n            if (res !== null)\n                return Promise.resolve({ done: false, value: res });\n            if (this[EOF])\n                return stop();\n            let resolve;\n            let reject;\n            const onerr = (er) => {\n                this.off('data', ondata);\n                this.off('end', onend);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                reject(er);\n            };\n            const ondata = (value) => {\n                this.off('error', onerr);\n                this.off('end', onend);\n                this.off(DESTROYED, ondestroy);\n                this.pause();\n                resolve({ value, done: !!this[EOF] });\n            };\n            const onend = () => {\n                this.off('error', onerr);\n                this.off('data', ondata);\n                this.off(DESTROYED, ondestroy);\n                stop();\n                resolve({ done: true, value: undefined });\n            };\n            const ondestroy = () => onerr(new Error('stream destroyed'));\n            return new Promise((res, rej) => {\n                reject = rej;\n                resolve = res;\n                this.once(DESTROYED, ondestroy);\n                this.once('error', onerr);\n                this.once('end', onend);\n                this.once('data', ondata);\n            });\n        };\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.asyncIterator]() {\n                return this;\n            },\n        };\n    }\n    /**\n     * Synchronous `for of` iteration.\n     *\n     * The iteration will terminate when the internal buffer runs out, even\n     * if the stream has not yet terminated.\n     */\n    [Symbol.iterator]() {\n        // set this up front, in case the consumer doesn't call next()\n        // right away.\n        this[DISCARDED] = false;\n        let stopped = false;\n        const stop = () => {\n            this.pause();\n            this.off(ERROR, stop);\n            this.off(DESTROYED, stop);\n            this.off('end', stop);\n            stopped = true;\n            return { done: true, value: undefined };\n        };\n        const next = () => {\n            if (stopped)\n                return stop();\n            const value = this.read();\n            return value === null ? stop() : { done: false, value };\n        };\n        this.once('end', stop);\n        this.once(ERROR, stop);\n        this.once(DESTROYED, stop);\n        return {\n            next,\n            throw: stop,\n            return: stop,\n            [Symbol.iterator]() {\n                return this;\n            },\n        };\n    }\n    /**\n     * Destroy a stream, preventing it from being used for any further purpose.\n     *\n     * If the stream has a `close()` method, then it will be called on\n     * destruction.\n     *\n     * After destruction, any attempt to write data, read data, or emit most\n     * events will be ignored.\n     *\n     * If an error argument is provided, then it will be emitted in an\n     * 'error' event.\n     */\n    destroy(er) {\n        if (this[DESTROYED]) {\n            if (er)\n                this.emit('error', er);\n            else\n                this.emit(DESTROYED);\n            return this;\n        }\n        this[DESTROYED] = true;\n        this[DISCARDED] = true;\n        // throw away all buffered data, it's never coming out\n        this[BUFFER].length = 0;\n        this[BUFFERLENGTH] = 0;\n        const wc = this;\n        if (typeof wc.close === 'function' && !this[CLOSED])\n            wc.close();\n        if (er)\n            this.emit('error', er);\n        // if no error to emit, still reject pending promises\n        else\n            this.emit(DESTROYED);\n        return this;\n    }\n    /**\n     * Alias for {@link isStream}\n     *\n     * Former export location, maintained for backwards compatibility.\n     *\n     * @deprecated\n     */\n    static get isStream() {\n        return exports.isStream;\n    }\n}\nexports.Minipass = Minipass;\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.constants = void 0;\n// Update with any zlib constants that are added or changed in the future.\n// Node v6 didn't export this, so we just hard code the version and rely\n// on all the other hard-coded values from zlib v4736.  When node v6\n// support drops, we can just export the realZlibConstants object.\nconst zlib_1 = __importDefault(require(\"zlib\"));\n/* c8 ignore start */\nconst realZlibConstants = zlib_1.default.constants || { ZLIB_VERNUM: 4736 };\n/* c8 ignore stop */\nexports.constants = Object.freeze(Object.assign(Object.create(null), {\n    Z_NO_FLUSH: 0,\n    Z_PARTIAL_FLUSH: 1,\n    Z_SYNC_FLUSH: 2,\n    Z_FULL_FLUSH: 3,\n    Z_FINISH: 4,\n    Z_BLOCK: 5,\n    Z_OK: 0,\n    Z_STREAM_END: 1,\n    Z_NEED_DICT: 2,\n    Z_ERRNO: -1,\n    Z_STREAM_ERROR: -2,\n    Z_DATA_ERROR: -3,\n    Z_MEM_ERROR: -4,\n    Z_BUF_ERROR: -5,\n    Z_VERSION_ERROR: -6,\n    Z_NO_COMPRESSION: 0,\n    Z_BEST_SPEED: 1,\n    Z_BEST_COMPRESSION: 9,\n    Z_DEFAULT_COMPRESSION: -1,\n    Z_FILTERED: 1,\n    Z_HUFFMAN_ONLY: 2,\n    Z_RLE: 3,\n    Z_FIXED: 4,\n    Z_DEFAULT_STRATEGY: 0,\n    DEFLATE: 1,\n    INFLATE: 2,\n    GZIP: 3,\n    GUNZIP: 4,\n    DEFLATERAW: 5,\n    INFLATERAW: 6,\n    UNZIP: 7,\n    BROTLI_DECODE: 8,\n    BROTLI_ENCODE: 9,\n    Z_MIN_WINDOWBITS: 8,\n    Z_MAX_WINDOWBITS: 15,\n    Z_DEFAULT_WINDOWBITS: 15,\n    Z_MIN_CHUNK: 64,\n    Z_MAX_CHUNK: Infinity,\n    Z_DEFAULT_CHUNK: 16384,\n    Z_MIN_MEMLEVEL: 1,\n    Z_MAX_MEMLEVEL: 9,\n    Z_DEFAULT_MEMLEVEL: 8,\n    Z_MIN_LEVEL: -1,\n    Z_MAX_LEVEL: 9,\n    Z_DEFAULT_LEVEL: -1,\n    BROTLI_OPERATION_PROCESS: 0,\n    BROTLI_OPERATION_FLUSH: 1,\n    BROTLI_OPERATION_FINISH: 2,\n    BROTLI_OPERATION_EMIT_METADATA: 3,\n    BROTLI_MODE_GENERIC: 0,\n    BROTLI_MODE_TEXT: 1,\n    BROTLI_MODE_FONT: 2,\n    BROTLI_DEFAULT_MODE: 0,\n    BROTLI_MIN_QUALITY: 0,\n    BROTLI_MAX_QUALITY: 11,\n    BROTLI_DEFAULT_QUALITY: 11,\n    BROTLI_MIN_WINDOW_BITS: 10,\n    BROTLI_MAX_WINDOW_BITS: 24,\n    BROTLI_LARGE_MAX_WINDOW_BITS: 30,\n    BROTLI_DEFAULT_WINDOW: 22,\n    BROTLI_MIN_INPUT_BLOCK_BITS: 16,\n    BROTLI_MAX_INPUT_BLOCK_BITS: 24,\n    BROTLI_PARAM_MODE: 0,\n    BROTLI_PARAM_QUALITY: 1,\n    BROTLI_PARAM_LGWIN: 2,\n    BROTLI_PARAM_LGBLOCK: 3,\n    BROTLI_PARAM_DISABLE_LITERAL_CONTEXT_MODELING: 4,\n    BROTLI_PARAM_SIZE_HINT: 5,\n    BROTLI_PARAM_LARGE_WINDOW: 6,\n    BROTLI_PARAM_NPOSTFIX: 7,\n    BROTLI_PARAM_NDIRECT: 8,\n    BROTLI_DECODER_RESULT_ERROR: 0,\n    BROTLI_DECODER_RESULT_SUCCESS: 1,\n    BROTLI_DECODER_RESULT_NEEDS_MORE_INPUT: 2,\n    BROTLI_DECODER_RESULT_NEEDS_MORE_OUTPUT: 3,\n    BROTLI_DECODER_PARAM_DISABLE_RING_BUFFER_REALLOCATION: 0,\n    BROTLI_DECODER_PARAM_LARGE_WINDOW: 1,\n    BROTLI_DECODER_NO_ERROR: 0,\n    BROTLI_DECODER_SUCCESS: 1,\n    BROTLI_DECODER_NEEDS_MORE_INPUT: 2,\n    BROTLI_DECODER_NEEDS_MORE_OUTPUT: 3,\n    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_NIBBLE: -1,\n    BROTLI_DECODER_ERROR_FORMAT_RESERVED: -2,\n    BROTLI_DECODER_ERROR_FORMAT_EXUBERANT_META_NIBBLE: -3,\n    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_ALPHABET: -4,\n    BROTLI_DECODER_ERROR_FORMAT_SIMPLE_HUFFMAN_SAME: -5,\n    BROTLI_DECODER_ERROR_FORMAT_CL_SPACE: -6,\n    BROTLI_DECODER_ERROR_FORMAT_HUFFMAN_SPACE: -7,\n    BROTLI_DECODER_ERROR_FORMAT_CONTEXT_MAP_REPEAT: -8,\n    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_1: -9,\n    BROTLI_DECODER_ERROR_FORMAT_BLOCK_LENGTH_2: -10,\n    BROTLI_DECODER_ERROR_FORMAT_TRANSFORM: -11,\n    BROTLI_DECODER_ERROR_FORMAT_DICTIONARY: -12,\n    BROTLI_DECODER_ERROR_FORMAT_WINDOW_BITS: -13,\n    BROTLI_DECODER_ERROR_FORMAT_PADDING_1: -14,\n    BROTLI_DECODER_ERROR_FORMAT_PADDING_2: -15,\n    BROTLI_DECODER_ERROR_FORMAT_DISTANCE: -16,\n    BROTLI_DECODER_ERROR_DICTIONARY_NOT_SET: -19,\n    BROTLI_DECODER_ERROR_INVALID_ARGUMENTS: -20,\n    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MODES: -21,\n    BROTLI_DECODER_ERROR_ALLOC_TREE_GROUPS: -22,\n    BROTLI_DECODER_ERROR_ALLOC_CONTEXT_MAP: -25,\n    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_1: -26,\n    BROTLI_DECODER_ERROR_ALLOC_RING_BUFFER_2: -27,\n    BROTLI_DECODER_ERROR_ALLOC_BLOCK_TYPE_TREES: -30,\n    BROTLI_DECODER_ERROR_UNREACHABLE: -31,\n}, realZlibConstants));\n//# sourceMappingURL=constants.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BrotliDecompress = exports.BrotliCompress = exports.Brotli = exports.Unzip = exports.InflateRaw = exports.DeflateRaw = exports.Gunzip = exports.Gzip = exports.Inflate = exports.Deflate = exports.Zlib = exports.ZlibError = exports.constants = void 0;\nconst assert_1 = __importDefault(require(\"assert\"));\nconst buffer_1 = require(\"buffer\");\nconst minipass_1 = require(\"minipass\");\nconst zlib_1 = __importDefault(require(\"zlib\"));\nconst constants_js_1 = require(\"./constants.js\");\nvar constants_js_2 = require(\"./constants.js\");\nObject.defineProperty(exports, \"constants\", { enumerable: true, get: function () { return constants_js_2.constants; } });\nconst OriginalBufferConcat = buffer_1.Buffer.concat;\nconst _superWrite = Symbol('_superWrite');\nclass ZlibError extends Error {\n    code;\n    errno;\n    constructor(err) {\n        super('zlib: ' + err.message);\n        this.code = err.code;\n        this.errno = err.errno;\n        /* c8 ignore next */\n        if (!this.code)\n            this.code = 'ZLIB_ERROR';\n        this.message = 'zlib: ' + err.message;\n        Error.captureStackTrace(this, this.constructor);\n    }\n    get name() {\n        return 'ZlibError';\n    }\n}\nexports.ZlibError = ZlibError;\n// the Zlib class they all inherit from\n// This thing manages the queue of requests, and returns\n// true or false if there is anything in the queue when\n// you call the .write() method.\nconst _flushFlag = Symbol('flushFlag');\nclass ZlibBase extends minipass_1.Minipass {\n    #sawError = false;\n    #ended = false;\n    #flushFlag;\n    #finishFlushFlag;\n    #fullFlushFlag;\n    #handle;\n    #onError;\n    get sawError() {\n        return this.#sawError;\n    }\n    get handle() {\n        return this.#handle;\n    }\n    /* c8 ignore start */\n    get flushFlag() {\n        return this.#flushFlag;\n    }\n    /* c8 ignore stop */\n    constructor(opts, mode) {\n        if (!opts || typeof opts !== 'object')\n            throw new TypeError('invalid options for ZlibBase constructor');\n        //@ts-ignore\n        super(opts);\n        /* c8 ignore start */\n        this.#flushFlag = opts.flush ?? 0;\n        this.#finishFlushFlag = opts.finishFlush ?? 0;\n        this.#fullFlushFlag = opts.fullFlushFlag ?? 0;\n        /* c8 ignore stop */\n        // this will throw if any options are invalid for the class selected\n        try {\n            // @types/node doesn't know that it exports the classes, but they're there\n            //@ts-ignore\n            this.#handle = new zlib_1.default[mode](opts);\n        }\n        catch (er) {\n            // make sure that all errors get decorated properly\n            throw new ZlibError(er);\n        }\n        this.#onError = err => {\n            // no sense raising multiple errors, since we abort on the first one.\n            if (this.#sawError)\n                return;\n            this.#sawError = true;\n            // there is no way to cleanly recover.\n            // continuing only obscures problems.\n            this.close();\n            this.emit('error', err);\n        };\n        this.#handle?.on('error', er => this.#onError(new ZlibError(er)));\n        this.once('end', () => this.close);\n    }\n    close() {\n        if (this.#handle) {\n            this.#handle.close();\n            this.#handle = undefined;\n            this.emit('close');\n        }\n    }\n    reset() {\n        if (!this.#sawError) {\n            (0, assert_1.default)(this.#handle, 'zlib binding closed');\n            //@ts-ignore\n            return this.#handle.reset?.();\n        }\n    }\n    flush(flushFlag) {\n        if (this.ended)\n            return;\n        if (typeof flushFlag !== 'number')\n            flushFlag = this.#fullFlushFlag;\n        this.write(Object.assign(buffer_1.Buffer.alloc(0), { [_flushFlag]: flushFlag }));\n    }\n    end(chunk, encoding, cb) {\n        /* c8 ignore start */\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            encoding = undefined;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        /* c8 ignore stop */\n        if (chunk) {\n            if (encoding)\n                this.write(chunk, encoding);\n            else\n                this.write(chunk);\n        }\n        this.flush(this.#finishFlushFlag);\n        this.#ended = true;\n        return super.end(cb);\n    }\n    get ended() {\n        return this.#ended;\n    }\n    // overridden in the gzip classes to do portable writes\n    [_superWrite](data) {\n        return super.write(data);\n    }\n    write(chunk, encoding, cb) {\n        // process the chunk using the sync process\n        // then super.write() all the outputted chunks\n        if (typeof encoding === 'function')\n            (cb = encoding), (encoding = 'utf8');\n        if (typeof chunk === 'string')\n            chunk = buffer_1.Buffer.from(chunk, encoding);\n        if (this.#sawError)\n            return;\n        (0, assert_1.default)(this.#handle, 'zlib binding closed');\n        // _processChunk tries to .close() the native handle after it's done, so we\n        // intercept that by temporarily making it a no-op.\n        // diving into the node:zlib internals a bit here\n        const nativeHandle = this.#handle\n            ._handle;\n        const originalNativeClose = nativeHandle.close;\n        nativeHandle.close = () => { };\n        const originalClose = this.#handle.close;\n        this.#handle.close = () => { };\n        // It also calls `Buffer.concat()` at the end, which may be convenient\n        // for some, but which we are not interested in as it slows us down.\n        buffer_1.Buffer.concat = args => args;\n        let result = undefined;\n        try {\n            const flushFlag = typeof chunk[_flushFlag] === 'number'\n                ? chunk[_flushFlag]\n                : this.#flushFlag;\n            result = this.#handle._processChunk(chunk, flushFlag);\n            // if we don't throw, reset it back how it was\n            buffer_1.Buffer.concat = OriginalBufferConcat;\n        }\n        catch (err) {\n            // or if we do, put Buffer.concat() back before we emit error\n            // Error events call into user code, which may call Buffer.concat()\n            buffer_1.Buffer.concat = OriginalBufferConcat;\n            this.#onError(new ZlibError(err));\n        }\n        finally {\n            if (this.#handle) {\n                // Core zlib resets `_handle` to null after attempting to close the\n                // native handle. Our no-op handler prevented actual closure, but we\n                // need to restore the `._handle` property.\n                ;\n                this.#handle._handle =\n                    nativeHandle;\n                nativeHandle.close = originalNativeClose;\n                this.#handle.close = originalClose;\n                // `_processChunk()` adds an 'error' listener. If we don't remove it\n                // after each call, these handlers start piling up.\n                this.#handle.removeAllListeners('error');\n                // make sure OUR error listener is still attached tho\n            }\n        }\n        if (this.#handle)\n            this.#handle.on('error', er => this.#onError(new ZlibError(er)));\n        let writeReturn;\n        if (result) {\n            if (Array.isArray(result) && result.length > 0) {\n                const r = result[0];\n                // The first buffer is always `handle._outBuffer`, which would be\n                // re-used for later invocations; so, we always have to copy that one.\n                writeReturn = this[_superWrite](buffer_1.Buffer.from(r));\n                for (let i = 1; i < result.length; i++) {\n                    writeReturn = this[_superWrite](result[i]);\n                }\n            }\n            else {\n                // either a single Buffer or an empty array\n                writeReturn = this[_superWrite](buffer_1.Buffer.from(result));\n            }\n        }\n        if (cb)\n            cb();\n        return writeReturn;\n    }\n}\nclass Zlib extends ZlibBase {\n    #level;\n    #strategy;\n    constructor(opts, mode) {\n        opts = opts || {};\n        opts.flush = opts.flush || constants_js_1.constants.Z_NO_FLUSH;\n        opts.finishFlush = opts.finishFlush || constants_js_1.constants.Z_FINISH;\n        opts.fullFlushFlag = constants_js_1.constants.Z_FULL_FLUSH;\n        super(opts, mode);\n        this.#level = opts.level;\n        this.#strategy = opts.strategy;\n    }\n    params(level, strategy) {\n        if (this.sawError)\n            return;\n        if (!this.handle)\n            throw new Error('cannot switch params when binding is closed');\n        // no way to test this without also not supporting params at all\n        /* c8 ignore start */\n        if (!this.handle.params)\n            throw new Error('not supported in this implementation');\n        /* c8 ignore stop */\n        if (this.#level !== level || this.#strategy !== strategy) {\n            this.flush(constants_js_1.constants.Z_SYNC_FLUSH);\n            (0, assert_1.default)(this.handle, 'zlib binding closed');\n            // .params() calls .flush(), but the latter is always async in the\n            // core zlib. We override .flush() temporarily to intercept that and\n            // flush synchronously.\n            const origFlush = this.handle.flush;\n            this.handle.flush = (flushFlag, cb) => {\n                /* c8 ignore start */\n                if (typeof flushFlag === 'function') {\n                    cb = flushFlag;\n                    flushFlag = this.flushFlag;\n                }\n                /* c8 ignore stop */\n                this.flush(flushFlag);\n                cb?.();\n            };\n            try {\n                ;\n                this.handle.params(level, strategy);\n            }\n            finally {\n                this.handle.flush = origFlush;\n            }\n            /* c8 ignore start */\n            if (this.handle) {\n                this.#level = level;\n                this.#strategy = strategy;\n            }\n            /* c8 ignore stop */\n        }\n    }\n}\nexports.Zlib = Zlib;\n// minimal 2-byte header\nclass Deflate extends Zlib {\n    constructor(opts) {\n        super(opts, 'Deflate');\n    }\n}\nexports.Deflate = Deflate;\nclass Inflate extends Zlib {\n    constructor(opts) {\n        super(opts, 'Inflate');\n    }\n}\nexports.Inflate = Inflate;\nclass Gzip extends Zlib {\n    #portable;\n    constructor(opts) {\n        super(opts, 'Gzip');\n        this.#portable = opts && !!opts.portable;\n    }\n    [_superWrite](data) {\n        if (!this.#portable)\n            return super[_superWrite](data);\n        // we'll always get the header emitted in one first chunk\n        // overwrite the OS indicator byte with 0xFF\n        this.#portable = false;\n        data[9] = 255;\n        return super[_superWrite](data);\n    }\n}\nexports.Gzip = Gzip;\nclass Gunzip extends Zlib {\n    constructor(opts) {\n        super(opts, 'Gunzip');\n    }\n}\nexports.Gunzip = Gunzip;\n// raw - no header\nclass DeflateRaw extends Zlib {\n    constructor(opts) {\n        super(opts, 'DeflateRaw');\n    }\n}\nexports.DeflateRaw = DeflateRaw;\nclass InflateRaw extends Zlib {\n    constructor(opts) {\n        super(opts, 'InflateRaw');\n    }\n}\nexports.InflateRaw = InflateRaw;\n// auto-detect header.\nclass Unzip extends Zlib {\n    constructor(opts) {\n        super(opts, 'Unzip');\n    }\n}\nexports.Unzip = Unzip;\nclass Brotli extends ZlibBase {\n    constructor(opts, mode) {\n        opts = opts || {};\n        opts.flush = opts.flush || constants_js_1.constants.BROTLI_OPERATION_PROCESS;\n        opts.finishFlush =\n            opts.finishFlush || constants_js_1.constants.BROTLI_OPERATION_FINISH;\n        opts.fullFlushFlag = constants_js_1.constants.BROTLI_OPERATION_FLUSH;\n        super(opts, mode);\n    }\n}\nexports.Brotli = Brotli;\nclass BrotliCompress extends Brotli {\n    constructor(opts) {\n        super(opts, 'BrotliCompress');\n    }\n}\nexports.BrotliCompress = BrotliCompress;\nclass BrotliDecompress extends Brotli {\n    constructor(opts) {\n        super(opts, 'BrotliDecompress');\n    }\n}\nexports.BrotliDecompress = BrotliDecompress;\n//# sourceMappingURL=index.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.create = void 0;\nconst fs_minipass_1 = require(\"@isaacs/fs-minipass\");\nconst node_path_1 = __importDefault(require(\"node:path\"));\nconst list_js_1 = require(\"./list.js\");\nconst make_command_js_1 = require(\"./make-command.js\");\nconst pack_js_1 = require(\"./pack.js\");\nconst createFileSync = (opt, files) => {\n    const p = new pack_js_1.PackSync(opt);\n    const stream = new fs_minipass_1.WriteStreamSync(opt.file, {\n        mode: opt.mode || 0o666,\n    });\n    p.pipe(stream);\n    addFilesSync(p, files);\n};\nconst createFile = (opt, files) => {\n    const p = new pack_js_1.Pack(opt);\n    const stream = new fs_minipass_1.WriteStream(opt.file, {\n        mode: opt.mode || 0o666,\n    });\n    p.pipe(stream);\n    const promise = new Promise((res, rej) => {\n        stream.on('error', rej);\n        stream.on('close', res);\n        p.on('error', rej);\n    });\n    addFilesAsync(p, files);\n    return promise;\n};\nconst addFilesSync = (p, files) => {\n    files.forEach(file => {\n        if (file.charAt(0) === '@') {\n            (0, list_js_1.list)({\n                file: node_path_1.default.resolve(p.cwd, file.slice(1)),\n                sync: true,\n                noResume: true,\n                onReadEntry: entry => p.add(entry),\n            });\n        }\n        else {\n            p.add(file);\n        }\n    });\n    p.end();\n};\nconst addFilesAsync = async (p, files) => {\n    for (let i = 0; i < files.length; i++) {\n        const file = String(files[i]);\n        if (file.charAt(0) === '@') {\n            await (0, list_js_1.list)({\n                file: node_path_1.default.resolve(String(p.cwd), file.slice(1)),\n                noResume: true,\n                onReadEntry: entry => {\n                    p.add(entry);\n                },\n            });\n        }\n        else {\n            p.add(file);\n        }\n    }\n    p.end();\n};\nconst createSync = (opt, files) => {\n    const p = new pack_js_1.PackSync(opt);\n    addFilesSync(p, files);\n    return p;\n};\nconst createAsync = (opt, files) => {\n    const p = new pack_js_1.Pack(opt);\n    addFilesAsync(p, files);\n    return p;\n};\nexports.create = (0, make_command_js_1.makeCommand)(createFileSync, createFile, createSync, createAsync, (_opt, files) => {\n    if (!files?.length) {\n        throw new TypeError('no paths specified to add to archive');\n    }\n});\n//# sourceMappingURL=create.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.CwdError = void 0;\nclass CwdError extends Error {\n    path;\n    code;\n    syscall = 'chdir';\n    constructor(path, code) {\n        super(`${code}: Cannot cd into '${path}'`);\n        this.path = path;\n        this.code = code;\n    }\n    get name() {\n        return 'CwdError';\n    }\n}\nexports.CwdError = CwdError;\n//# sourceMappingURL=cwd-error.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.extract = void 0;\n// tar -x\nconst fsm = __importStar(require(\"@isaacs/fs-minipass\"));\nconst node_fs_1 = __importDefault(require(\"node:fs\"));\nconst list_js_1 = require(\"./list.js\");\nconst make_command_js_1 = require(\"./make-command.js\");\nconst unpack_js_1 = require(\"./unpack.js\");\nconst extractFileSync = (opt) => {\n    const u = new unpack_js_1.UnpackSync(opt);\n    const file = opt.file;\n    const stat = node_fs_1.default.statSync(file);\n    // This trades a zero-byte read() syscall for a stat\n    // However, it will usually result in less memory allocation\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024;\n    const stream = new fsm.ReadStreamSync(file, {\n        readSize: readSize,\n        size: stat.size,\n    });\n    stream.pipe(u);\n};\nconst extractFile = (opt, _) => {\n    const u = new unpack_js_1.Unpack(opt);\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024;\n    const file = opt.file;\n    const p = new Promise((resolve, reject) => {\n        u.on('error', reject);\n        u.on('close', resolve);\n        // This trades a zero-byte read() syscall for a stat\n        // However, it will usually result in less memory allocation\n        node_fs_1.default.stat(file, (er, stat) => {\n            if (er) {\n                reject(er);\n            }\n            else {\n                const stream = new fsm.ReadStream(file, {\n                    readSize: readSize,\n                    size: stat.size,\n                });\n                stream.on('error', reject);\n                stream.pipe(u);\n            }\n        });\n    });\n    return p;\n};\nexports.extract = (0, make_command_js_1.makeCommand)(extractFileSync, extractFile, opt => new unpack_js_1.UnpackSync(opt), opt => new unpack_js_1.Unpack(opt), (opt, files) => {\n    if (files?.length)\n        (0, list_js_1.filesFilter)(opt, files);\n});\n//# sourceMappingURL=extract.js.map","\"use strict\";\n// Get the appropriate flag to use for creating files\n// We use fmap on Windows platforms for files less than\n// 512kb.  This is a fairly low limit, but avoids making\n// things slower in some cases.  Since most of what this\n// library is used for is extracting tarballs of many\n// relatively small files in npm packages and the like,\n// it can be a big boost on Windows platforms.\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getWriteFlag = void 0;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst platform = process.env.__FAKE_PLATFORM__ || process.platform;\nconst isWindows = platform === 'win32';\n/* c8 ignore start */\nconst { O_CREAT, O_TRUNC, O_WRONLY } = fs_1.default.constants;\nconst UV_FS_O_FILEMAP = Number(process.env.__FAKE_FS_O_FILENAME__) ||\n    fs_1.default.constants.UV_FS_O_FILEMAP ||\n    0;\n/* c8 ignore stop */\nconst fMapEnabled = isWindows && !!UV_FS_O_FILEMAP;\nconst fMapLimit = 512 * 1024;\nconst fMapFlag = UV_FS_O_FILEMAP | O_TRUNC | O_CREAT | O_WRONLY;\nexports.getWriteFlag = !fMapEnabled ?\n    () => 'w'\n    : (size) => (size < fMapLimit ? fMapFlag : 'w');\n//# sourceMappingURL=get-write-flag.js.map","\"use strict\";\n// parse a 512-byte header block to a data object, or vice-versa\n// encode returns `true` if a pax extended header is needed, because\n// the data could not be faithfully encoded in a simple header.\n// (Also, check header.needPax to see if it needs a pax header.)\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Header = void 0;\nconst node_path_1 = require(\"node:path\");\nconst large = __importStar(require(\"./large-numbers.js\"));\nconst types = __importStar(require(\"./types.js\"));\nclass Header {\n    cksumValid = false;\n    needPax = false;\n    nullBlock = false;\n    block;\n    path;\n    mode;\n    uid;\n    gid;\n    size;\n    cksum;\n    #type = 'Unsupported';\n    linkpath;\n    uname;\n    gname;\n    devmaj = 0;\n    devmin = 0;\n    atime;\n    ctime;\n    mtime;\n    charset;\n    comment;\n    constructor(data, off = 0, ex, gex) {\n        if (Buffer.isBuffer(data)) {\n            this.decode(data, off || 0, ex, gex);\n        }\n        else if (data) {\n            this.#slurp(data);\n        }\n    }\n    decode(buf, off, ex, gex) {\n        if (!off) {\n            off = 0;\n        }\n        if (!buf || !(buf.length >= off + 512)) {\n            throw new Error('need 512 bytes for header');\n        }\n        this.path = decString(buf, off, 100);\n        this.mode = decNumber(buf, off + 100, 8);\n        this.uid = decNumber(buf, off + 108, 8);\n        this.gid = decNumber(buf, off + 116, 8);\n        this.size = decNumber(buf, off + 124, 12);\n        this.mtime = decDate(buf, off + 136, 12);\n        this.cksum = decNumber(buf, off + 148, 12);\n        // if we have extended or global extended headers, apply them now\n        // See https://github.com/npm/node-tar/pull/187\n        // Apply global before local, so it overrides\n        if (gex)\n            this.#slurp(gex, true);\n        if (ex)\n            this.#slurp(ex);\n        // old tar versions marked dirs as a file with a trailing /\n        const t = decString(buf, off + 156, 1);\n        if (types.isCode(t)) {\n            this.#type = t || '0';\n        }\n        if (this.#type === '0' && this.path.slice(-1) === '/') {\n            this.#type = '5';\n        }\n        // tar implementations sometimes incorrectly put the stat(dir).size\n        // as the size in the tarball, even though Directory entries are\n        // not able to have any body at all.  In the very rare chance that\n        // it actually DOES have a body, we weren't going to do anything with\n        // it anyway, and it'll just be a warning about an invalid header.\n        if (this.#type === '5') {\n            this.size = 0;\n        }\n        this.linkpath = decString(buf, off + 157, 100);\n        if (buf.subarray(off + 257, off + 265).toString() ===\n            'ustar\\u000000') {\n            this.uname = decString(buf, off + 265, 32);\n            this.gname = decString(buf, off + 297, 32);\n            /* c8 ignore start */\n            this.devmaj = decNumber(buf, off + 329, 8) ?? 0;\n            this.devmin = decNumber(buf, off + 337, 8) ?? 0;\n            /* c8 ignore stop */\n            if (buf[off + 475] !== 0) {\n                // definitely a prefix, definitely >130 chars.\n                const prefix = decString(buf, off + 345, 155);\n                this.path = prefix + '/' + this.path;\n            }\n            else {\n                const prefix = decString(buf, off + 345, 130);\n                if (prefix) {\n                    this.path = prefix + '/' + this.path;\n                }\n                this.atime = decDate(buf, off + 476, 12);\n                this.ctime = decDate(buf, off + 488, 12);\n            }\n        }\n        let sum = 8 * 0x20;\n        for (let i = off; i < off + 148; i++) {\n            sum += buf[i];\n        }\n        for (let i = off + 156; i < off + 512; i++) {\n            sum += buf[i];\n        }\n        this.cksumValid = sum === this.cksum;\n        if (this.cksum === undefined && sum === 8 * 0x20) {\n            this.nullBlock = true;\n        }\n    }\n    #slurp(ex, gex = false) {\n        Object.assign(this, Object.fromEntries(Object.entries(ex).filter(([k, v]) => {\n            // we slurp in everything except for the path attribute in\n            // a global extended header, because that's weird. Also, any\n            // null/undefined values are ignored.\n            return !(v === null ||\n                v === undefined ||\n                (k === 'path' && gex) ||\n                (k === 'linkpath' && gex) ||\n                k === 'global');\n        })));\n    }\n    encode(buf, off = 0) {\n        if (!buf) {\n            buf = this.block = Buffer.alloc(512);\n        }\n        if (this.#type === 'Unsupported') {\n            this.#type = '0';\n        }\n        if (!(buf.length >= off + 512)) {\n            throw new Error('need 512 bytes for header');\n        }\n        const prefixSize = this.ctime || this.atime ? 130 : 155;\n        const split = splitPrefix(this.path || '', prefixSize);\n        const path = split[0];\n        const prefix = split[1];\n        this.needPax = !!split[2];\n        this.needPax = encString(buf, off, 100, path) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 100, 8, this.mode) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 108, 8, this.uid) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 116, 8, this.gid) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 124, 12, this.size) || this.needPax;\n        this.needPax =\n            encDate(buf, off + 136, 12, this.mtime) || this.needPax;\n        buf[off + 156] = this.#type.charCodeAt(0);\n        this.needPax =\n            encString(buf, off + 157, 100, this.linkpath) || this.needPax;\n        buf.write('ustar\\u000000', off + 257, 8);\n        this.needPax =\n            encString(buf, off + 265, 32, this.uname) || this.needPax;\n        this.needPax =\n            encString(buf, off + 297, 32, this.gname) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 329, 8, this.devmaj) || this.needPax;\n        this.needPax =\n            encNumber(buf, off + 337, 8, this.devmin) || this.needPax;\n        this.needPax =\n            encString(buf, off + 345, prefixSize, prefix) || this.needPax;\n        if (buf[off + 475] !== 0) {\n            this.needPax =\n                encString(buf, off + 345, 155, prefix) || this.needPax;\n        }\n        else {\n            this.needPax =\n                encString(buf, off + 345, 130, prefix) || this.needPax;\n            this.needPax =\n                encDate(buf, off + 476, 12, this.atime) || this.needPax;\n            this.needPax =\n                encDate(buf, off + 488, 12, this.ctime) || this.needPax;\n        }\n        let sum = 8 * 0x20;\n        for (let i = off; i < off + 148; i++) {\n            sum += buf[i];\n        }\n        for (let i = off + 156; i < off + 512; i++) {\n            sum += buf[i];\n        }\n        this.cksum = sum;\n        encNumber(buf, off + 148, 8, this.cksum);\n        this.cksumValid = true;\n        return this.needPax;\n    }\n    get type() {\n        return (this.#type === 'Unsupported' ?\n            this.#type\n            : types.name.get(this.#type));\n    }\n    get typeKey() {\n        return this.#type;\n    }\n    set type(type) {\n        const c = String(types.code.get(type));\n        if (types.isCode(c) || c === 'Unsupported') {\n            this.#type = c;\n        }\n        else if (types.isCode(type)) {\n            this.#type = type;\n        }\n        else {\n            throw new TypeError('invalid entry type: ' + type);\n        }\n    }\n}\nexports.Header = Header;\nconst splitPrefix = (p, prefixSize) => {\n    const pathSize = 100;\n    let pp = p;\n    let prefix = '';\n    let ret = undefined;\n    const root = node_path_1.posix.parse(p).root || '.';\n    if (Buffer.byteLength(pp) < pathSize) {\n        ret = [pp, prefix, false];\n    }\n    else {\n        // first set prefix to the dir, and path to the base\n        prefix = node_path_1.posix.dirname(pp);\n        pp = node_path_1.posix.basename(pp);\n        do {\n            if (Buffer.byteLength(pp) <= pathSize &&\n                Buffer.byteLength(prefix) <= prefixSize) {\n                // both fit!\n                ret = [pp, prefix, false];\n            }\n            else if (Buffer.byteLength(pp) > pathSize &&\n                Buffer.byteLength(prefix) <= prefixSize) {\n                // prefix fits in prefix, but path doesn't fit in path\n                ret = [pp.slice(0, pathSize - 1), prefix, true];\n            }\n            else {\n                // make path take a bit from prefix\n                pp = node_path_1.posix.join(node_path_1.posix.basename(prefix), pp);\n                prefix = node_path_1.posix.dirname(prefix);\n            }\n        } while (prefix !== root && ret === undefined);\n        // at this point, found no resolution, just truncate\n        if (!ret) {\n            ret = [p.slice(0, pathSize - 1), '', true];\n        }\n    }\n    return ret;\n};\nconst decString = (buf, off, size) => buf\n    .subarray(off, off + size)\n    .toString('utf8')\n    .replace(/\\0.*/, '');\nconst decDate = (buf, off, size) => numToDate(decNumber(buf, off, size));\nconst numToDate = (num) => num === undefined ? undefined : new Date(num * 1000);\nconst decNumber = (buf, off, size) => Number(buf[off]) & 0x80 ?\n    large.parse(buf.subarray(off, off + size))\n    : decSmallNumber(buf, off, size);\nconst nanUndef = (value) => (isNaN(value) ? undefined : value);\nconst decSmallNumber = (buf, off, size) => nanUndef(parseInt(buf\n    .subarray(off, off + size)\n    .toString('utf8')\n    .replace(/\\0.*$/, '')\n    .trim(), 8));\n// the maximum encodable as a null-terminated octal, by field size\nconst MAXNUM = {\n    12: 0o77777777777,\n    8: 0o7777777,\n};\nconst encNumber = (buf, off, size, num) => num === undefined ? false\n    : num > MAXNUM[size] || num < 0 ?\n        (large.encode(num, buf.subarray(off, off + size)), true)\n        : (encSmallNumber(buf, off, size, num), false);\nconst encSmallNumber = (buf, off, size, num) => buf.write(octalString(num, size), off, size, 'ascii');\nconst octalString = (num, size) => padOctal(Math.floor(num).toString(8), size);\nconst padOctal = (str, size) => (str.length === size - 1 ?\n    str\n    : new Array(size - str.length - 1).join('0') + str + ' ') + '\\0';\nconst encDate = (buf, off, size, date) => date === undefined ? false : (encNumber(buf, off, size, date.getTime() / 1000));\n// enough to fill the longest string we've got\nconst NULLS = new Array(156).join('\\0');\n// pad with nulls, return true if it's longer or non-ascii\nconst encString = (buf, off, size, str) => str === undefined ? false : ((buf.write(str + NULLS, off, size, 'utf8'),\n    str.length !== Buffer.byteLength(str) || str.length > size));\n//# sourceMappingURL=header.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.u = exports.types = exports.r = exports.t = exports.x = exports.c = void 0;\n__exportStar(require(\"./create.js\"), exports);\nvar create_js_1 = require(\"./create.js\");\nObject.defineProperty(exports, \"c\", { enumerable: true, get: function () { return create_js_1.create; } });\n__exportStar(require(\"./extract.js\"), exports);\nvar extract_js_1 = require(\"./extract.js\");\nObject.defineProperty(exports, \"x\", { enumerable: true, get: function () { return extract_js_1.extract; } });\n__exportStar(require(\"./header.js\"), exports);\n__exportStar(require(\"./list.js\"), exports);\nvar list_js_1 = require(\"./list.js\");\nObject.defineProperty(exports, \"t\", { enumerable: true, get: function () { return list_js_1.list; } });\n// classes\n__exportStar(require(\"./pack.js\"), exports);\n__exportStar(require(\"./parse.js\"), exports);\n__exportStar(require(\"./pax.js\"), exports);\n__exportStar(require(\"./read-entry.js\"), exports);\n__exportStar(require(\"./replace.js\"), exports);\nvar replace_js_1 = require(\"./replace.js\");\nObject.defineProperty(exports, \"r\", { enumerable: true, get: function () { return replace_js_1.replace; } });\nexports.types = __importStar(require(\"./types.js\"));\n__exportStar(require(\"./unpack.js\"), exports);\n__exportStar(require(\"./update.js\"), exports);\nvar update_js_1 = require(\"./update.js\");\nObject.defineProperty(exports, \"u\", { enumerable: true, get: function () { return update_js_1.update; } });\n__exportStar(require(\"./write-entry.js\"), exports);\n//# sourceMappingURL=index.js.map","\"use strict\";\n// Tar can encode large and negative numbers using a leading byte of\n// 0xff for negative, and 0x80 for positive.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.parse = exports.encode = void 0;\nconst encode = (num, buf) => {\n    if (!Number.isSafeInteger(num)) {\n        // The number is so large that javascript cannot represent it with integer\n        // precision.\n        throw Error('cannot encode number outside of javascript safe integer range');\n    }\n    else if (num < 0) {\n        encodeNegative(num, buf);\n    }\n    else {\n        encodePositive(num, buf);\n    }\n    return buf;\n};\nexports.encode = encode;\nconst encodePositive = (num, buf) => {\n    buf[0] = 0x80;\n    for (var i = buf.length; i > 1; i--) {\n        buf[i - 1] = num & 0xff;\n        num = Math.floor(num / 0x100);\n    }\n};\nconst encodeNegative = (num, buf) => {\n    buf[0] = 0xff;\n    var flipped = false;\n    num = num * -1;\n    for (var i = buf.length; i > 1; i--) {\n        var byte = num & 0xff;\n        num = Math.floor(num / 0x100);\n        if (flipped) {\n            buf[i - 1] = onesComp(byte);\n        }\n        else if (byte === 0) {\n            buf[i - 1] = 0;\n        }\n        else {\n            flipped = true;\n            buf[i - 1] = twosComp(byte);\n        }\n    }\n};\nconst parse = (buf) => {\n    const pre = buf[0];\n    const value = pre === 0x80 ? pos(buf.subarray(1, buf.length))\n        : pre === 0xff ? twos(buf)\n            : null;\n    if (value === null) {\n        throw Error('invalid base256 encoding');\n    }\n    if (!Number.isSafeInteger(value)) {\n        // The number is so large that javascript cannot represent it with integer\n        // precision.\n        throw Error('parsed number outside of javascript safe integer range');\n    }\n    return value;\n};\nexports.parse = parse;\nconst twos = (buf) => {\n    var len = buf.length;\n    var sum = 0;\n    var flipped = false;\n    for (var i = len - 1; i > -1; i--) {\n        var byte = Number(buf[i]);\n        var f;\n        if (flipped) {\n            f = onesComp(byte);\n        }\n        else if (byte === 0) {\n            f = byte;\n        }\n        else {\n            flipped = true;\n            f = twosComp(byte);\n        }\n        if (f !== 0) {\n            sum -= f * Math.pow(256, len - i - 1);\n        }\n    }\n    return sum;\n};\nconst pos = (buf) => {\n    var len = buf.length;\n    var sum = 0;\n    for (var i = len - 1; i > -1; i--) {\n        var byte = Number(buf[i]);\n        if (byte !== 0) {\n            sum += byte * Math.pow(256, len - i - 1);\n        }\n    }\n    return sum;\n};\nconst onesComp = (byte) => (0xff ^ byte) & 0xff;\nconst twosComp = (byte) => ((0xff ^ byte) + 1) & 0xff;\n//# sourceMappingURL=large-numbers.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.list = exports.filesFilter = void 0;\n// tar -t\nconst fsm = __importStar(require(\"@isaacs/fs-minipass\"));\nconst node_fs_1 = __importDefault(require(\"node:fs\"));\nconst path_1 = require(\"path\");\nconst make_command_js_1 = require(\"./make-command.js\");\nconst parse_js_1 = require(\"./parse.js\");\nconst strip_trailing_slashes_js_1 = require(\"./strip-trailing-slashes.js\");\nconst onReadEntryFunction = (opt) => {\n    const onReadEntry = opt.onReadEntry;\n    opt.onReadEntry =\n        onReadEntry ?\n            e => {\n                onReadEntry(e);\n                e.resume();\n            }\n            : e => e.resume();\n};\n// construct a filter that limits the file entries listed\n// include child entries if a dir is included\nconst filesFilter = (opt, files) => {\n    const map = new Map(files.map(f => [(0, strip_trailing_slashes_js_1.stripTrailingSlashes)(f), true]));\n    const filter = opt.filter;\n    const mapHas = (file, r = '') => {\n        const root = r || (0, path_1.parse)(file).root || '.';\n        let ret;\n        if (file === root)\n            ret = false;\n        else {\n            const m = map.get(file);\n            if (m !== undefined) {\n                ret = m;\n            }\n            else {\n                ret = mapHas((0, path_1.dirname)(file), root);\n            }\n        }\n        map.set(file, ret);\n        return ret;\n    };\n    opt.filter =\n        filter ?\n            (file, entry) => filter(file, entry) && mapHas((0, strip_trailing_slashes_js_1.stripTrailingSlashes)(file))\n            : file => mapHas((0, strip_trailing_slashes_js_1.stripTrailingSlashes)(file));\n};\nexports.filesFilter = filesFilter;\nconst listFileSync = (opt) => {\n    const p = new parse_js_1.Parser(opt);\n    const file = opt.file;\n    let fd;\n    try {\n        const stat = node_fs_1.default.statSync(file);\n        const readSize = opt.maxReadSize || 16 * 1024 * 1024;\n        if (stat.size < readSize) {\n            p.end(node_fs_1.default.readFileSync(file));\n        }\n        else {\n            let pos = 0;\n            const buf = Buffer.allocUnsafe(readSize);\n            fd = node_fs_1.default.openSync(file, 'r');\n            while (pos < stat.size) {\n                const bytesRead = node_fs_1.default.readSync(fd, buf, 0, readSize, pos);\n                pos += bytesRead;\n                p.write(buf.subarray(0, bytesRead));\n            }\n            p.end();\n        }\n    }\n    finally {\n        if (typeof fd === 'number') {\n            try {\n                node_fs_1.default.closeSync(fd);\n                /* c8 ignore next */\n            }\n            catch (er) { }\n        }\n    }\n};\nconst listFile = (opt, _files) => {\n    const parse = new parse_js_1.Parser(opt);\n    const readSize = opt.maxReadSize || 16 * 1024 * 1024;\n    const file = opt.file;\n    const p = new Promise((resolve, reject) => {\n        parse.on('error', reject);\n        parse.on('end', resolve);\n        node_fs_1.default.stat(file, (er, stat) => {\n            if (er) {\n                reject(er);\n            }\n            else {\n                const stream = new fsm.ReadStream(file, {\n                    readSize: readSize,\n                    size: stat.size,\n                });\n                stream.on('error', reject);\n                stream.pipe(parse);\n            }\n        });\n    });\n    return p;\n};\nexports.list = (0, make_command_js_1.makeCommand)(listFileSync, listFile, opt => new parse_js_1.Parser(opt), opt => new parse_js_1.Parser(opt), (opt, files) => {\n    if (files?.length)\n        (0, exports.filesFilter)(opt, files);\n    if (!opt.noResume)\n        onReadEntryFunction(opt);\n});\n//# sourceMappingURL=list.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.makeCommand = void 0;\nconst options_js_1 = require(\"./options.js\");\nconst makeCommand = (syncFile, asyncFile, syncNoFile, asyncNoFile, validate) => {\n    return Object.assign((opt_ = [], entries, cb) => {\n        if (Array.isArray(opt_)) {\n            entries = opt_;\n            opt_ = {};\n        }\n        if (typeof entries === 'function') {\n            cb = entries;\n            entries = undefined;\n        }\n        if (!entries) {\n            entries = [];\n        }\n        else {\n            entries = Array.from(entries);\n        }\n        const opt = (0, options_js_1.dealias)(opt_);\n        validate?.(opt, entries);\n        if ((0, options_js_1.isSyncFile)(opt)) {\n            if (typeof cb === 'function') {\n                throw new TypeError('callback not supported for sync tar functions');\n            }\n            return syncFile(opt, entries);\n        }\n        else if ((0, options_js_1.isAsyncFile)(opt)) {\n            const p = asyncFile(opt, entries);\n            // weirdness to make TS happy\n            const c = cb ? cb : undefined;\n            return c ? p.then(() => c(), c) : p;\n        }\n        else if ((0, options_js_1.isSyncNoFile)(opt)) {\n            if (typeof cb === 'function') {\n                throw new TypeError('callback not supported for sync tar functions');\n            }\n            return syncNoFile(opt, entries);\n        }\n        else if ((0, options_js_1.isAsyncNoFile)(opt)) {\n            if (typeof cb === 'function') {\n                throw new TypeError('callback only supported with file option');\n            }\n            return asyncNoFile(opt, entries);\n            /* c8 ignore start */\n        }\n        else {\n            throw new Error('impossible options??');\n        }\n        /* c8 ignore stop */\n    }, {\n        syncFile,\n        asyncFile,\n        syncNoFile,\n        asyncNoFile,\n        validate,\n    });\n};\nexports.makeCommand = makeCommand;\n//# sourceMappingURL=make-command.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.mkdirSync = exports.mkdir = void 0;\nconst chownr_1 = require(\"chownr\");\nconst fs_1 = __importDefault(require(\"fs\"));\nconst mkdirp_1 = require(\"mkdirp\");\nconst node_path_1 = __importDefault(require(\"node:path\"));\nconst cwd_error_js_1 = require(\"./cwd-error.js\");\nconst normalize_windows_path_js_1 = require(\"./normalize-windows-path.js\");\nconst symlink_error_js_1 = require(\"./symlink-error.js\");\nconst cGet = (cache, key) => cache.get((0, normalize_windows_path_js_1.normalizeWindowsPath)(key));\nconst cSet = (cache, key, val) => cache.set((0, normalize_windows_path_js_1.normalizeWindowsPath)(key), val);\nconst checkCwd = (dir, cb) => {\n    fs_1.default.stat(dir, (er, st) => {\n        if (er || !st.isDirectory()) {\n            er = new cwd_error_js_1.CwdError(dir, er?.code || 'ENOTDIR');\n        }\n        cb(er);\n    });\n};\n/**\n * Wrapper around mkdirp for tar's needs.\n *\n * The main purpose is to avoid creating directories if we know that\n * they already exist (and track which ones exist for this purpose),\n * and prevent entries from being extracted into symlinked folders,\n * if `preservePaths` is not set.\n */\nconst mkdir = (dir, opt, cb) => {\n    dir = (0, normalize_windows_path_js_1.normalizeWindowsPath)(dir);\n    // if there's any overlap between mask and mode,\n    // then we'll need an explicit chmod\n    /* c8 ignore next */\n    const umask = opt.umask ?? 0o22;\n    const mode = opt.mode | 0o0700;\n    const needChmod = (mode & umask) !== 0;\n    const uid = opt.uid;\n    const gid = opt.gid;\n    const doChown = typeof uid === 'number' &&\n        typeof gid === 'number' &&\n        (uid !== opt.processUid || gid !== opt.processGid);\n    const preserve = opt.preserve;\n    const unlink = opt.unlink;\n    const cache = opt.cache;\n    const cwd = (0, normalize_windows_path_js_1.normalizeWindowsPath)(opt.cwd);\n    const done = (er, created) => {\n        if (er) {\n            cb(er);\n        }\n        else {\n            cSet(cache, dir, true);\n            if (created && doChown) {\n                (0, chownr_1.chownr)(created, uid, gid, er => done(er));\n            }\n            else if (needChmod) {\n                fs_1.default.chmod(dir, mode, cb);\n            }\n            else {\n                cb();\n            }\n        }\n    };\n    if (cache && cGet(cache, dir) === true) {\n        return done();\n    }\n    if (dir === cwd) {\n        return checkCwd(dir, done);\n    }\n    if (preserve) {\n        return (0, mkdirp_1.mkdirp)(dir, { mode }).then(made => done(null, made ?? undefined), // oh, ts\n        done);\n    }\n    const sub = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.relative(cwd, dir));\n    const parts = sub.split('/');\n    mkdir_(cwd, parts, mode, cache, unlink, cwd, undefined, done);\n};\nexports.mkdir = mkdir;\nconst mkdir_ = (base, parts, mode, cache, unlink, cwd, created, cb) => {\n    if (!parts.length) {\n        return cb(null, created);\n    }\n    const p = parts.shift();\n    const part = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.resolve(base + '/' + p));\n    if (cGet(cache, part)) {\n        return mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n    }\n    fs_1.default.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n};\nconst onmkdir = (part, parts, mode, cache, unlink, cwd, created, cb) => (er) => {\n    if (er) {\n        fs_1.default.lstat(part, (statEr, st) => {\n            if (statEr) {\n                statEr.path =\n                    statEr.path && (0, normalize_windows_path_js_1.normalizeWindowsPath)(statEr.path);\n                cb(statEr);\n            }\n            else if (st.isDirectory()) {\n                mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n            }\n            else if (unlink) {\n                fs_1.default.unlink(part, er => {\n                    if (er) {\n                        return cb(er);\n                    }\n                    fs_1.default.mkdir(part, mode, onmkdir(part, parts, mode, cache, unlink, cwd, created, cb));\n                });\n            }\n            else if (st.isSymbolicLink()) {\n                return cb(new symlink_error_js_1.SymlinkError(part, part + '/' + parts.join('/')));\n            }\n            else {\n                cb(er);\n            }\n        });\n    }\n    else {\n        created = created || part;\n        mkdir_(part, parts, mode, cache, unlink, cwd, created, cb);\n    }\n};\nconst checkCwdSync = (dir) => {\n    let ok = false;\n    let code = undefined;\n    try {\n        ok = fs_1.default.statSync(dir).isDirectory();\n    }\n    catch (er) {\n        code = er?.code;\n    }\n    finally {\n        if (!ok) {\n            throw new cwd_error_js_1.CwdError(dir, code ?? 'ENOTDIR');\n        }\n    }\n};\nconst mkdirSync = (dir, opt) => {\n    dir = (0, normalize_windows_path_js_1.normalizeWindowsPath)(dir);\n    // if there's any overlap between mask and mode,\n    // then we'll need an explicit chmod\n    /* c8 ignore next */\n    const umask = opt.umask ?? 0o22;\n    const mode = opt.mode | 0o700;\n    const needChmod = (mode & umask) !== 0;\n    const uid = opt.uid;\n    const gid = opt.gid;\n    const doChown = typeof uid === 'number' &&\n        typeof gid === 'number' &&\n        (uid !== opt.processUid || gid !== opt.processGid);\n    const preserve = opt.preserve;\n    const unlink = opt.unlink;\n    const cache = opt.cache;\n    const cwd = (0, normalize_windows_path_js_1.normalizeWindowsPath)(opt.cwd);\n    const done = (created) => {\n        cSet(cache, dir, true);\n        if (created && doChown) {\n            (0, chownr_1.chownrSync)(created, uid, gid);\n        }\n        if (needChmod) {\n            fs_1.default.chmodSync(dir, mode);\n        }\n    };\n    if (cache && cGet(cache, dir) === true) {\n        return done();\n    }\n    if (dir === cwd) {\n        checkCwdSync(cwd);\n        return done();\n    }\n    if (preserve) {\n        return done((0, mkdirp_1.mkdirpSync)(dir, mode) ?? undefined);\n    }\n    const sub = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.relative(cwd, dir));\n    const parts = sub.split('/');\n    let created = undefined;\n    for (let p = parts.shift(), part = cwd; p && (part += '/' + p); p = parts.shift()) {\n        part = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.resolve(part));\n        if (cGet(cache, part)) {\n            continue;\n        }\n        try {\n            fs_1.default.mkdirSync(part, mode);\n            created = created || part;\n            cSet(cache, part, true);\n        }\n        catch (er) {\n            const st = fs_1.default.lstatSync(part);\n            if (st.isDirectory()) {\n                cSet(cache, part, true);\n                continue;\n            }\n            else if (unlink) {\n                fs_1.default.unlinkSync(part);\n                fs_1.default.mkdirSync(part, mode);\n                created = created || part;\n                cSet(cache, part, true);\n                continue;\n            }\n            else if (st.isSymbolicLink()) {\n                return new symlink_error_js_1.SymlinkError(part, part + '/' + parts.join('/'));\n            }\n        }\n    }\n    return done(created);\n};\nexports.mkdirSync = mkdirSync;\n//# sourceMappingURL=mkdir.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.modeFix = void 0;\nconst modeFix = (mode, isDir, portable) => {\n    mode &= 0o7777;\n    // in portable mode, use the minimum reasonable umask\n    // if this system creates files with 0o664 by default\n    // (as some linux distros do), then we'll write the\n    // archive with 0o644 instead.  Also, don't ever create\n    // a file that is not readable/writable by the owner.\n    if (portable) {\n        mode = (mode | 0o600) & ~0o22;\n    }\n    // if dirs are readable, then they should be listable\n    if (isDir) {\n        if (mode & 0o400) {\n            mode |= 0o100;\n        }\n        if (mode & 0o40) {\n            mode |= 0o10;\n        }\n        if (mode & 0o4) {\n            mode |= 0o1;\n        }\n    }\n    return mode;\n};\nexports.modeFix = modeFix;\n//# sourceMappingURL=mode-fix.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.normalizeUnicode = void 0;\n// warning: extremely hot code path.\n// This has been meticulously optimized for use\n// within npm install on large package trees.\n// Do not edit without careful benchmarking.\nconst normalizeCache = Object.create(null);\nconst { hasOwnProperty } = Object.prototype;\nconst normalizeUnicode = (s) => {\n    if (!hasOwnProperty.call(normalizeCache, s)) {\n        normalizeCache[s] = s.normalize('NFD');\n    }\n    return normalizeCache[s];\n};\nexports.normalizeUnicode = normalizeUnicode;\n//# sourceMappingURL=normalize-unicode.js.map","\"use strict\";\n// on windows, either \\ or / are valid directory separators.\n// on unix, \\ is a valid character in filenames.\n// so, on windows, and only on windows, we replace all \\ chars with /,\n// so that we can use / as our one and only directory separator char.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.normalizeWindowsPath = void 0;\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nexports.normalizeWindowsPath = platform !== 'win32' ?\n    (p) => p\n    : (p) => p && p.replace(/\\\\/g, '/');\n//# sourceMappingURL=normalize-windows-path.js.map","\"use strict\";\n// turn tar(1) style args like `C` into the more verbose things like `cwd`\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.dealias = exports.isNoFile = exports.isFile = exports.isAsync = exports.isSync = exports.isAsyncNoFile = exports.isSyncNoFile = exports.isAsyncFile = exports.isSyncFile = void 0;\nconst argmap = new Map([\n    ['C', 'cwd'],\n    ['f', 'file'],\n    ['z', 'gzip'],\n    ['P', 'preservePaths'],\n    ['U', 'unlink'],\n    ['strip-components', 'strip'],\n    ['stripComponents', 'strip'],\n    ['keep-newer', 'newer'],\n    ['keepNewer', 'newer'],\n    ['keep-newer-files', 'newer'],\n    ['keepNewerFiles', 'newer'],\n    ['k', 'keep'],\n    ['keep-existing', 'keep'],\n    ['keepExisting', 'keep'],\n    ['m', 'noMtime'],\n    ['no-mtime', 'noMtime'],\n    ['p', 'preserveOwner'],\n    ['L', 'follow'],\n    ['h', 'follow'],\n    ['onentry', 'onReadEntry'],\n]);\nconst isSyncFile = (o) => !!o.sync && !!o.file;\nexports.isSyncFile = isSyncFile;\nconst isAsyncFile = (o) => !o.sync && !!o.file;\nexports.isAsyncFile = isAsyncFile;\nconst isSyncNoFile = (o) => !!o.sync && !o.file;\nexports.isSyncNoFile = isSyncNoFile;\nconst isAsyncNoFile = (o) => !o.sync && !o.file;\nexports.isAsyncNoFile = isAsyncNoFile;\nconst isSync = (o) => !!o.sync;\nexports.isSync = isSync;\nconst isAsync = (o) => !o.sync;\nexports.isAsync = isAsync;\nconst isFile = (o) => !!o.file;\nexports.isFile = isFile;\nconst isNoFile = (o) => !o.file;\nexports.isNoFile = isNoFile;\nconst dealiasKey = (k) => {\n    const d = argmap.get(k);\n    if (d)\n        return d;\n    return k;\n};\nconst dealias = (opt = {}) => {\n    if (!opt)\n        return {};\n    const result = {};\n    for (const [key, v] of Object.entries(opt)) {\n        // TS doesn't know that aliases are going to always be the same type\n        const k = dealiasKey(key);\n        result[k] = v;\n    }\n    // affordance for deprecated noChmod -> chmod\n    if (result.chmod === undefined && result.noChmod === false) {\n        result.chmod = true;\n    }\n    delete result.noChmod;\n    return result;\n};\nexports.dealias = dealias;\n//# sourceMappingURL=options.js.map","\"use strict\";\n// A readable tar stream creator\n// Technically, this is a transform stream that you write paths into,\n// and tar format comes out of.\n// The `add()` method is like `write()` but returns this,\n// and end() return `this` as well, so you can\n// do `new Pack(opt).add('files').add('dir').end().pipe(output)\n// You could also do something like:\n// streamOfPaths().pipe(new Pack()).pipe(new fs.WriteStream('out.tar'))\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PackSync = exports.Pack = exports.PackJob = void 0;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst write_entry_js_1 = require(\"./write-entry.js\");\nclass PackJob {\n    path;\n    absolute;\n    entry;\n    stat;\n    readdir;\n    pending = false;\n    ignore = false;\n    piped = false;\n    constructor(path, absolute) {\n        this.path = path || './';\n        this.absolute = absolute;\n    }\n}\nexports.PackJob = PackJob;\nconst minipass_1 = require(\"minipass\");\nconst zlib = __importStar(require(\"minizlib\"));\nconst yallist_1 = require(\"yallist\");\nconst read_entry_js_1 = require(\"./read-entry.js\");\nconst warn_method_js_1 = require(\"./warn-method.js\");\nconst EOF = Buffer.alloc(1024);\nconst ONSTAT = Symbol('onStat');\nconst ENDED = Symbol('ended');\nconst QUEUE = Symbol('queue');\nconst CURRENT = Symbol('current');\nconst PROCESS = Symbol('process');\nconst PROCESSING = Symbol('processing');\nconst PROCESSJOB = Symbol('processJob');\nconst JOBS = Symbol('jobs');\nconst JOBDONE = Symbol('jobDone');\nconst ADDFSENTRY = Symbol('addFSEntry');\nconst ADDTARENTRY = Symbol('addTarEntry');\nconst STAT = Symbol('stat');\nconst READDIR = Symbol('readdir');\nconst ONREADDIR = Symbol('onreaddir');\nconst PIPE = Symbol('pipe');\nconst ENTRY = Symbol('entry');\nconst ENTRYOPT = Symbol('entryOpt');\nconst WRITEENTRYCLASS = Symbol('writeEntryClass');\nconst WRITE = Symbol('write');\nconst ONDRAIN = Symbol('ondrain');\nconst path_1 = __importDefault(require(\"path\"));\nconst normalize_windows_path_js_1 = require(\"./normalize-windows-path.js\");\nclass Pack extends minipass_1.Minipass {\n    opt;\n    cwd;\n    maxReadSize;\n    preservePaths;\n    strict;\n    noPax;\n    prefix;\n    linkCache;\n    statCache;\n    file;\n    portable;\n    zip;\n    readdirCache;\n    noDirRecurse;\n    follow;\n    noMtime;\n    mtime;\n    filter;\n    jobs;\n    [WRITEENTRYCLASS];\n    onWriteEntry;\n    [QUEUE];\n    [JOBS] = 0;\n    [PROCESSING] = false;\n    [ENDED] = false;\n    constructor(opt = {}) {\n        //@ts-ignore\n        super();\n        this.opt = opt;\n        this.file = opt.file || '';\n        this.cwd = opt.cwd || process.cwd();\n        this.maxReadSize = opt.maxReadSize;\n        this.preservePaths = !!opt.preservePaths;\n        this.strict = !!opt.strict;\n        this.noPax = !!opt.noPax;\n        this.prefix = (0, normalize_windows_path_js_1.normalizeWindowsPath)(opt.prefix || '');\n        this.linkCache = opt.linkCache || new Map();\n        this.statCache = opt.statCache || new Map();\n        this.readdirCache = opt.readdirCache || new Map();\n        this.onWriteEntry = opt.onWriteEntry;\n        this[WRITEENTRYCLASS] = write_entry_js_1.WriteEntry;\n        if (typeof opt.onwarn === 'function') {\n            this.on('warn', opt.onwarn);\n        }\n        this.portable = !!opt.portable;\n        if (opt.gzip || opt.brotli) {\n            if (opt.gzip && opt.brotli) {\n                throw new TypeError('gzip and brotli are mutually exclusive');\n            }\n            if (opt.gzip) {\n                if (typeof opt.gzip !== 'object') {\n                    opt.gzip = {};\n                }\n                if (this.portable) {\n                    opt.gzip.portable = true;\n                }\n                this.zip = new zlib.Gzip(opt.gzip);\n            }\n            if (opt.brotli) {\n                if (typeof opt.brotli !== 'object') {\n                    opt.brotli = {};\n                }\n                this.zip = new zlib.BrotliCompress(opt.brotli);\n            }\n            /* c8 ignore next */\n            if (!this.zip)\n                throw new Error('impossible');\n            const zip = this.zip;\n            zip.on('data', chunk => super.write(chunk));\n            zip.on('end', () => super.end());\n            zip.on('drain', () => this[ONDRAIN]());\n            this.on('resume', () => zip.resume());\n        }\n        else {\n            this.on('drain', this[ONDRAIN]);\n        }\n        this.noDirRecurse = !!opt.noDirRecurse;\n        this.follow = !!opt.follow;\n        this.noMtime = !!opt.noMtime;\n        if (opt.mtime)\n            this.mtime = opt.mtime;\n        this.filter =\n            typeof opt.filter === 'function' ? opt.filter : () => true;\n        this[QUEUE] = new yallist_1.Yallist();\n        this[JOBS] = 0;\n        this.jobs = Number(opt.jobs) || 4;\n        this[PROCESSING] = false;\n        this[ENDED] = false;\n    }\n    [WRITE](chunk) {\n        return super.write(chunk);\n    }\n    add(path) {\n        this.write(path);\n        return this;\n    }\n    end(path, encoding, cb) {\n        /* c8 ignore start */\n        if (typeof path === 'function') {\n            cb = path;\n            path = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        /* c8 ignore stop */\n        if (path) {\n            this.add(path);\n        }\n        this[ENDED] = true;\n        this[PROCESS]();\n        /* c8 ignore next */\n        if (cb)\n            cb();\n        return this;\n    }\n    write(path) {\n        if (this[ENDED]) {\n            throw new Error('write after end');\n        }\n        if (path instanceof read_entry_js_1.ReadEntry) {\n            this[ADDTARENTRY](path);\n        }\n        else {\n            this[ADDFSENTRY](path);\n        }\n        return this.flowing;\n    }\n    [ADDTARENTRY](p) {\n        const absolute = (0, normalize_windows_path_js_1.normalizeWindowsPath)(path_1.default.resolve(this.cwd, p.path));\n        // in this case, we don't have to wait for the stat\n        if (!this.filter(p.path, p)) {\n            p.resume();\n        }\n        else {\n            const job = new PackJob(p.path, absolute);\n            job.entry = new write_entry_js_1.WriteEntryTar(p, this[ENTRYOPT](job));\n            job.entry.on('end', () => this[JOBDONE](job));\n            this[JOBS] += 1;\n            this[QUEUE].push(job);\n        }\n        this[PROCESS]();\n    }\n    [ADDFSENTRY](p) {\n        const absolute = (0, normalize_windows_path_js_1.normalizeWindowsPath)(path_1.default.resolve(this.cwd, p));\n        this[QUEUE].push(new PackJob(p, absolute));\n        this[PROCESS]();\n    }\n    [STAT](job) {\n        job.pending = true;\n        this[JOBS] += 1;\n        const stat = this.follow ? 'stat' : 'lstat';\n        fs_1.default[stat](job.absolute, (er, stat) => {\n            job.pending = false;\n            this[JOBS] -= 1;\n            if (er) {\n                this.emit('error', er);\n            }\n            else {\n                this[ONSTAT](job, stat);\n            }\n        });\n    }\n    [ONSTAT](job, stat) {\n        this.statCache.set(job.absolute, stat);\n        job.stat = stat;\n        // now we have the stat, we can filter it.\n        if (!this.filter(job.path, stat)) {\n            job.ignore = true;\n        }\n        this[PROCESS]();\n    }\n    [READDIR](job) {\n        job.pending = true;\n        this[JOBS] += 1;\n        fs_1.default.readdir(job.absolute, (er, entries) => {\n            job.pending = false;\n            this[JOBS] -= 1;\n            if (er) {\n                return this.emit('error', er);\n            }\n            this[ONREADDIR](job, entries);\n        });\n    }\n    [ONREADDIR](job, entries) {\n        this.readdirCache.set(job.absolute, entries);\n        job.readdir = entries;\n        this[PROCESS]();\n    }\n    [PROCESS]() {\n        if (this[PROCESSING]) {\n            return;\n        }\n        this[PROCESSING] = true;\n        for (let w = this[QUEUE].head; !!w && this[JOBS] < this.jobs; w = w.next) {\n            this[PROCESSJOB](w.value);\n            if (w.value.ignore) {\n                const p = w.next;\n                this[QUEUE].removeNode(w);\n                w.next = p;\n            }\n        }\n        this[PROCESSING] = false;\n        if (this[ENDED] && !this[QUEUE].length && this[JOBS] === 0) {\n            if (this.zip) {\n                this.zip.end(EOF);\n            }\n            else {\n                super.write(EOF);\n                super.end();\n            }\n        }\n    }\n    get [CURRENT]() {\n        return this[QUEUE] && this[QUEUE].head && this[QUEUE].head.value;\n    }\n    [JOBDONE](_job) {\n        this[QUEUE].shift();\n        this[JOBS] -= 1;\n        this[PROCESS]();\n    }\n    [PROCESSJOB](job) {\n        if (job.pending) {\n            return;\n        }\n        if (job.entry) {\n            if (job === this[CURRENT] && !job.piped) {\n                this[PIPE](job);\n            }\n            return;\n        }\n        if (!job.stat) {\n            const sc = this.statCache.get(job.absolute);\n            if (sc) {\n                this[ONSTAT](job, sc);\n            }\n            else {\n                this[STAT](job);\n            }\n        }\n        if (!job.stat) {\n            return;\n        }\n        // filtered out!\n        if (job.ignore) {\n            return;\n        }\n        if (!this.noDirRecurse &&\n            job.stat.isDirectory() &&\n            !job.readdir) {\n            const rc = this.readdirCache.get(job.absolute);\n            if (rc) {\n                this[ONREADDIR](job, rc);\n            }\n            else {\n                this[READDIR](job);\n            }\n            if (!job.readdir) {\n                return;\n            }\n        }\n        // we know it doesn't have an entry, because that got checked above\n        job.entry = this[ENTRY](job);\n        if (!job.entry) {\n            job.ignore = true;\n            return;\n        }\n        if (job === this[CURRENT] && !job.piped) {\n            this[PIPE](job);\n        }\n    }\n    [ENTRYOPT](job) {\n        return {\n            onwarn: (code, msg, data) => this.warn(code, msg, data),\n            noPax: this.noPax,\n            cwd: this.cwd,\n            absolute: job.absolute,\n            preservePaths: this.preservePaths,\n            maxReadSize: this.maxReadSize,\n            strict: this.strict,\n            portable: this.portable,\n            linkCache: this.linkCache,\n            statCache: this.statCache,\n            noMtime: this.noMtime,\n            mtime: this.mtime,\n            prefix: this.prefix,\n            onWriteEntry: this.onWriteEntry,\n        };\n    }\n    [ENTRY](job) {\n        this[JOBS] += 1;\n        try {\n            const e = new this[WRITEENTRYCLASS](job.path, this[ENTRYOPT](job));\n            return e\n                .on('end', () => this[JOBDONE](job))\n                .on('error', er => this.emit('error', er));\n        }\n        catch (er) {\n            this.emit('error', er);\n        }\n    }\n    [ONDRAIN]() {\n        if (this[CURRENT] && this[CURRENT].entry) {\n            this[CURRENT].entry.resume();\n        }\n    }\n    // like .pipe() but using super, because our write() is special\n    [PIPE](job) {\n        job.piped = true;\n        if (job.readdir) {\n            job.readdir.forEach(entry => {\n                const p = job.path;\n                const base = p === './' ? '' : p.replace(/\\/*$/, '/');\n                this[ADDFSENTRY](base + entry);\n            });\n        }\n        const source = job.entry;\n        const zip = this.zip;\n        /* c8 ignore start */\n        if (!source)\n            throw new Error('cannot pipe without source');\n        /* c8 ignore stop */\n        if (zip) {\n            source.on('data', chunk => {\n                if (!zip.write(chunk)) {\n                    source.pause();\n                }\n            });\n        }\n        else {\n            source.on('data', chunk => {\n                if (!super.write(chunk)) {\n                    source.pause();\n                }\n            });\n        }\n    }\n    pause() {\n        if (this.zip) {\n            this.zip.pause();\n        }\n        return super.pause();\n    }\n    warn(code, message, data = {}) {\n        (0, warn_method_js_1.warnMethod)(this, code, message, data);\n    }\n}\nexports.Pack = Pack;\nclass PackSync extends Pack {\n    sync = true;\n    constructor(opt) {\n        super(opt);\n        this[WRITEENTRYCLASS] = write_entry_js_1.WriteEntrySync;\n    }\n    // pause/resume are no-ops in sync streams.\n    pause() { }\n    resume() { }\n    [STAT](job) {\n        const stat = this.follow ? 'statSync' : 'lstatSync';\n        this[ONSTAT](job, fs_1.default[stat](job.absolute));\n    }\n    [READDIR](job) {\n        this[ONREADDIR](job, fs_1.default.readdirSync(job.absolute));\n    }\n    // gotta get it all in this tick\n    [PIPE](job) {\n        const source = job.entry;\n        const zip = this.zip;\n        if (job.readdir) {\n            job.readdir.forEach(entry => {\n                const p = job.path;\n                const base = p === './' ? '' : p.replace(/\\/*$/, '/');\n                this[ADDFSENTRY](base + entry);\n            });\n        }\n        /* c8 ignore start */\n        if (!source)\n            throw new Error('Cannot pipe without source');\n        /* c8 ignore stop */\n        if (zip) {\n            source.on('data', chunk => {\n                zip.write(chunk);\n            });\n        }\n        else {\n            source.on('data', chunk => {\n                super[WRITE](chunk);\n            });\n        }\n    }\n}\nexports.PackSync = PackSync;\n//# sourceMappingURL=pack.js.map","\"use strict\";\n// this[BUFFER] is the remainder of a chunk if we're waiting for\n// the full 512 bytes of a header to come in.  We will Buffer.concat()\n// it to the next write(), which is a mem copy, but a small one.\n//\n// this[QUEUE] is a Yallist of entries that haven't been emitted\n// yet this can only get filled up if the user keeps write()ing after\n// a write() returns false, or does a write() with more than one entry\n//\n// We don't buffer chunks, we always parse them and either create an\n// entry, or push it into the active entry.  The ReadEntry class knows\n// to throw data away if .ignore=true\n//\n// Shift entry off the buffer when it emits 'end', and emit 'entry' for\n// the next one in the list.\n//\n// At any time, we're pushing body chunks into the entry at WRITEENTRY,\n// and waiting for 'end' on the entry at READENTRY\n//\n// ignored entries get .resume() called on them straight away\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Parser = void 0;\nconst events_1 = require(\"events\");\nconst minizlib_1 = require(\"minizlib\");\nconst yallist_1 = require(\"yallist\");\nconst header_js_1 = require(\"./header.js\");\nconst pax_js_1 = require(\"./pax.js\");\nconst read_entry_js_1 = require(\"./read-entry.js\");\nconst warn_method_js_1 = require(\"./warn-method.js\");\nconst maxMetaEntrySize = 1024 * 1024;\nconst gzipHeader = Buffer.from([0x1f, 0x8b]);\nconst STATE = Symbol('state');\nconst WRITEENTRY = Symbol('writeEntry');\nconst READENTRY = Symbol('readEntry');\nconst NEXTENTRY = Symbol('nextEntry');\nconst PROCESSENTRY = Symbol('processEntry');\nconst EX = Symbol('extendedHeader');\nconst GEX = Symbol('globalExtendedHeader');\nconst META = Symbol('meta');\nconst EMITMETA = Symbol('emitMeta');\nconst BUFFER = Symbol('buffer');\nconst QUEUE = Symbol('queue');\nconst ENDED = Symbol('ended');\nconst EMITTEDEND = Symbol('emittedEnd');\nconst EMIT = Symbol('emit');\nconst UNZIP = Symbol('unzip');\nconst CONSUMECHUNK = Symbol('consumeChunk');\nconst CONSUMECHUNKSUB = Symbol('consumeChunkSub');\nconst CONSUMEBODY = Symbol('consumeBody');\nconst CONSUMEMETA = Symbol('consumeMeta');\nconst CONSUMEHEADER = Symbol('consumeHeader');\nconst CONSUMING = Symbol('consuming');\nconst BUFFERCONCAT = Symbol('bufferConcat');\nconst MAYBEEND = Symbol('maybeEnd');\nconst WRITING = Symbol('writing');\nconst ABORTED = Symbol('aborted');\nconst DONE = Symbol('onDone');\nconst SAW_VALID_ENTRY = Symbol('sawValidEntry');\nconst SAW_NULL_BLOCK = Symbol('sawNullBlock');\nconst SAW_EOF = Symbol('sawEOF');\nconst CLOSESTREAM = Symbol('closeStream');\nconst noop = () => true;\nclass Parser extends events_1.EventEmitter {\n    file;\n    strict;\n    maxMetaEntrySize;\n    filter;\n    brotli;\n    writable = true;\n    readable = false;\n    [QUEUE] = new yallist_1.Yallist();\n    [BUFFER];\n    [READENTRY];\n    [WRITEENTRY];\n    [STATE] = 'begin';\n    [META] = '';\n    [EX];\n    [GEX];\n    [ENDED] = false;\n    [UNZIP];\n    [ABORTED] = false;\n    [SAW_VALID_ENTRY];\n    [SAW_NULL_BLOCK] = false;\n    [SAW_EOF] = false;\n    [WRITING] = false;\n    [CONSUMING] = false;\n    [EMITTEDEND] = false;\n    constructor(opt = {}) {\n        super();\n        this.file = opt.file || '';\n        // these BADARCHIVE errors can't be detected early. listen on DONE.\n        this.on(DONE, () => {\n            if (this[STATE] === 'begin' ||\n                this[SAW_VALID_ENTRY] === false) {\n                // either less than 1 block of data, or all entries were invalid.\n                // Either way, probably not even a tarball.\n                this.warn('TAR_BAD_ARCHIVE', 'Unrecognized archive format');\n            }\n        });\n        if (opt.ondone) {\n            this.on(DONE, opt.ondone);\n        }\n        else {\n            this.on(DONE, () => {\n                this.emit('prefinish');\n                this.emit('finish');\n                this.emit('end');\n            });\n        }\n        this.strict = !!opt.strict;\n        this.maxMetaEntrySize = opt.maxMetaEntrySize || maxMetaEntrySize;\n        this.filter = typeof opt.filter === 'function' ? opt.filter : noop;\n        // Unlike gzip, brotli doesn't have any magic bytes to identify it\n        // Users need to explicitly tell us they're extracting a brotli file\n        // Or we infer from the file extension\n        const isTBR = opt.file &&\n            (opt.file.endsWith('.tar.br') || opt.file.endsWith('.tbr'));\n        // if it's a tbr file it MIGHT be brotli, but we don't know until\n        // we look at it and verify it's not a valid tar file.\n        this.brotli =\n            !opt.gzip && opt.brotli !== undefined ? opt.brotli\n                : isTBR ? undefined\n                    : false;\n        // have to set this so that streams are ok piping into it\n        this.on('end', () => this[CLOSESTREAM]());\n        if (typeof opt.onwarn === 'function') {\n            this.on('warn', opt.onwarn);\n        }\n        if (typeof opt.onReadEntry === 'function') {\n            this.on('entry', opt.onReadEntry);\n        }\n    }\n    warn(code, message, data = {}) {\n        (0, warn_method_js_1.warnMethod)(this, code, message, data);\n    }\n    [CONSUMEHEADER](chunk, position) {\n        if (this[SAW_VALID_ENTRY] === undefined) {\n            this[SAW_VALID_ENTRY] = false;\n        }\n        let header;\n        try {\n            header = new header_js_1.Header(chunk, position, this[EX], this[GEX]);\n        }\n        catch (er) {\n            return this.warn('TAR_ENTRY_INVALID', er);\n        }\n        if (header.nullBlock) {\n            if (this[SAW_NULL_BLOCK]) {\n                this[SAW_EOF] = true;\n                // ending an archive with no entries.  pointless, but legal.\n                if (this[STATE] === 'begin') {\n                    this[STATE] = 'header';\n                }\n                this[EMIT]('eof');\n            }\n            else {\n                this[SAW_NULL_BLOCK] = true;\n                this[EMIT]('nullBlock');\n            }\n        }\n        else {\n            this[SAW_NULL_BLOCK] = false;\n            if (!header.cksumValid) {\n                this.warn('TAR_ENTRY_INVALID', 'checksum failure', { header });\n            }\n            else if (!header.path) {\n                this.warn('TAR_ENTRY_INVALID', 'path is required', { header });\n            }\n            else {\n                const type = header.type;\n                if (/^(Symbolic)?Link$/.test(type) && !header.linkpath) {\n                    this.warn('TAR_ENTRY_INVALID', 'linkpath required', {\n                        header,\n                    });\n                }\n                else if (!/^(Symbolic)?Link$/.test(type) &&\n                    !/^(Global)?ExtendedHeader$/.test(type) &&\n                    header.linkpath) {\n                    this.warn('TAR_ENTRY_INVALID', 'linkpath forbidden', {\n                        header,\n                    });\n                }\n                else {\n                    const entry = (this[WRITEENTRY] = new read_entry_js_1.ReadEntry(header, this[EX], this[GEX]));\n                    // we do this for meta & ignored entries as well, because they\n                    // are still valid tar, or else we wouldn't know to ignore them\n                    if (!this[SAW_VALID_ENTRY]) {\n                        if (entry.remain) {\n                            // this might be the one!\n                            const onend = () => {\n                                if (!entry.invalid) {\n                                    this[SAW_VALID_ENTRY] = true;\n                                }\n                            };\n                            entry.on('end', onend);\n                        }\n                        else {\n                            this[SAW_VALID_ENTRY] = true;\n                        }\n                    }\n                    if (entry.meta) {\n                        if (entry.size > this.maxMetaEntrySize) {\n                            entry.ignore = true;\n                            this[EMIT]('ignoredEntry', entry);\n                            this[STATE] = 'ignore';\n                            entry.resume();\n                        }\n                        else if (entry.size > 0) {\n                            this[META] = '';\n                            entry.on('data', c => (this[META] += c));\n                            this[STATE] = 'meta';\n                        }\n                    }\n                    else {\n                        this[EX] = undefined;\n                        entry.ignore =\n                            entry.ignore || !this.filter(entry.path, entry);\n                        if (entry.ignore) {\n                            // probably valid, just not something we care about\n                            this[EMIT]('ignoredEntry', entry);\n                            this[STATE] = entry.remain ? 'ignore' : 'header';\n                            entry.resume();\n                        }\n                        else {\n                            if (entry.remain) {\n                                this[STATE] = 'body';\n                            }\n                            else {\n                                this[STATE] = 'header';\n                                entry.end();\n                            }\n                            if (!this[READENTRY]) {\n                                this[QUEUE].push(entry);\n                                this[NEXTENTRY]();\n                            }\n                            else {\n                                this[QUEUE].push(entry);\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    [CLOSESTREAM]() {\n        queueMicrotask(() => this.emit('close'));\n    }\n    [PROCESSENTRY](entry) {\n        let go = true;\n        if (!entry) {\n            this[READENTRY] = undefined;\n            go = false;\n        }\n        else if (Array.isArray(entry)) {\n            const [ev, ...args] = entry;\n            this.emit(ev, ...args);\n        }\n        else {\n            this[READENTRY] = entry;\n            this.emit('entry', entry);\n            if (!entry.emittedEnd) {\n                entry.on('end', () => this[NEXTENTRY]());\n                go = false;\n            }\n        }\n        return go;\n    }\n    [NEXTENTRY]() {\n        do { } while (this[PROCESSENTRY](this[QUEUE].shift()));\n        if (!this[QUEUE].length) {\n            // At this point, there's nothing in the queue, but we may have an\n            // entry which is being consumed (readEntry).\n            // If we don't, then we definitely can handle more data.\n            // If we do, and either it's flowing, or it has never had any data\n            // written to it, then it needs more.\n            // The only other possibility is that it has returned false from a\n            // write() call, so we wait for the next drain to continue.\n            const re = this[READENTRY];\n            const drainNow = !re || re.flowing || re.size === re.remain;\n            if (drainNow) {\n                if (!this[WRITING]) {\n                    this.emit('drain');\n                }\n            }\n            else {\n                re.once('drain', () => this.emit('drain'));\n            }\n        }\n    }\n    [CONSUMEBODY](chunk, position) {\n        // write up to but no  more than writeEntry.blockRemain\n        const entry = this[WRITEENTRY];\n        /* c8 ignore start */\n        if (!entry) {\n            throw new Error('attempt to consume body without entry??');\n        }\n        const br = entry.blockRemain ?? 0;\n        /* c8 ignore stop */\n        const c = br >= chunk.length && position === 0 ?\n            chunk\n            : chunk.subarray(position, position + br);\n        entry.write(c);\n        if (!entry.blockRemain) {\n            this[STATE] = 'header';\n            this[WRITEENTRY] = undefined;\n            entry.end();\n        }\n        return c.length;\n    }\n    [CONSUMEMETA](chunk, position) {\n        const entry = this[WRITEENTRY];\n        const ret = this[CONSUMEBODY](chunk, position);\n        // if we finished, then the entry is reset\n        if (!this[WRITEENTRY] && entry) {\n            this[EMITMETA](entry);\n        }\n        return ret;\n    }\n    [EMIT](ev, data, extra) {\n        if (!this[QUEUE].length && !this[READENTRY]) {\n            this.emit(ev, data, extra);\n        }\n        else {\n            this[QUEUE].push([ev, data, extra]);\n        }\n    }\n    [EMITMETA](entry) {\n        this[EMIT]('meta', this[META]);\n        switch (entry.type) {\n            case 'ExtendedHeader':\n            case 'OldExtendedHeader':\n                this[EX] = pax_js_1.Pax.parse(this[META], this[EX], false);\n                break;\n            case 'GlobalExtendedHeader':\n                this[GEX] = pax_js_1.Pax.parse(this[META], this[GEX], true);\n                break;\n            case 'NextFileHasLongPath':\n            case 'OldGnuLongPath': {\n                const ex = this[EX] ?? Object.create(null);\n                this[EX] = ex;\n                ex.path = this[META].replace(/\\0.*/, '');\n                break;\n            }\n            case 'NextFileHasLongLinkpath': {\n                const ex = this[EX] || Object.create(null);\n                this[EX] = ex;\n                ex.linkpath = this[META].replace(/\\0.*/, '');\n                break;\n            }\n            /* c8 ignore start */\n            default:\n                throw new Error('unknown meta: ' + entry.type);\n            /* c8 ignore stop */\n        }\n    }\n    abort(error) {\n        this[ABORTED] = true;\n        this.emit('abort', error);\n        // always throws, even in non-strict mode\n        this.warn('TAR_ABORT', error, { recoverable: false });\n    }\n    write(chunk, encoding, cb) {\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, \n            /* c8 ignore next */\n            typeof encoding === 'string' ? encoding : 'utf8');\n        }\n        if (this[ABORTED]) {\n            /* c8 ignore next */\n            cb?.();\n            return false;\n        }\n        // first write, might be gzipped\n        const needSniff = this[UNZIP] === undefined ||\n            (this.brotli === undefined && this[UNZIP] === false);\n        if (needSniff && chunk) {\n            if (this[BUFFER]) {\n                chunk = Buffer.concat([this[BUFFER], chunk]);\n                this[BUFFER] = undefined;\n            }\n            if (chunk.length < gzipHeader.length) {\n                this[BUFFER] = chunk;\n                /* c8 ignore next */\n                cb?.();\n                return true;\n            }\n            // look for gzip header\n            for (let i = 0; this[UNZIP] === undefined && i < gzipHeader.length; i++) {\n                if (chunk[i] !== gzipHeader[i]) {\n                    this[UNZIP] = false;\n                }\n            }\n            const maybeBrotli = this.brotli === undefined;\n            if (this[UNZIP] === false && maybeBrotli) {\n                // read the first header to see if it's a valid tar file. If so,\n                // we can safely assume that it's not actually brotli, despite the\n                // .tbr or .tar.br file extension.\n                // if we ended before getting a full chunk, yes, def brotli\n                if (chunk.length < 512) {\n                    if (this[ENDED]) {\n                        this.brotli = true;\n                    }\n                    else {\n                        this[BUFFER] = chunk;\n                        /* c8 ignore next */\n                        cb?.();\n                        return true;\n                    }\n                }\n                else {\n                    // if it's tar, it's pretty reliably not brotli, chances of\n                    // that happening are astronomical.\n                    try {\n                        new header_js_1.Header(chunk.subarray(0, 512));\n                        this.brotli = false;\n                    }\n                    catch (_) {\n                        this.brotli = true;\n                    }\n                }\n            }\n            if (this[UNZIP] === undefined ||\n                (this[UNZIP] === false && this.brotli)) {\n                const ended = this[ENDED];\n                this[ENDED] = false;\n                this[UNZIP] =\n                    this[UNZIP] === undefined ?\n                        new minizlib_1.Unzip({})\n                        : new minizlib_1.BrotliDecompress({});\n                this[UNZIP].on('data', chunk => this[CONSUMECHUNK](chunk));\n                this[UNZIP].on('error', er => this.abort(er));\n                this[UNZIP].on('end', () => {\n                    this[ENDED] = true;\n                    this[CONSUMECHUNK]();\n                });\n                this[WRITING] = true;\n                const ret = !!this[UNZIP][ended ? 'end' : 'write'](chunk);\n                this[WRITING] = false;\n                cb?.();\n                return ret;\n            }\n        }\n        this[WRITING] = true;\n        if (this[UNZIP]) {\n            this[UNZIP].write(chunk);\n        }\n        else {\n            this[CONSUMECHUNK](chunk);\n        }\n        this[WRITING] = false;\n        // return false if there's a queue, or if the current entry isn't flowing\n        const ret = this[QUEUE].length ? false\n            : this[READENTRY] ? this[READENTRY].flowing\n                : true;\n        // if we have no queue, then that means a clogged READENTRY\n        if (!ret && !this[QUEUE].length) {\n            this[READENTRY]?.once('drain', () => this.emit('drain'));\n        }\n        /* c8 ignore next */\n        cb?.();\n        return ret;\n    }\n    [BUFFERCONCAT](c) {\n        if (c && !this[ABORTED]) {\n            this[BUFFER] =\n                this[BUFFER] ? Buffer.concat([this[BUFFER], c]) : c;\n        }\n    }\n    [MAYBEEND]() {\n        if (this[ENDED] &&\n            !this[EMITTEDEND] &&\n            !this[ABORTED] &&\n            !this[CONSUMING]) {\n            this[EMITTEDEND] = true;\n            const entry = this[WRITEENTRY];\n            if (entry && entry.blockRemain) {\n                // truncated, likely a damaged file\n                const have = this[BUFFER] ? this[BUFFER].length : 0;\n                this.warn('TAR_BAD_ARCHIVE', `Truncated input (needed ${entry.blockRemain} more bytes, only ${have} available)`, { entry });\n                if (this[BUFFER]) {\n                    entry.write(this[BUFFER]);\n                }\n                entry.end();\n            }\n            this[EMIT](DONE);\n        }\n    }\n    [CONSUMECHUNK](chunk) {\n        if (this[CONSUMING] && chunk) {\n            this[BUFFERCONCAT](chunk);\n        }\n        else if (!chunk && !this[BUFFER]) {\n            this[MAYBEEND]();\n        }\n        else if (chunk) {\n            this[CONSUMING] = true;\n            if (this[BUFFER]) {\n                this[BUFFERCONCAT](chunk);\n                const c = this[BUFFER];\n                this[BUFFER] = undefined;\n                this[CONSUMECHUNKSUB](c);\n            }\n            else {\n                this[CONSUMECHUNKSUB](chunk);\n            }\n            while (this[BUFFER] &&\n                this[BUFFER]?.length >= 512 &&\n                !this[ABORTED] &&\n                !this[SAW_EOF]) {\n                const c = this[BUFFER];\n                this[BUFFER] = undefined;\n                this[CONSUMECHUNKSUB](c);\n            }\n            this[CONSUMING] = false;\n        }\n        if (!this[BUFFER] || this[ENDED]) {\n            this[MAYBEEND]();\n        }\n    }\n    [CONSUMECHUNKSUB](chunk) {\n        // we know that we are in CONSUMING mode, so anything written goes into\n        // the buffer.  Advance the position and put any remainder in the buffer.\n        let position = 0;\n        const length = chunk.length;\n        while (position + 512 <= length &&\n            !this[ABORTED] &&\n            !this[SAW_EOF]) {\n            switch (this[STATE]) {\n                case 'begin':\n                case 'header':\n                    this[CONSUMEHEADER](chunk, position);\n                    position += 512;\n                    break;\n                case 'ignore':\n                case 'body':\n                    position += this[CONSUMEBODY](chunk, position);\n                    break;\n                case 'meta':\n                    position += this[CONSUMEMETA](chunk, position);\n                    break;\n                /* c8 ignore start */\n                default:\n                    throw new Error('invalid state: ' + this[STATE]);\n                /* c8 ignore stop */\n            }\n        }\n        if (position < length) {\n            if (this[BUFFER]) {\n                this[BUFFER] = Buffer.concat([\n                    chunk.subarray(position),\n                    this[BUFFER],\n                ]);\n            }\n            else {\n                this[BUFFER] = chunk.subarray(position);\n            }\n        }\n    }\n    end(chunk, encoding, cb) {\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            encoding = undefined;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding);\n        }\n        if (cb)\n            this.once('finish', cb);\n        if (!this[ABORTED]) {\n            if (this[UNZIP]) {\n                /* c8 ignore start */\n                if (chunk)\n                    this[UNZIP].write(chunk);\n                /* c8 ignore stop */\n                this[UNZIP].end();\n            }\n            else {\n                this[ENDED] = true;\n                if (this.brotli === undefined)\n                    chunk = chunk || Buffer.alloc(0);\n                if (chunk)\n                    this.write(chunk);\n                this[MAYBEEND]();\n            }\n        }\n        return this;\n    }\n}\nexports.Parser = Parser;\n//# sourceMappingURL=parse.js.map","\"use strict\";\n// A path exclusive reservation system\n// reserve([list, of, paths], fn)\n// When the fn is first in line for all its paths, it\n// is called with a cb that clears the reservation.\n//\n// Used by async unpack to avoid clobbering paths in use,\n// while still allowing maximal safe parallelization.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathReservations = void 0;\nconst node_path_1 = require(\"node:path\");\nconst normalize_unicode_js_1 = require(\"./normalize-unicode.js\");\nconst strip_trailing_slashes_js_1 = require(\"./strip-trailing-slashes.js\");\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nconst isWindows = platform === 'win32';\n// return a set of parent dirs for a given path\n// '/a/b/c/d' -> ['/', '/a', '/a/b', '/a/b/c', '/a/b/c/d']\nconst getDirs = (path) => {\n    const dirs = path\n        .split('/')\n        .slice(0, -1)\n        .reduce((set, path) => {\n        const s = set[set.length - 1];\n        if (s !== undefined) {\n            path = (0, node_path_1.join)(s, path);\n        }\n        set.push(path || '/');\n        return set;\n    }, []);\n    return dirs;\n};\nclass PathReservations {\n    // path => [function or Set]\n    // A Set object means a directory reservation\n    // A fn is a direct reservation on that path\n    #queues = new Map();\n    // fn => {paths:[path,...], dirs:[path, ...]}\n    #reservations = new Map();\n    // functions currently running\n    #running = new Set();\n    reserve(paths, fn) {\n        paths =\n            isWindows ?\n                ['win32 parallelization disabled']\n                : paths.map(p => {\n                    // don't need normPath, because we skip this entirely for windows\n                    return (0, strip_trailing_slashes_js_1.stripTrailingSlashes)((0, node_path_1.join)((0, normalize_unicode_js_1.normalizeUnicode)(p))).toLowerCase();\n                });\n        const dirs = new Set(paths.map(path => getDirs(path)).reduce((a, b) => a.concat(b)));\n        this.#reservations.set(fn, { dirs, paths });\n        for (const p of paths) {\n            const q = this.#queues.get(p);\n            if (!q) {\n                this.#queues.set(p, [fn]);\n            }\n            else {\n                q.push(fn);\n            }\n        }\n        for (const dir of dirs) {\n            const q = this.#queues.get(dir);\n            if (!q) {\n                this.#queues.set(dir, [new Set([fn])]);\n            }\n            else {\n                const l = q[q.length - 1];\n                if (l instanceof Set) {\n                    l.add(fn);\n                }\n                else {\n                    q.push(new Set([fn]));\n                }\n            }\n        }\n        return this.#run(fn);\n    }\n    // return the queues for each path the function cares about\n    // fn => {paths, dirs}\n    #getQueues(fn) {\n        const res = this.#reservations.get(fn);\n        /* c8 ignore start */\n        if (!res) {\n            throw new Error('function does not have any path reservations');\n        }\n        /* c8 ignore stop */\n        return {\n            paths: res.paths.map((path) => this.#queues.get(path)),\n            dirs: [...res.dirs].map(path => this.#queues.get(path)),\n        };\n    }\n    // check if fn is first in line for all its paths, and is\n    // included in the first set for all its dir queues\n    check(fn) {\n        const { paths, dirs } = this.#getQueues(fn);\n        return (paths.every(q => q && q[0] === fn) &&\n            dirs.every(q => q && q[0] instanceof Set && q[0].has(fn)));\n    }\n    // run the function if it's first in line and not already running\n    #run(fn) {\n        if (this.#running.has(fn) || !this.check(fn)) {\n            return false;\n        }\n        this.#running.add(fn);\n        fn(() => this.#clear(fn));\n        return true;\n    }\n    #clear(fn) {\n        if (!this.#running.has(fn)) {\n            return false;\n        }\n        const res = this.#reservations.get(fn);\n        /* c8 ignore start */\n        if (!res) {\n            throw new Error('invalid reservation');\n        }\n        /* c8 ignore stop */\n        const { paths, dirs } = res;\n        const next = new Set();\n        for (const path of paths) {\n            const q = this.#queues.get(path);\n            /* c8 ignore start */\n            if (!q || q?.[0] !== fn) {\n                continue;\n            }\n            /* c8 ignore stop */\n            const q0 = q[1];\n            if (!q0) {\n                this.#queues.delete(path);\n                continue;\n            }\n            q.shift();\n            if (typeof q0 === 'function') {\n                next.add(q0);\n            }\n            else {\n                for (const f of q0) {\n                    next.add(f);\n                }\n            }\n        }\n        for (const dir of dirs) {\n            const q = this.#queues.get(dir);\n            const q0 = q?.[0];\n            /* c8 ignore next - type safety only */\n            if (!q || !(q0 instanceof Set))\n                continue;\n            if (q0.size === 1 && q.length === 1) {\n                this.#queues.delete(dir);\n                continue;\n            }\n            else if (q0.size === 1) {\n                q.shift();\n                // next one must be a function,\n                // or else the Set would've been reused\n                const n = q[0];\n                if (typeof n === 'function') {\n                    next.add(n);\n                }\n            }\n            else {\n                q0.delete(fn);\n            }\n        }\n        this.#running.delete(fn);\n        next.forEach(fn => this.#run(fn));\n        return true;\n    }\n}\nexports.PathReservations = PathReservations;\n//# sourceMappingURL=path-reservations.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Pax = void 0;\nconst node_path_1 = require(\"node:path\");\nconst header_js_1 = require(\"./header.js\");\nclass Pax {\n    atime;\n    mtime;\n    ctime;\n    charset;\n    comment;\n    gid;\n    uid;\n    gname;\n    uname;\n    linkpath;\n    dev;\n    ino;\n    nlink;\n    path;\n    size;\n    mode;\n    global;\n    constructor(obj, global = false) {\n        this.atime = obj.atime;\n        this.charset = obj.charset;\n        this.comment = obj.comment;\n        this.ctime = obj.ctime;\n        this.dev = obj.dev;\n        this.gid = obj.gid;\n        this.global = global;\n        this.gname = obj.gname;\n        this.ino = obj.ino;\n        this.linkpath = obj.linkpath;\n        this.mtime = obj.mtime;\n        this.nlink = obj.nlink;\n        this.path = obj.path;\n        this.size = obj.size;\n        this.uid = obj.uid;\n        this.uname = obj.uname;\n    }\n    encode() {\n        const body = this.encodeBody();\n        if (body === '') {\n            return Buffer.allocUnsafe(0);\n        }\n        const bodyLen = Buffer.byteLength(body);\n        // round up to 512 bytes\n        // add 512 for header\n        const bufLen = 512 * Math.ceil(1 + bodyLen / 512);\n        const buf = Buffer.allocUnsafe(bufLen);\n        // 0-fill the header section, it might not hit every field\n        for (let i = 0; i < 512; i++) {\n            buf[i] = 0;\n        }\n        new header_js_1.Header({\n            // XXX split the path\n            // then the path should be PaxHeader + basename, but less than 99,\n            // prepend with the dirname\n            /* c8 ignore start */\n            path: ('PaxHeader/' + (0, node_path_1.basename)(this.path ?? '')).slice(0, 99),\n            /* c8 ignore stop */\n            mode: this.mode || 0o644,\n            uid: this.uid,\n            gid: this.gid,\n            size: bodyLen,\n            mtime: this.mtime,\n            type: this.global ? 'GlobalExtendedHeader' : 'ExtendedHeader',\n            linkpath: '',\n            uname: this.uname || '',\n            gname: this.gname || '',\n            devmaj: 0,\n            devmin: 0,\n            atime: this.atime,\n            ctime: this.ctime,\n        }).encode(buf);\n        buf.write(body, 512, bodyLen, 'utf8');\n        // null pad after the body\n        for (let i = bodyLen + 512; i < buf.length; i++) {\n            buf[i] = 0;\n        }\n        return buf;\n    }\n    encodeBody() {\n        return (this.encodeField('path') +\n            this.encodeField('ctime') +\n            this.encodeField('atime') +\n            this.encodeField('dev') +\n            this.encodeField('ino') +\n            this.encodeField('nlink') +\n            this.encodeField('charset') +\n            this.encodeField('comment') +\n            this.encodeField('gid') +\n            this.encodeField('gname') +\n            this.encodeField('linkpath') +\n            this.encodeField('mtime') +\n            this.encodeField('size') +\n            this.encodeField('uid') +\n            this.encodeField('uname'));\n    }\n    encodeField(field) {\n        if (this[field] === undefined) {\n            return '';\n        }\n        const r = this[field];\n        const v = r instanceof Date ? r.getTime() / 1000 : r;\n        const s = ' ' +\n            (field === 'dev' || field === 'ino' || field === 'nlink' ?\n                'SCHILY.'\n                : '') +\n            field +\n            '=' +\n            v +\n            '\\n';\n        const byteLen = Buffer.byteLength(s);\n        // the digits includes the length of the digits in ascii base-10\n        // so if it's 9 characters, then adding 1 for the 9 makes it 10\n        // which makes it 11 chars.\n        let digits = Math.floor(Math.log(byteLen) / Math.log(10)) + 1;\n        if (byteLen + digits >= Math.pow(10, digits)) {\n            digits += 1;\n        }\n        const len = digits + byteLen;\n        return len + s;\n    }\n    static parse(str, ex, g = false) {\n        return new Pax(merge(parseKV(str), ex), g);\n    }\n}\nexports.Pax = Pax;\nconst merge = (a, b) => b ? Object.assign({}, b, a) : a;\nconst parseKV = (str) => str\n    .replace(/\\n$/, '')\n    .split('\\n')\n    .reduce(parseKVLine, Object.create(null));\nconst parseKVLine = (set, line) => {\n    const n = parseInt(line, 10);\n    // XXX Values with \\n in them will fail this.\n    // Refactor to not be a naive line-by-line parse.\n    if (n !== Buffer.byteLength(line) + 1) {\n        return set;\n    }\n    line = line.slice((n + ' ').length);\n    const kv = line.split('=');\n    const r = kv.shift();\n    if (!r) {\n        return set;\n    }\n    const k = r.replace(/^SCHILY\\.(dev|ino|nlink)/, '$1');\n    const v = kv.join('=');\n    set[k] =\n        /^([A-Z]+\\.)?([mac]|birth|creation)time$/.test(k) ?\n            new Date(Number(v) * 1000)\n            : /^[0-9]+$/.test(v) ? +v\n                : v;\n    return set;\n};\n//# sourceMappingURL=pax.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ReadEntry = void 0;\nconst minipass_1 = require(\"minipass\");\nconst normalize_windows_path_js_1 = require(\"./normalize-windows-path.js\");\nclass ReadEntry extends minipass_1.Minipass {\n    extended;\n    globalExtended;\n    header;\n    startBlockSize;\n    blockRemain;\n    remain;\n    type;\n    meta = false;\n    ignore = false;\n    path;\n    mode;\n    uid;\n    gid;\n    uname;\n    gname;\n    size = 0;\n    mtime;\n    atime;\n    ctime;\n    linkpath;\n    dev;\n    ino;\n    nlink;\n    invalid = false;\n    absolute;\n    unsupported = false;\n    constructor(header, ex, gex) {\n        super({});\n        // read entries always start life paused.  this is to avoid the\n        // situation where Minipass's auto-ending empty streams results\n        // in an entry ending before we're ready for it.\n        this.pause();\n        this.extended = ex;\n        this.globalExtended = gex;\n        this.header = header;\n        /* c8 ignore start */\n        this.remain = header.size ?? 0;\n        /* c8 ignore stop */\n        this.startBlockSize = 512 * Math.ceil(this.remain / 512);\n        this.blockRemain = this.startBlockSize;\n        this.type = header.type;\n        switch (this.type) {\n            case 'File':\n            case 'OldFile':\n            case 'Link':\n            case 'SymbolicLink':\n            case 'CharacterDevice':\n            case 'BlockDevice':\n            case 'Directory':\n            case 'FIFO':\n            case 'ContiguousFile':\n            case 'GNUDumpDir':\n                break;\n            case 'NextFileHasLongLinkpath':\n            case 'NextFileHasLongPath':\n            case 'OldGnuLongPath':\n            case 'GlobalExtendedHeader':\n            case 'ExtendedHeader':\n            case 'OldExtendedHeader':\n                this.meta = true;\n                break;\n            // NOTE: gnutar and bsdtar treat unrecognized types as 'File'\n            // it may be worth doing the same, but with a warning.\n            default:\n                this.ignore = true;\n        }\n        /* c8 ignore start */\n        if (!header.path) {\n            throw new Error('no path provided for tar.ReadEntry');\n        }\n        /* c8 ignore stop */\n        this.path = (0, normalize_windows_path_js_1.normalizeWindowsPath)(header.path);\n        this.mode = header.mode;\n        if (this.mode) {\n            this.mode = this.mode & 0o7777;\n        }\n        this.uid = header.uid;\n        this.gid = header.gid;\n        this.uname = header.uname;\n        this.gname = header.gname;\n        this.size = this.remain;\n        this.mtime = header.mtime;\n        this.atime = header.atime;\n        this.ctime = header.ctime;\n        /* c8 ignore start */\n        this.linkpath =\n            header.linkpath ?\n                (0, normalize_windows_path_js_1.normalizeWindowsPath)(header.linkpath)\n                : undefined;\n        /* c8 ignore stop */\n        this.uname = header.uname;\n        this.gname = header.gname;\n        if (ex) {\n            this.#slurp(ex);\n        }\n        if (gex) {\n            this.#slurp(gex, true);\n        }\n    }\n    write(data) {\n        const writeLen = data.length;\n        if (writeLen > this.blockRemain) {\n            throw new Error('writing more to entry than is appropriate');\n        }\n        const r = this.remain;\n        const br = this.blockRemain;\n        this.remain = Math.max(0, r - writeLen);\n        this.blockRemain = Math.max(0, br - writeLen);\n        if (this.ignore) {\n            return true;\n        }\n        if (r >= writeLen) {\n            return super.write(data);\n        }\n        // r < writeLen\n        return super.write(data.subarray(0, r));\n    }\n    #slurp(ex, gex = false) {\n        if (ex.path)\n            ex.path = (0, normalize_windows_path_js_1.normalizeWindowsPath)(ex.path);\n        if (ex.linkpath)\n            ex.linkpath = (0, normalize_windows_path_js_1.normalizeWindowsPath)(ex.linkpath);\n        Object.assign(this, Object.fromEntries(Object.entries(ex).filter(([k, v]) => {\n            // we slurp in everything except for the path attribute in\n            // a global extended header, because that's weird. Also, any\n            // null/undefined values are ignored.\n            return !(v === null ||\n                v === undefined ||\n                (k === 'path' && gex));\n        })));\n    }\n}\nexports.ReadEntry = ReadEntry;\n//# sourceMappingURL=read-entry.js.map","\"use strict\";\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.replace = void 0;\n// tar -r\nconst fs_minipass_1 = require(\"@isaacs/fs-minipass\");\nconst node_fs_1 = __importDefault(require(\"node:fs\"));\nconst node_path_1 = __importDefault(require(\"node:path\"));\nconst header_js_1 = require(\"./header.js\");\nconst list_js_1 = require(\"./list.js\");\nconst make_command_js_1 = require(\"./make-command.js\");\nconst options_js_1 = require(\"./options.js\");\nconst pack_js_1 = require(\"./pack.js\");\n// starting at the head of the file, read a Header\n// If the checksum is invalid, that's our position to start writing\n// If it is, jump forward by the specified size (round up to 512)\n// and try again.\n// Write the new Pack stream starting there.\nconst replaceSync = (opt, files) => {\n    const p = new pack_js_1.PackSync(opt);\n    let threw = true;\n    let fd;\n    let position;\n    try {\n        try {\n            fd = node_fs_1.default.openSync(opt.file, 'r+');\n        }\n        catch (er) {\n            if (er?.code === 'ENOENT') {\n                fd = node_fs_1.default.openSync(opt.file, 'w+');\n            }\n            else {\n                throw er;\n            }\n        }\n        const st = node_fs_1.default.fstatSync(fd);\n        const headBuf = Buffer.alloc(512);\n        POSITION: for (position = 0; position < st.size; position += 512) {\n            for (let bufPos = 0, bytes = 0; bufPos < 512; bufPos += bytes) {\n                bytes = node_fs_1.default.readSync(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos);\n                if (position === 0 &&\n                    headBuf[0] === 0x1f &&\n                    headBuf[1] === 0x8b) {\n                    throw new Error('cannot append to compressed archives');\n                }\n                if (!bytes) {\n                    break POSITION;\n                }\n            }\n            const h = new header_js_1.Header(headBuf);\n            if (!h.cksumValid) {\n                break;\n            }\n            const entryBlockSize = 512 * Math.ceil((h.size || 0) / 512);\n            if (position + entryBlockSize + 512 > st.size) {\n                break;\n            }\n            // the 512 for the header we just parsed will be added as well\n            // also jump ahead all the blocks for the body\n            position += entryBlockSize;\n            if (opt.mtimeCache && h.mtime) {\n                opt.mtimeCache.set(String(h.path), h.mtime);\n            }\n        }\n        threw = false;\n        streamSync(opt, p, position, fd, files);\n    }\n    finally {\n        if (threw) {\n            try {\n                node_fs_1.default.closeSync(fd);\n            }\n            catch (er) { }\n        }\n    }\n};\nconst streamSync = (opt, p, position, fd, files) => {\n    const stream = new fs_minipass_1.WriteStreamSync(opt.file, {\n        fd: fd,\n        start: position,\n    });\n    p.pipe(stream);\n    addFilesSync(p, files);\n};\nconst replaceAsync = (opt, files) => {\n    files = Array.from(files);\n    const p = new pack_js_1.Pack(opt);\n    const getPos = (fd, size, cb_) => {\n        const cb = (er, pos) => {\n            if (er) {\n                node_fs_1.default.close(fd, _ => cb_(er));\n            }\n            else {\n                cb_(null, pos);\n            }\n        };\n        let position = 0;\n        if (size === 0) {\n            return cb(null, 0);\n        }\n        let bufPos = 0;\n        const headBuf = Buffer.alloc(512);\n        const onread = (er, bytes) => {\n            if (er || typeof bytes === 'undefined') {\n                return cb(er);\n            }\n            bufPos += bytes;\n            if (bufPos < 512 && bytes) {\n                return node_fs_1.default.read(fd, headBuf, bufPos, headBuf.length - bufPos, position + bufPos, onread);\n            }\n            if (position === 0 &&\n                headBuf[0] === 0x1f &&\n                headBuf[1] === 0x8b) {\n                return cb(new Error('cannot append to compressed archives'));\n            }\n            // truncated header\n            if (bufPos < 512) {\n                return cb(null, position);\n            }\n            const h = new header_js_1.Header(headBuf);\n            if (!h.cksumValid) {\n                return cb(null, position);\n            }\n            /* c8 ignore next */\n            const entryBlockSize = 512 * Math.ceil((h.size ?? 0) / 512);\n            if (position + entryBlockSize + 512 > size) {\n                return cb(null, position);\n            }\n            position += entryBlockSize + 512;\n            if (position >= size) {\n                return cb(null, position);\n            }\n            if (opt.mtimeCache && h.mtime) {\n                opt.mtimeCache.set(String(h.path), h.mtime);\n            }\n            bufPos = 0;\n            node_fs_1.default.read(fd, headBuf, 0, 512, position, onread);\n        };\n        node_fs_1.default.read(fd, headBuf, 0, 512, position, onread);\n    };\n    const promise = new Promise((resolve, reject) => {\n        p.on('error', reject);\n        let flag = 'r+';\n        const onopen = (er, fd) => {\n            if (er && er.code === 'ENOENT' && flag === 'r+') {\n                flag = 'w+';\n                return node_fs_1.default.open(opt.file, flag, onopen);\n            }\n            if (er || !fd) {\n                return reject(er);\n            }\n            node_fs_1.default.fstat(fd, (er, st) => {\n                if (er) {\n                    return node_fs_1.default.close(fd, () => reject(er));\n                }\n                getPos(fd, st.size, (er, position) => {\n                    if (er) {\n                        return reject(er);\n                    }\n                    const stream = new fs_minipass_1.WriteStream(opt.file, {\n                        fd: fd,\n                        start: position,\n                    });\n                    p.pipe(stream);\n                    stream.on('error', reject);\n                    stream.on('close', resolve);\n                    addFilesAsync(p, files);\n                });\n            });\n        };\n        node_fs_1.default.open(opt.file, flag, onopen);\n    });\n    return promise;\n};\nconst addFilesSync = (p, files) => {\n    files.forEach(file => {\n        if (file.charAt(0) === '@') {\n            (0, list_js_1.list)({\n                file: node_path_1.default.resolve(p.cwd, file.slice(1)),\n                sync: true,\n                noResume: true,\n                onReadEntry: entry => p.add(entry),\n            });\n        }\n        else {\n            p.add(file);\n        }\n    });\n    p.end();\n};\nconst addFilesAsync = async (p, files) => {\n    for (let i = 0; i < files.length; i++) {\n        const file = String(files[i]);\n        if (file.charAt(0) === '@') {\n            await (0, list_js_1.list)({\n                file: node_path_1.default.resolve(String(p.cwd), file.slice(1)),\n                noResume: true,\n                onReadEntry: entry => p.add(entry),\n            });\n        }\n        else {\n            p.add(file);\n        }\n    }\n    p.end();\n};\nexports.replace = (0, make_command_js_1.makeCommand)(replaceSync, replaceAsync, \n/* c8 ignore start */\n() => {\n    throw new TypeError('file is required');\n}, () => {\n    throw new TypeError('file is required');\n}, \n/* c8 ignore stop */\n(opt, entries) => {\n    if (!(0, options_js_1.isFile)(opt)) {\n        throw new TypeError('file is required');\n    }\n    if (opt.gzip ||\n        opt.brotli ||\n        opt.file.endsWith('.br') ||\n        opt.file.endsWith('.tbr')) {\n        throw new TypeError('cannot append to compressed archives');\n    }\n    if (!entries?.length) {\n        throw new TypeError('no paths specified to add/replace');\n    }\n});\n//# sourceMappingURL=replace.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.stripAbsolutePath = void 0;\n// unix absolute paths are also absolute on win32, so we use this for both\nconst node_path_1 = require(\"node:path\");\nconst { isAbsolute, parse } = node_path_1.win32;\n// returns [root, stripped]\n// Note that windows will think that //x/y/z/a has a \"root\" of //x/y, and in\n// those cases, we want to sanitize it to x/y/z/a, not z/a, so we strip /\n// explicitly if it's the first character.\n// drive-specific relative paths on Windows get their root stripped off even\n// though they are not absolute, so `c:../foo` becomes ['c:', '../foo']\nconst stripAbsolutePath = (path) => {\n    let r = '';\n    let parsed = parse(path);\n    while (isAbsolute(path) || parsed.root) {\n        // windows will think that //x/y/z has a \"root\" of //x/y/\n        // but strip the //?/C:/ off of //?/C:/path\n        const root = path.charAt(0) === '/' && path.slice(0, 4) !== '//?/' ?\n            '/'\n            : parsed.root;\n        path = path.slice(root.length);\n        r += root;\n        parsed = parse(path);\n    }\n    return [r, path];\n};\nexports.stripAbsolutePath = stripAbsolutePath;\n//# sourceMappingURL=strip-absolute-path.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.stripTrailingSlashes = void 0;\n// warning: extremely hot code path.\n// This has been meticulously optimized for use\n// within npm install on large package trees.\n// Do not edit without careful benchmarking.\nconst stripTrailingSlashes = (str) => {\n    let i = str.length - 1;\n    let slashesStart = -1;\n    while (i > -1 && str.charAt(i) === '/') {\n        slashesStart = i;\n        i--;\n    }\n    return slashesStart === -1 ? str : str.slice(0, slashesStart);\n};\nexports.stripTrailingSlashes = stripTrailingSlashes;\n//# sourceMappingURL=strip-trailing-slashes.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SymlinkError = void 0;\nclass SymlinkError extends Error {\n    path;\n    symlink;\n    syscall = 'symlink';\n    code = 'TAR_SYMLINK_ERROR';\n    constructor(symlink, path) {\n        super('TAR_SYMLINK_ERROR: Cannot extract through symbolic link');\n        this.symlink = symlink;\n        this.path = path;\n    }\n    get name() {\n        return 'SymlinkError';\n    }\n}\nexports.SymlinkError = SymlinkError;\n//# sourceMappingURL=symlink-error.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.code = exports.name = exports.isName = exports.isCode = void 0;\nconst isCode = (c) => exports.name.has(c);\nexports.isCode = isCode;\nconst isName = (c) => exports.code.has(c);\nexports.isName = isName;\n// map types from key to human-friendly name\nexports.name = new Map([\n    ['0', 'File'],\n    // same as File\n    ['', 'OldFile'],\n    ['1', 'Link'],\n    ['2', 'SymbolicLink'],\n    // Devices and FIFOs aren't fully supported\n    // they are parsed, but skipped when unpacking\n    ['3', 'CharacterDevice'],\n    ['4', 'BlockDevice'],\n    ['5', 'Directory'],\n    ['6', 'FIFO'],\n    // same as File\n    ['7', 'ContiguousFile'],\n    // pax headers\n    ['g', 'GlobalExtendedHeader'],\n    ['x', 'ExtendedHeader'],\n    // vendor-specific stuff\n    // skip\n    ['A', 'SolarisACL'],\n    // like 5, but with data, which should be skipped\n    ['D', 'GNUDumpDir'],\n    // metadata only, skip\n    ['I', 'Inode'],\n    // data = link path of next file\n    ['K', 'NextFileHasLongLinkpath'],\n    // data = path of next file\n    ['L', 'NextFileHasLongPath'],\n    // skip\n    ['M', 'ContinuationFile'],\n    // like L\n    ['N', 'OldGnuLongPath'],\n    // skip\n    ['S', 'SparseFile'],\n    // skip\n    ['V', 'TapeVolumeHeader'],\n    // like x\n    ['X', 'OldExtendedHeader'],\n]);\n// map the other direction\nexports.code = new Map(Array.from(exports.name).map(kv => [kv[1], kv[0]]));\n//# sourceMappingURL=types.js.map","\"use strict\";\n// the PEND/UNPEND stuff tracks whether we're ready to emit end/close yet.\n// but the path reservations are required to avoid race conditions where\n// parallelized unpack ops may mess with one another, due to dependencies\n// (like a Link depending on its target) or destructive operations (like\n// clobbering an fs object to create one of a different type.)\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.UnpackSync = exports.Unpack = void 0;\nconst fsm = __importStar(require(\"@isaacs/fs-minipass\"));\nconst node_assert_1 = __importDefault(require(\"node:assert\"));\nconst node_crypto_1 = require(\"node:crypto\");\nconst node_fs_1 = __importDefault(require(\"node:fs\"));\nconst node_path_1 = __importDefault(require(\"node:path\"));\nconst get_write_flag_js_1 = require(\"./get-write-flag.js\");\nconst mkdir_js_1 = require(\"./mkdir.js\");\nconst normalize_unicode_js_1 = require(\"./normalize-unicode.js\");\nconst normalize_windows_path_js_1 = require(\"./normalize-windows-path.js\");\nconst parse_js_1 = require(\"./parse.js\");\nconst strip_absolute_path_js_1 = require(\"./strip-absolute-path.js\");\nconst strip_trailing_slashes_js_1 = require(\"./strip-trailing-slashes.js\");\nconst wc = __importStar(require(\"./winchars.js\"));\nconst path_reservations_js_1 = require(\"./path-reservations.js\");\nconst ONENTRY = Symbol('onEntry');\nconst CHECKFS = Symbol('checkFs');\nconst CHECKFS2 = Symbol('checkFs2');\nconst PRUNECACHE = Symbol('pruneCache');\nconst ISREUSABLE = Symbol('isReusable');\nconst MAKEFS = Symbol('makeFs');\nconst FILE = Symbol('file');\nconst DIRECTORY = Symbol('directory');\nconst LINK = Symbol('link');\nconst SYMLINK = Symbol('symlink');\nconst HARDLINK = Symbol('hardlink');\nconst UNSUPPORTED = Symbol('unsupported');\nconst CHECKPATH = Symbol('checkPath');\nconst MKDIR = Symbol('mkdir');\nconst ONERROR = Symbol('onError');\nconst PENDING = Symbol('pending');\nconst PEND = Symbol('pend');\nconst UNPEND = Symbol('unpend');\nconst ENDED = Symbol('ended');\nconst MAYBECLOSE = Symbol('maybeClose');\nconst SKIP = Symbol('skip');\nconst DOCHOWN = Symbol('doChown');\nconst UID = Symbol('uid');\nconst GID = Symbol('gid');\nconst CHECKED_CWD = Symbol('checkedCwd');\nconst platform = process.env.TESTING_TAR_FAKE_PLATFORM || process.platform;\nconst isWindows = platform === 'win32';\nconst DEFAULT_MAX_DEPTH = 1024;\n// Unlinks on Windows are not atomic.\n//\n// This means that if you have a file entry, followed by another\n// file entry with an identical name, and you cannot re-use the file\n// (because it's a hardlink, or because unlink:true is set, or it's\n// Windows, which does not have useful nlink values), then the unlink\n// will be committed to the disk AFTER the new file has been written\n// over the old one, deleting the new file.\n//\n// To work around this, on Windows systems, we rename the file and then\n// delete the renamed file.  It's a sloppy kludge, but frankly, I do not\n// know of a better way to do this, given windows' non-atomic unlink\n// semantics.\n//\n// See: https://github.com/npm/node-tar/issues/183\n/* c8 ignore start */\nconst unlinkFile = (path, cb) => {\n    if (!isWindows) {\n        return node_fs_1.default.unlink(path, cb);\n    }\n    const name = path + '.DELETE.' + (0, node_crypto_1.randomBytes)(16).toString('hex');\n    node_fs_1.default.rename(path, name, er => {\n        if (er) {\n            return cb(er);\n        }\n        node_fs_1.default.unlink(name, cb);\n    });\n};\n/* c8 ignore stop */\n/* c8 ignore start */\nconst unlinkFileSync = (path) => {\n    if (!isWindows) {\n        return node_fs_1.default.unlinkSync(path);\n    }\n    const name = path + '.DELETE.' + (0, node_crypto_1.randomBytes)(16).toString('hex');\n    node_fs_1.default.renameSync(path, name);\n    node_fs_1.default.unlinkSync(name);\n};\n/* c8 ignore stop */\n// this.gid, entry.gid, this.processUid\nconst uint32 = (a, b, c) => a !== undefined && a === a >>> 0 ? a\n    : b !== undefined && b === b >>> 0 ? b\n        : c;\n// clear the cache if it's a case-insensitive unicode-squashing match.\n// we can't know if the current file system is case-sensitive or supports\n// unicode fully, so we check for similarity on the maximally compatible\n// representation.  Err on the side of pruning, since all it's doing is\n// preventing lstats, and it's not the end of the world if we get a false\n// positive.\n// Note that on windows, we always drop the entire cache whenever a\n// symbolic link is encountered, because 8.3 filenames are impossible\n// to reason about, and collisions are hazards rather than just failures.\nconst cacheKeyNormalize = (path) => (0, strip_trailing_slashes_js_1.stripTrailingSlashes)((0, normalize_windows_path_js_1.normalizeWindowsPath)((0, normalize_unicode_js_1.normalizeUnicode)(path))).toLowerCase();\n// remove all cache entries matching ${abs}/**\nconst pruneCache = (cache, abs) => {\n    abs = cacheKeyNormalize(abs);\n    for (const path of cache.keys()) {\n        const pnorm = cacheKeyNormalize(path);\n        if (pnorm === abs || pnorm.indexOf(abs + '/') === 0) {\n            cache.delete(path);\n        }\n    }\n};\nconst dropCache = (cache) => {\n    for (const key of cache.keys()) {\n        cache.delete(key);\n    }\n};\nclass Unpack extends parse_js_1.Parser {\n    [ENDED] = false;\n    [CHECKED_CWD] = false;\n    [PENDING] = 0;\n    reservations = new path_reservations_js_1.PathReservations();\n    transform;\n    writable = true;\n    readable = false;\n    dirCache;\n    uid;\n    gid;\n    setOwner;\n    preserveOwner;\n    processGid;\n    processUid;\n    maxDepth;\n    forceChown;\n    win32;\n    newer;\n    keep;\n    noMtime;\n    preservePaths;\n    unlink;\n    cwd;\n    strip;\n    processUmask;\n    umask;\n    dmode;\n    fmode;\n    chmod;\n    constructor(opt = {}) {\n        opt.ondone = () => {\n            this[ENDED] = true;\n            this[MAYBECLOSE]();\n        };\n        super(opt);\n        this.transform = opt.transform;\n        this.dirCache = opt.dirCache || new Map();\n        this.chmod = !!opt.chmod;\n        if (typeof opt.uid === 'number' || typeof opt.gid === 'number') {\n            // need both or neither\n            if (typeof opt.uid !== 'number' ||\n                typeof opt.gid !== 'number') {\n                throw new TypeError('cannot set owner without number uid and gid');\n            }\n            if (opt.preserveOwner) {\n                throw new TypeError('cannot preserve owner in archive and also set owner explicitly');\n            }\n            this.uid = opt.uid;\n            this.gid = opt.gid;\n            this.setOwner = true;\n        }\n        else {\n            this.uid = undefined;\n            this.gid = undefined;\n            this.setOwner = false;\n        }\n        // default true for root\n        if (opt.preserveOwner === undefined &&\n            typeof opt.uid !== 'number') {\n            this.preserveOwner = !!(process.getuid && process.getuid() === 0);\n        }\n        else {\n            this.preserveOwner = !!opt.preserveOwner;\n        }\n        this.processUid =\n            (this.preserveOwner || this.setOwner) && process.getuid ?\n                process.getuid()\n                : undefined;\n        this.processGid =\n            (this.preserveOwner || this.setOwner) && process.getgid ?\n                process.getgid()\n                : undefined;\n        // prevent excessively deep nesting of subfolders\n        // set to `Infinity` to remove this restriction\n        this.maxDepth =\n            typeof opt.maxDepth === 'number' ?\n                opt.maxDepth\n                : DEFAULT_MAX_DEPTH;\n        // mostly just for testing, but useful in some cases.\n        // Forcibly trigger a chown on every entry, no matter what\n        this.forceChown = opt.forceChown === true;\n        // turn ><?| in filenames into 0xf000-higher encoded forms\n        this.win32 = !!opt.win32 || isWindows;\n        // do not unpack over files that are newer than what's in the archive\n        this.newer = !!opt.newer;\n        // do not unpack over ANY files\n        this.keep = !!opt.keep;\n        // do not set mtime/atime of extracted entries\n        this.noMtime = !!opt.noMtime;\n        // allow .., absolute path entries, and unpacking through symlinks\n        // without this, warn and skip .., relativize absolutes, and error\n        // on symlinks in extraction path\n        this.preservePaths = !!opt.preservePaths;\n        // unlink files and links before writing. This breaks existing hard\n        // links, and removes symlink directories rather than erroring\n        this.unlink = !!opt.unlink;\n        this.cwd = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.resolve(opt.cwd || process.cwd()));\n        this.strip = Number(opt.strip) || 0;\n        // if we're not chmodding, then we don't need the process umask\n        this.processUmask =\n            !this.chmod ? 0\n                : typeof opt.processUmask === 'number' ? opt.processUmask\n                    : process.umask();\n        this.umask =\n            typeof opt.umask === 'number' ? opt.umask : this.processUmask;\n        // default mode for dirs created as parents\n        this.dmode = opt.dmode || 0o0777 & ~this.umask;\n        this.fmode = opt.fmode || 0o0666 & ~this.umask;\n        this.on('entry', entry => this[ONENTRY](entry));\n    }\n    // a bad or damaged archive is a warning for Parser, but an error\n    // when extracting.  Mark those errors as unrecoverable, because\n    // the Unpack contract cannot be met.\n    warn(code, msg, data = {}) {\n        if (code === 'TAR_BAD_ARCHIVE' || code === 'TAR_ABORT') {\n            data.recoverable = false;\n        }\n        return super.warn(code, msg, data);\n    }\n    [MAYBECLOSE]() {\n        if (this[ENDED] && this[PENDING] === 0) {\n            this.emit('prefinish');\n            this.emit('finish');\n            this.emit('end');\n        }\n    }\n    [CHECKPATH](entry) {\n        const p = (0, normalize_windows_path_js_1.normalizeWindowsPath)(entry.path);\n        const parts = p.split('/');\n        if (this.strip) {\n            if (parts.length < this.strip) {\n                return false;\n            }\n            if (entry.type === 'Link') {\n                const linkparts = (0, normalize_windows_path_js_1.normalizeWindowsPath)(String(entry.linkpath)).split('/');\n                if (linkparts.length >= this.strip) {\n                    entry.linkpath = linkparts.slice(this.strip).join('/');\n                }\n                else {\n                    return false;\n                }\n            }\n            parts.splice(0, this.strip);\n            entry.path = parts.join('/');\n        }\n        if (isFinite(this.maxDepth) && parts.length > this.maxDepth) {\n            this.warn('TAR_ENTRY_ERROR', 'path excessively deep', {\n                entry,\n                path: p,\n                depth: parts.length,\n                maxDepth: this.maxDepth,\n            });\n            return false;\n        }\n        if (!this.preservePaths) {\n            if (parts.includes('..') ||\n                /* c8 ignore next */\n                (isWindows && /^[a-z]:\\.\\.$/i.test(parts[0] ?? ''))) {\n                this.warn('TAR_ENTRY_ERROR', `path contains '..'`, {\n                    entry,\n                    path: p,\n                });\n                return false;\n            }\n            // strip off the root\n            const [root, stripped] = (0, strip_absolute_path_js_1.stripAbsolutePath)(p);\n            if (root) {\n                entry.path = String(stripped);\n                this.warn('TAR_ENTRY_INFO', `stripping ${root} from absolute path`, {\n                    entry,\n                    path: p,\n                });\n            }\n        }\n        if (node_path_1.default.isAbsolute(entry.path)) {\n            entry.absolute = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.resolve(entry.path));\n        }\n        else {\n            entry.absolute = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.resolve(this.cwd, entry.path));\n        }\n        // if we somehow ended up with a path that escapes the cwd, and we are\n        // not in preservePaths mode, then something is fishy!  This should have\n        // been prevented above, so ignore this for coverage.\n        /* c8 ignore start - defense in depth */\n        if (!this.preservePaths &&\n            typeof entry.absolute === 'string' &&\n            entry.absolute.indexOf(this.cwd + '/') !== 0 &&\n            entry.absolute !== this.cwd) {\n            this.warn('TAR_ENTRY_ERROR', 'path escaped extraction target', {\n                entry,\n                path: (0, normalize_windows_path_js_1.normalizeWindowsPath)(entry.path),\n                resolvedPath: entry.absolute,\n                cwd: this.cwd,\n            });\n            return false;\n        }\n        /* c8 ignore stop */\n        // an archive can set properties on the extraction directory, but it\n        // may not replace the cwd with a different kind of thing entirely.\n        if (entry.absolute === this.cwd &&\n            entry.type !== 'Directory' &&\n            entry.type !== 'GNUDumpDir') {\n            return false;\n        }\n        // only encode : chars that aren't drive letter indicators\n        if (this.win32) {\n            const { root: aRoot } = node_path_1.default.win32.parse(String(entry.absolute));\n            entry.absolute =\n                aRoot + wc.encode(String(entry.absolute).slice(aRoot.length));\n            const { root: pRoot } = node_path_1.default.win32.parse(entry.path);\n            entry.path = pRoot + wc.encode(entry.path.slice(pRoot.length));\n        }\n        return true;\n    }\n    [ONENTRY](entry) {\n        if (!this[CHECKPATH](entry)) {\n            return entry.resume();\n        }\n        node_assert_1.default.equal(typeof entry.absolute, 'string');\n        switch (entry.type) {\n            case 'Directory':\n            case 'GNUDumpDir':\n                if (entry.mode) {\n                    entry.mode = entry.mode | 0o700;\n                }\n            // eslint-disable-next-line no-fallthrough\n            case 'File':\n            case 'OldFile':\n            case 'ContiguousFile':\n            case 'Link':\n            case 'SymbolicLink':\n                return this[CHECKFS](entry);\n            case 'CharacterDevice':\n            case 'BlockDevice':\n            case 'FIFO':\n            default:\n                return this[UNSUPPORTED](entry);\n        }\n    }\n    [ONERROR](er, entry) {\n        // Cwd has to exist, or else nothing works. That's serious.\n        // Other errors are warnings, which raise the error in strict\n        // mode, but otherwise continue on.\n        if (er.name === 'CwdError') {\n            this.emit('error', er);\n        }\n        else {\n            this.warn('TAR_ENTRY_ERROR', er, { entry });\n            this[UNPEND]();\n            entry.resume();\n        }\n    }\n    [MKDIR](dir, mode, cb) {\n        (0, mkdir_js_1.mkdir)((0, normalize_windows_path_js_1.normalizeWindowsPath)(dir), {\n            uid: this.uid,\n            gid: this.gid,\n            processUid: this.processUid,\n            processGid: this.processGid,\n            umask: this.processUmask,\n            preserve: this.preservePaths,\n            unlink: this.unlink,\n            cache: this.dirCache,\n            cwd: this.cwd,\n            mode: mode,\n        }, cb);\n    }\n    [DOCHOWN](entry) {\n        // in preserve owner mode, chown if the entry doesn't match process\n        // in set owner mode, chown if setting doesn't match process\n        return (this.forceChown ||\n            (this.preserveOwner &&\n                ((typeof entry.uid === 'number' &&\n                    entry.uid !== this.processUid) ||\n                    (typeof entry.gid === 'number' &&\n                        entry.gid !== this.processGid))) ||\n            (typeof this.uid === 'number' &&\n                this.uid !== this.processUid) ||\n            (typeof this.gid === 'number' && this.gid !== this.processGid));\n    }\n    [UID](entry) {\n        return uint32(this.uid, entry.uid, this.processUid);\n    }\n    [GID](entry) {\n        return uint32(this.gid, entry.gid, this.processGid);\n    }\n    [FILE](entry, fullyDone) {\n        const mode = typeof entry.mode === 'number' ?\n            entry.mode & 0o7777\n            : this.fmode;\n        const stream = new fsm.WriteStream(String(entry.absolute), {\n            // slight lie, but it can be numeric flags\n            flags: (0, get_write_flag_js_1.getWriteFlag)(entry.size),\n            mode: mode,\n            autoClose: false,\n        });\n        stream.on('error', (er) => {\n            if (stream.fd) {\n                node_fs_1.default.close(stream.fd, () => { });\n            }\n            // flush all the data out so that we aren't left hanging\n            // if the error wasn't actually fatal.  otherwise the parse\n            // is blocked, and we never proceed.\n            stream.write = () => true;\n            this[ONERROR](er, entry);\n            fullyDone();\n        });\n        let actions = 1;\n        const done = (er) => {\n            if (er) {\n                /* c8 ignore start - we should always have a fd by now */\n                if (stream.fd) {\n                    node_fs_1.default.close(stream.fd, () => { });\n                }\n                /* c8 ignore stop */\n                this[ONERROR](er, entry);\n                fullyDone();\n                return;\n            }\n            if (--actions === 0) {\n                if (stream.fd !== undefined) {\n                    node_fs_1.default.close(stream.fd, er => {\n                        if (er) {\n                            this[ONERROR](er, entry);\n                        }\n                        else {\n                            this[UNPEND]();\n                        }\n                        fullyDone();\n                    });\n                }\n            }\n        };\n        stream.on('finish', () => {\n            // if futimes fails, try utimes\n            // if utimes fails, fail with the original error\n            // same for fchown/chown\n            const abs = String(entry.absolute);\n            const fd = stream.fd;\n            if (typeof fd === 'number' && entry.mtime && !this.noMtime) {\n                actions++;\n                const atime = entry.atime || new Date();\n                const mtime = entry.mtime;\n                node_fs_1.default.futimes(fd, atime, mtime, er => er ?\n                    node_fs_1.default.utimes(abs, atime, mtime, er2 => done(er2 && er))\n                    : done());\n            }\n            if (typeof fd === 'number' && this[DOCHOWN](entry)) {\n                actions++;\n                const uid = this[UID](entry);\n                const gid = this[GID](entry);\n                if (typeof uid === 'number' && typeof gid === 'number') {\n                    node_fs_1.default.fchown(fd, uid, gid, er => er ?\n                        node_fs_1.default.chown(abs, uid, gid, er2 => done(er2 && er))\n                        : done());\n                }\n            }\n            done();\n        });\n        const tx = this.transform ? this.transform(entry) || entry : entry;\n        if (tx !== entry) {\n            tx.on('error', (er) => {\n                this[ONERROR](er, entry);\n                fullyDone();\n            });\n            entry.pipe(tx);\n        }\n        tx.pipe(stream);\n    }\n    [DIRECTORY](entry, fullyDone) {\n        const mode = typeof entry.mode === 'number' ?\n            entry.mode & 0o7777\n            : this.dmode;\n        this[MKDIR](String(entry.absolute), mode, er => {\n            if (er) {\n                this[ONERROR](er, entry);\n                fullyDone();\n                return;\n            }\n            let actions = 1;\n            const done = () => {\n                if (--actions === 0) {\n                    fullyDone();\n                    this[UNPEND]();\n                    entry.resume();\n                }\n            };\n            if (entry.mtime && !this.noMtime) {\n                actions++;\n                node_fs_1.default.utimes(String(entry.absolute), entry.atime || new Date(), entry.mtime, done);\n            }\n            if (this[DOCHOWN](entry)) {\n                actions++;\n                node_fs_1.default.chown(String(entry.absolute), Number(this[UID](entry)), Number(this[GID](entry)), done);\n            }\n            done();\n        });\n    }\n    [UNSUPPORTED](entry) {\n        entry.unsupported = true;\n        this.warn('TAR_ENTRY_UNSUPPORTED', `unsupported entry type: ${entry.type}`, { entry });\n        entry.resume();\n    }\n    [SYMLINK](entry, done) {\n        this[LINK](entry, String(entry.linkpath), 'symlink', done);\n    }\n    [HARDLINK](entry, done) {\n        const linkpath = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.resolve(this.cwd, String(entry.linkpath)));\n        this[LINK](entry, linkpath, 'link', done);\n    }\n    [PEND]() {\n        this[PENDING]++;\n    }\n    [UNPEND]() {\n        this[PENDING]--;\n        this[MAYBECLOSE]();\n    }\n    [SKIP](entry) {\n        this[UNPEND]();\n        entry.resume();\n    }\n    // Check if we can reuse an existing filesystem entry safely and\n    // overwrite it, rather than unlinking and recreating\n    // Windows doesn't report a useful nlink, so we just never reuse entries\n    [ISREUSABLE](entry, st) {\n        return (entry.type === 'File' &&\n            !this.unlink &&\n            st.isFile() &&\n            st.nlink <= 1 &&\n            !isWindows);\n    }\n    // check if a thing is there, and if so, try to clobber it\n    [CHECKFS](entry) {\n        this[PEND]();\n        const paths = [entry.path];\n        if (entry.linkpath) {\n            paths.push(entry.linkpath);\n        }\n        this.reservations.reserve(paths, done => this[CHECKFS2](entry, done));\n    }\n    [PRUNECACHE](entry) {\n        // if we are not creating a directory, and the path is in the dirCache,\n        // then that means we are about to delete the directory we created\n        // previously, and it is no longer going to be a directory, and neither\n        // is any of its children.\n        // If a symbolic link is encountered, all bets are off.  There is no\n        // reasonable way to sanitize the cache in such a way we will be able to\n        // avoid having filesystem collisions.  If this happens with a non-symlink\n        // entry, it'll just fail to unpack, but a symlink to a directory, using an\n        // 8.3 shortname or certain unicode attacks, can evade detection and lead\n        // to arbitrary writes to anywhere on the system.\n        if (entry.type === 'SymbolicLink') {\n            dropCache(this.dirCache);\n        }\n        else if (entry.type !== 'Directory') {\n            pruneCache(this.dirCache, String(entry.absolute));\n        }\n    }\n    [CHECKFS2](entry, fullyDone) {\n        this[PRUNECACHE](entry);\n        const done = (er) => {\n            this[PRUNECACHE](entry);\n            fullyDone(er);\n        };\n        const checkCwd = () => {\n            this[MKDIR](this.cwd, this.dmode, er => {\n                if (er) {\n                    this[ONERROR](er, entry);\n                    done();\n                    return;\n                }\n                this[CHECKED_CWD] = true;\n                start();\n            });\n        };\n        const start = () => {\n            if (entry.absolute !== this.cwd) {\n                const parent = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.dirname(String(entry.absolute)));\n                if (parent !== this.cwd) {\n                    return this[MKDIR](parent, this.dmode, er => {\n                        if (er) {\n                            this[ONERROR](er, entry);\n                            done();\n                            return;\n                        }\n                        afterMakeParent();\n                    });\n                }\n            }\n            afterMakeParent();\n        };\n        const afterMakeParent = () => {\n            node_fs_1.default.lstat(String(entry.absolute), (lstatEr, st) => {\n                if (st &&\n                    (this.keep ||\n                        /* c8 ignore next */\n                        (this.newer && st.mtime > (entry.mtime ?? st.mtime)))) {\n                    this[SKIP](entry);\n                    done();\n                    return;\n                }\n                if (lstatEr || this[ISREUSABLE](entry, st)) {\n                    return this[MAKEFS](null, entry, done);\n                }\n                if (st.isDirectory()) {\n                    if (entry.type === 'Directory') {\n                        const needChmod = this.chmod &&\n                            entry.mode &&\n                            (st.mode & 0o7777) !== entry.mode;\n                        const afterChmod = (er) => this[MAKEFS](er ?? null, entry, done);\n                        if (!needChmod) {\n                            return afterChmod();\n                        }\n                        return node_fs_1.default.chmod(String(entry.absolute), Number(entry.mode), afterChmod);\n                    }\n                    // Not a dir entry, have to remove it.\n                    // NB: the only way to end up with an entry that is the cwd\n                    // itself, in such a way that == does not detect, is a\n                    // tricky windows absolute path with UNC or 8.3 parts (and\n                    // preservePaths:true, or else it will have been stripped).\n                    // In that case, the user has opted out of path protections\n                    // explicitly, so if they blow away the cwd, c'est la vie.\n                    if (entry.absolute !== this.cwd) {\n                        return node_fs_1.default.rmdir(String(entry.absolute), (er) => this[MAKEFS](er ?? null, entry, done));\n                    }\n                }\n                // not a dir, and not reusable\n                // don't remove if the cwd, we want that error\n                if (entry.absolute === this.cwd) {\n                    return this[MAKEFS](null, entry, done);\n                }\n                unlinkFile(String(entry.absolute), er => this[MAKEFS](er ?? null, entry, done));\n            });\n        };\n        if (this[CHECKED_CWD]) {\n            start();\n        }\n        else {\n            checkCwd();\n        }\n    }\n    [MAKEFS](er, entry, done) {\n        if (er) {\n            this[ONERROR](er, entry);\n            done();\n            return;\n        }\n        switch (entry.type) {\n            case 'File':\n            case 'OldFile':\n            case 'ContiguousFile':\n                return this[FILE](entry, done);\n            case 'Link':\n                return this[HARDLINK](entry, done);\n            case 'SymbolicLink':\n                return this[SYMLINK](entry, done);\n            case 'Directory':\n            case 'GNUDumpDir':\n                return this[DIRECTORY](entry, done);\n        }\n    }\n    [LINK](entry, linkpath, link, done) {\n        // XXX: get the type ('symlink' or 'junction') for windows\n        node_fs_1.default[link](linkpath, String(entry.absolute), er => {\n            if (er) {\n                this[ONERROR](er, entry);\n            }\n            else {\n                this[UNPEND]();\n                entry.resume();\n            }\n            done();\n        });\n    }\n}\nexports.Unpack = Unpack;\nconst callSync = (fn) => {\n    try {\n        return [null, fn()];\n    }\n    catch (er) {\n        return [er, null];\n    }\n};\nclass UnpackSync extends Unpack {\n    sync = true;\n    [MAKEFS](er, entry) {\n        return super[MAKEFS](er, entry, () => { });\n    }\n    [CHECKFS](entry) {\n        this[PRUNECACHE](entry);\n        if (!this[CHECKED_CWD]) {\n            const er = this[MKDIR](this.cwd, this.dmode);\n            if (er) {\n                return this[ONERROR](er, entry);\n            }\n            this[CHECKED_CWD] = true;\n        }\n        // don't bother to make the parent if the current entry is the cwd,\n        // we've already checked it.\n        if (entry.absolute !== this.cwd) {\n            const parent = (0, normalize_windows_path_js_1.normalizeWindowsPath)(node_path_1.default.dirname(String(entry.absolute)));\n            if (parent !== this.cwd) {\n                const mkParent = this[MKDIR](parent, this.dmode);\n                if (mkParent) {\n                    return this[ONERROR](mkParent, entry);\n                }\n            }\n        }\n        const [lstatEr, st] = callSync(() => node_fs_1.default.lstatSync(String(entry.absolute)));\n        if (st &&\n            (this.keep ||\n                /* c8 ignore next */\n                (this.newer && st.mtime > (entry.mtime ?? st.mtime)))) {\n            return this[SKIP](entry);\n        }\n        if (lstatEr || this[ISREUSABLE](entry, st)) {\n            return this[MAKEFS](null, entry);\n        }\n        if (st.isDirectory()) {\n            if (entry.type === 'Directory') {\n                const needChmod = this.chmod &&\n                    entry.mode &&\n                    (st.mode & 0o7777) !== entry.mode;\n                const [er] = needChmod ?\n                    callSync(() => {\n                        node_fs_1.default.chmodSync(String(entry.absolute), Number(entry.mode));\n                    })\n                    : [];\n                return this[MAKEFS](er, entry);\n            }\n            // not a dir entry, have to remove it\n            const [er] = callSync(() => node_fs_1.default.rmdirSync(String(entry.absolute)));\n            this[MAKEFS](er, entry);\n        }\n        // not a dir, and not reusable.\n        // don't remove if it's the cwd, since we want that error.\n        const [er] = entry.absolute === this.cwd ?\n            []\n            : callSync(() => unlinkFileSync(String(entry.absolute)));\n        this[MAKEFS](er, entry);\n    }\n    [FILE](entry, done) {\n        const mode = typeof entry.mode === 'number' ?\n            entry.mode & 0o7777\n            : this.fmode;\n        const oner = (er) => {\n            let closeError;\n            try {\n                node_fs_1.default.closeSync(fd);\n            }\n            catch (e) {\n                closeError = e;\n            }\n            if (er || closeError) {\n                this[ONERROR](er || closeError, entry);\n            }\n            done();\n        };\n        let fd;\n        try {\n            fd = node_fs_1.default.openSync(String(entry.absolute), (0, get_write_flag_js_1.getWriteFlag)(entry.size), mode);\n        }\n        catch (er) {\n            return oner(er);\n        }\n        const tx = this.transform ? this.transform(entry) || entry : entry;\n        if (tx !== entry) {\n            tx.on('error', (er) => this[ONERROR](er, entry));\n            entry.pipe(tx);\n        }\n        tx.on('data', (chunk) => {\n            try {\n                node_fs_1.default.writeSync(fd, chunk, 0, chunk.length);\n            }\n            catch (er) {\n                oner(er);\n            }\n        });\n        tx.on('end', () => {\n            let er = null;\n            // try both, falling futimes back to utimes\n            // if either fails, handle the first error\n            if (entry.mtime && !this.noMtime) {\n                const atime = entry.atime || new Date();\n                const mtime = entry.mtime;\n                try {\n                    node_fs_1.default.futimesSync(fd, atime, mtime);\n                }\n                catch (futimeser) {\n                    try {\n                        node_fs_1.default.utimesSync(String(entry.absolute), atime, mtime);\n                    }\n                    catch (utimeser) {\n                        er = futimeser;\n                    }\n                }\n            }\n            if (this[DOCHOWN](entry)) {\n                const uid = this[UID](entry);\n                const gid = this[GID](entry);\n                try {\n                    node_fs_1.default.fchownSync(fd, Number(uid), Number(gid));\n                }\n                catch (fchowner) {\n                    try {\n                        node_fs_1.default.chownSync(String(entry.absolute), Number(uid), Number(gid));\n                    }\n                    catch (chowner) {\n                        er = er || fchowner;\n                    }\n                }\n            }\n            oner(er);\n        });\n    }\n    [DIRECTORY](entry, done) {\n        const mode = typeof entry.mode === 'number' ?\n            entry.mode & 0o7777\n            : this.dmode;\n        const er = this[MKDIR](String(entry.absolute), mode);\n        if (er) {\n            this[ONERROR](er, entry);\n            done();\n            return;\n        }\n        if (entry.mtime && !this.noMtime) {\n            try {\n                node_fs_1.default.utimesSync(String(entry.absolute), entry.atime || new Date(), entry.mtime);\n                /* c8 ignore next */\n            }\n            catch (er) { }\n        }\n        if (this[DOCHOWN](entry)) {\n            try {\n                node_fs_1.default.chownSync(String(entry.absolute), Number(this[UID](entry)), Number(this[GID](entry)));\n            }\n            catch (er) { }\n        }\n        done();\n        entry.resume();\n    }\n    [MKDIR](dir, mode) {\n        try {\n            return (0, mkdir_js_1.mkdirSync)((0, normalize_windows_path_js_1.normalizeWindowsPath)(dir), {\n                uid: this.uid,\n                gid: this.gid,\n                processUid: this.processUid,\n                processGid: this.processGid,\n                umask: this.processUmask,\n                preserve: this.preservePaths,\n                unlink: this.unlink,\n                cache: this.dirCache,\n                cwd: this.cwd,\n                mode: mode,\n            });\n        }\n        catch (er) {\n            return er;\n        }\n    }\n    [LINK](entry, linkpath, link, done) {\n        const ls = `${link}Sync`;\n        try {\n            node_fs_1.default[ls](linkpath, String(entry.absolute));\n            done();\n            entry.resume();\n        }\n        catch (er) {\n            return this[ONERROR](er, entry);\n        }\n    }\n}\nexports.UnpackSync = UnpackSync;\n//# sourceMappingURL=unpack.js.map","\"use strict\";\n// tar -u\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.update = void 0;\nconst make_command_js_1 = require(\"./make-command.js\");\nconst replace_js_1 = require(\"./replace.js\");\n// just call tar.r with the filter and mtimeCache\nexports.update = (0, make_command_js_1.makeCommand)(replace_js_1.replace.syncFile, replace_js_1.replace.asyncFile, replace_js_1.replace.syncNoFile, replace_js_1.replace.asyncNoFile, (opt, entries = []) => {\n    replace_js_1.replace.validate?.(opt, entries);\n    mtimeFilter(opt);\n});\nconst mtimeFilter = (opt) => {\n    const filter = opt.filter;\n    if (!opt.mtimeCache) {\n        opt.mtimeCache = new Map();\n    }\n    opt.filter =\n        filter ?\n            (path, stat) => filter(path, stat) &&\n                !(\n                /* c8 ignore start */\n                ((opt.mtimeCache?.get(path) ?? stat.mtime ?? 0) >\n                    (stat.mtime ?? 0))\n                /* c8 ignore stop */\n                )\n            : (path, stat) => !(\n            /* c8 ignore start */\n            ((opt.mtimeCache?.get(path) ?? stat.mtime ?? 0) >\n                (stat.mtime ?? 0))\n            /* c8 ignore stop */\n            );\n};\n//# sourceMappingURL=update.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.warnMethod = void 0;\nconst warnMethod = (self, code, message, data = {}) => {\n    if (self.file) {\n        data.file = self.file;\n    }\n    if (self.cwd) {\n        data.cwd = self.cwd;\n    }\n    data.code =\n        (message instanceof Error &&\n            message.code) ||\n            code;\n    data.tarCode = code;\n    if (!self.strict && data.recoverable !== false) {\n        if (message instanceof Error) {\n            data = Object.assign(message, data);\n            message = message.message;\n        }\n        self.emit('warn', code, message, data);\n    }\n    else if (message instanceof Error) {\n        self.emit('error', Object.assign(message, data));\n    }\n    else {\n        self.emit('error', Object.assign(new Error(`${code}: ${message}`), data));\n    }\n};\nexports.warnMethod = warnMethod;\n//# sourceMappingURL=warn-method.js.map","\"use strict\";\n// When writing files on Windows, translate the characters to their\n// 0xf000 higher-encoded versions.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.decode = exports.encode = void 0;\nconst raw = ['|', '<', '>', '?', ':'];\nconst win = raw.map(char => String.fromCharCode(0xf000 + char.charCodeAt(0)));\nconst toWin = new Map(raw.map((char, i) => [char, win[i]]));\nconst toRaw = new Map(win.map((char, i) => [char, raw[i]]));\nconst encode = (s) => raw.reduce((s, c) => s.split(c).join(toWin.get(c)), s);\nexports.encode = encode;\nconst decode = (s) => win.reduce((s, c) => s.split(c).join(toRaw.get(c)), s);\nexports.decode = decode;\n//# sourceMappingURL=winchars.js.map","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    var desc = Object.getOwnPropertyDescriptor(m, k);\n    if (!desc || (\"get\" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n    }\n    Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\n}) : function(o, v) {\n    o[\"default\"] = v;\n});\nvar __importStar = (this && this.__importStar) || function (mod) {\n    if (mod && mod.__esModule) return mod;\n    var result = {};\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\n    __setModuleDefault(result, mod);\n    return result;\n};\nvar __importDefault = (this && this.__importDefault) || function (mod) {\n    return (mod && mod.__esModule) ? mod : { \"default\": mod };\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.WriteEntryTar = exports.WriteEntrySync = exports.WriteEntry = void 0;\nconst fs_1 = __importDefault(require(\"fs\"));\nconst minipass_1 = require(\"minipass\");\nconst path_1 = __importDefault(require(\"path\"));\nconst header_js_1 = require(\"./header.js\");\nconst mode_fix_js_1 = require(\"./mode-fix.js\");\nconst normalize_windows_path_js_1 = require(\"./normalize-windows-path.js\");\nconst options_js_1 = require(\"./options.js\");\nconst pax_js_1 = require(\"./pax.js\");\nconst strip_absolute_path_js_1 = require(\"./strip-absolute-path.js\");\nconst strip_trailing_slashes_js_1 = require(\"./strip-trailing-slashes.js\");\nconst warn_method_js_1 = require(\"./warn-method.js\");\nconst winchars = __importStar(require(\"./winchars.js\"));\nconst prefixPath = (path, prefix) => {\n    if (!prefix) {\n        return (0, normalize_windows_path_js_1.normalizeWindowsPath)(path);\n    }\n    path = (0, normalize_windows_path_js_1.normalizeWindowsPath)(path).replace(/^\\.(\\/|$)/, '');\n    return (0, strip_trailing_slashes_js_1.stripTrailingSlashes)(prefix) + '/' + path;\n};\nconst maxReadSize = 16 * 1024 * 1024;\nconst PROCESS = Symbol('process');\nconst FILE = Symbol('file');\nconst DIRECTORY = Symbol('directory');\nconst SYMLINK = Symbol('symlink');\nconst HARDLINK = Symbol('hardlink');\nconst HEADER = Symbol('header');\nconst READ = Symbol('read');\nconst LSTAT = Symbol('lstat');\nconst ONLSTAT = Symbol('onlstat');\nconst ONREAD = Symbol('onread');\nconst ONREADLINK = Symbol('onreadlink');\nconst OPENFILE = Symbol('openfile');\nconst ONOPENFILE = Symbol('onopenfile');\nconst CLOSE = Symbol('close');\nconst MODE = Symbol('mode');\nconst AWAITDRAIN = Symbol('awaitDrain');\nconst ONDRAIN = Symbol('ondrain');\nconst PREFIX = Symbol('prefix');\nclass WriteEntry extends minipass_1.Minipass {\n    path;\n    portable;\n    myuid = (process.getuid && process.getuid()) || 0;\n    // until node has builtin pwnam functions, this'll have to do\n    myuser = process.env.USER || '';\n    maxReadSize;\n    linkCache;\n    statCache;\n    preservePaths;\n    cwd;\n    strict;\n    mtime;\n    noPax;\n    noMtime;\n    prefix;\n    fd;\n    blockLen = 0;\n    blockRemain = 0;\n    buf;\n    pos = 0;\n    remain = 0;\n    length = 0;\n    offset = 0;\n    win32;\n    absolute;\n    header;\n    type;\n    linkpath;\n    stat;\n    onWriteEntry;\n    #hadError = false;\n    constructor(p, opt_ = {}) {\n        const opt = (0, options_js_1.dealias)(opt_);\n        super();\n        this.path = (0, normalize_windows_path_js_1.normalizeWindowsPath)(p);\n        // suppress atime, ctime, uid, gid, uname, gname\n        this.portable = !!opt.portable;\n        this.maxReadSize = opt.maxReadSize || maxReadSize;\n        this.linkCache = opt.linkCache || new Map();\n        this.statCache = opt.statCache || new Map();\n        this.preservePaths = !!opt.preservePaths;\n        this.cwd = (0, normalize_windows_path_js_1.normalizeWindowsPath)(opt.cwd || process.cwd());\n        this.strict = !!opt.strict;\n        this.noPax = !!opt.noPax;\n        this.noMtime = !!opt.noMtime;\n        this.mtime = opt.mtime;\n        this.prefix =\n            opt.prefix ? (0, normalize_windows_path_js_1.normalizeWindowsPath)(opt.prefix) : undefined;\n        this.onWriteEntry = opt.onWriteEntry;\n        if (typeof opt.onwarn === 'function') {\n            this.on('warn', opt.onwarn);\n        }\n        let pathWarn = false;\n        if (!this.preservePaths) {\n            const [root, stripped] = (0, strip_absolute_path_js_1.stripAbsolutePath)(this.path);\n            if (root && typeof stripped === 'string') {\n                this.path = stripped;\n                pathWarn = root;\n            }\n        }\n        this.win32 = !!opt.win32 || process.platform === 'win32';\n        if (this.win32) {\n            // force the \\ to / normalization, since we might not *actually*\n            // be on windows, but want \\ to be considered a path separator.\n            this.path = winchars.decode(this.path.replace(/\\\\/g, '/'));\n            p = p.replace(/\\\\/g, '/');\n        }\n        this.absolute = (0, normalize_windows_path_js_1.normalizeWindowsPath)(opt.absolute || path_1.default.resolve(this.cwd, p));\n        if (this.path === '') {\n            this.path = './';\n        }\n        if (pathWarn) {\n            this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n                entry: this,\n                path: pathWarn + this.path,\n            });\n        }\n        const cs = this.statCache.get(this.absolute);\n        if (cs) {\n            this[ONLSTAT](cs);\n        }\n        else {\n            this[LSTAT]();\n        }\n    }\n    warn(code, message, data = {}) {\n        return (0, warn_method_js_1.warnMethod)(this, code, message, data);\n    }\n    emit(ev, ...data) {\n        if (ev === 'error') {\n            this.#hadError = true;\n        }\n        return super.emit(ev, ...data);\n    }\n    [LSTAT]() {\n        fs_1.default.lstat(this.absolute, (er, stat) => {\n            if (er) {\n                return this.emit('error', er);\n            }\n            this[ONLSTAT](stat);\n        });\n    }\n    [ONLSTAT](stat) {\n        this.statCache.set(this.absolute, stat);\n        this.stat = stat;\n        if (!stat.isFile()) {\n            stat.size = 0;\n        }\n        this.type = getType(stat);\n        this.emit('stat', stat);\n        this[PROCESS]();\n    }\n    [PROCESS]() {\n        switch (this.type) {\n            case 'File':\n                return this[FILE]();\n            case 'Directory':\n                return this[DIRECTORY]();\n            case 'SymbolicLink':\n                return this[SYMLINK]();\n            // unsupported types are ignored.\n            default:\n                return this.end();\n        }\n    }\n    [MODE](mode) {\n        return (0, mode_fix_js_1.modeFix)(mode, this.type === 'Directory', this.portable);\n    }\n    [PREFIX](path) {\n        return prefixPath(path, this.prefix);\n    }\n    [HEADER]() {\n        /* c8 ignore start */\n        if (!this.stat) {\n            throw new Error('cannot write header before stat');\n        }\n        /* c8 ignore stop */\n        if (this.type === 'Directory' && this.portable) {\n            this.noMtime = true;\n        }\n        this.onWriteEntry?.(this);\n        this.header = new header_js_1.Header({\n            path: this[PREFIX](this.path),\n            // only apply the prefix to hard links.\n            linkpath: this.type === 'Link' && this.linkpath !== undefined ?\n                this[PREFIX](this.linkpath)\n                : this.linkpath,\n            // only the permissions and setuid/setgid/sticky bitflags\n            // not the higher-order bits that specify file type\n            mode: this[MODE](this.stat.mode),\n            uid: this.portable ? undefined : this.stat.uid,\n            gid: this.portable ? undefined : this.stat.gid,\n            size: this.stat.size,\n            mtime: this.noMtime ? undefined : this.mtime || this.stat.mtime,\n            /* c8 ignore next */\n            type: this.type === 'Unsupported' ? undefined : this.type,\n            uname: this.portable ? undefined\n                : this.stat.uid === this.myuid ? this.myuser\n                    : '',\n            atime: this.portable ? undefined : this.stat.atime,\n            ctime: this.portable ? undefined : this.stat.ctime,\n        });\n        if (this.header.encode() && !this.noPax) {\n            super.write(new pax_js_1.Pax({\n                atime: this.portable ? undefined : this.header.atime,\n                ctime: this.portable ? undefined : this.header.ctime,\n                gid: this.portable ? undefined : this.header.gid,\n                mtime: this.noMtime ? undefined : (this.mtime || this.header.mtime),\n                path: this[PREFIX](this.path),\n                linkpath: this.type === 'Link' && this.linkpath !== undefined ?\n                    this[PREFIX](this.linkpath)\n                    : this.linkpath,\n                size: this.header.size,\n                uid: this.portable ? undefined : this.header.uid,\n                uname: this.portable ? undefined : this.header.uname,\n                dev: this.portable ? undefined : this.stat.dev,\n                ino: this.portable ? undefined : this.stat.ino,\n                nlink: this.portable ? undefined : this.stat.nlink,\n            }).encode());\n        }\n        const block = this.header?.block;\n        /* c8 ignore start */\n        if (!block) {\n            throw new Error('failed to encode header');\n        }\n        /* c8 ignore stop */\n        super.write(block);\n    }\n    [DIRECTORY]() {\n        /* c8 ignore start */\n        if (!this.stat) {\n            throw new Error('cannot create directory entry without stat');\n        }\n        /* c8 ignore stop */\n        if (this.path.slice(-1) !== '/') {\n            this.path += '/';\n        }\n        this.stat.size = 0;\n        this[HEADER]();\n        this.end();\n    }\n    [SYMLINK]() {\n        fs_1.default.readlink(this.absolute, (er, linkpath) => {\n            if (er) {\n                return this.emit('error', er);\n            }\n            this[ONREADLINK](linkpath);\n        });\n    }\n    [ONREADLINK](linkpath) {\n        this.linkpath = (0, normalize_windows_path_js_1.normalizeWindowsPath)(linkpath);\n        this[HEADER]();\n        this.end();\n    }\n    [HARDLINK](linkpath) {\n        /* c8 ignore start */\n        if (!this.stat) {\n            throw new Error('cannot create link entry without stat');\n        }\n        /* c8 ignore stop */\n        this.type = 'Link';\n        this.linkpath = (0, normalize_windows_path_js_1.normalizeWindowsPath)(path_1.default.relative(this.cwd, linkpath));\n        this.stat.size = 0;\n        this[HEADER]();\n        this.end();\n    }\n    [FILE]() {\n        /* c8 ignore start */\n        if (!this.stat) {\n            throw new Error('cannot create file entry without stat');\n        }\n        /* c8 ignore stop */\n        if (this.stat.nlink > 1) {\n            const linkKey = `${this.stat.dev}:${this.stat.ino}`;\n            const linkpath = this.linkCache.get(linkKey);\n            if (linkpath?.indexOf(this.cwd) === 0) {\n                return this[HARDLINK](linkpath);\n            }\n            this.linkCache.set(linkKey, this.absolute);\n        }\n        this[HEADER]();\n        if (this.stat.size === 0) {\n            return this.end();\n        }\n        this[OPENFILE]();\n    }\n    [OPENFILE]() {\n        fs_1.default.open(this.absolute, 'r', (er, fd) => {\n            if (er) {\n                return this.emit('error', er);\n            }\n            this[ONOPENFILE](fd);\n        });\n    }\n    [ONOPENFILE](fd) {\n        this.fd = fd;\n        if (this.#hadError) {\n            return this[CLOSE]();\n        }\n        /* c8 ignore start */\n        if (!this.stat) {\n            throw new Error('should stat before calling onopenfile');\n        }\n        /* c8 ignore start */\n        this.blockLen = 512 * Math.ceil(this.stat.size / 512);\n        this.blockRemain = this.blockLen;\n        const bufLen = Math.min(this.blockLen, this.maxReadSize);\n        this.buf = Buffer.allocUnsafe(bufLen);\n        this.offset = 0;\n        this.pos = 0;\n        this.remain = this.stat.size;\n        this.length = this.buf.length;\n        this[READ]();\n    }\n    [READ]() {\n        const { fd, buf, offset, length, pos } = this;\n        if (fd === undefined || buf === undefined) {\n            throw new Error('cannot read file without first opening');\n        }\n        fs_1.default.read(fd, buf, offset, length, pos, (er, bytesRead) => {\n            if (er) {\n                // ignoring the error from close(2) is a bad practice, but at\n                // this point we already have an error, don't need another one\n                return this[CLOSE](() => this.emit('error', er));\n            }\n            this[ONREAD](bytesRead);\n        });\n    }\n    /* c8 ignore start */\n    [CLOSE](cb = () => { }) {\n        /* c8 ignore stop */\n        if (this.fd !== undefined)\n            fs_1.default.close(this.fd, cb);\n    }\n    [ONREAD](bytesRead) {\n        if (bytesRead <= 0 && this.remain > 0) {\n            const er = Object.assign(new Error('encountered unexpected EOF'), {\n                path: this.absolute,\n                syscall: 'read',\n                code: 'EOF',\n            });\n            return this[CLOSE](() => this.emit('error', er));\n        }\n        if (bytesRead > this.remain) {\n            const er = Object.assign(new Error('did not encounter expected EOF'), {\n                path: this.absolute,\n                syscall: 'read',\n                code: 'EOF',\n            });\n            return this[CLOSE](() => this.emit('error', er));\n        }\n        /* c8 ignore start */\n        if (!this.buf) {\n            throw new Error('should have created buffer prior to reading');\n        }\n        /* c8 ignore stop */\n        // null out the rest of the buffer, if we could fit the block padding\n        // at the end of this loop, we've incremented bytesRead and this.remain\n        // to be incremented up to the blockRemain level, as if we had expected\n        // to get a null-padded file, and read it until the end.  then we will\n        // decrement both remain and blockRemain by bytesRead, and know that we\n        // reached the expected EOF, without any null buffer to append.\n        if (bytesRead === this.remain) {\n            for (let i = bytesRead; i < this.length && bytesRead < this.blockRemain; i++) {\n                this.buf[i + this.offset] = 0;\n                bytesRead++;\n                this.remain++;\n            }\n        }\n        const chunk = this.offset === 0 && bytesRead === this.buf.length ?\n            this.buf\n            : this.buf.subarray(this.offset, this.offset + bytesRead);\n        const flushed = this.write(chunk);\n        if (!flushed) {\n            this[AWAITDRAIN](() => this[ONDRAIN]());\n        }\n        else {\n            this[ONDRAIN]();\n        }\n    }\n    [AWAITDRAIN](cb) {\n        this.once('drain', cb);\n    }\n    write(chunk, encoding, cb) {\n        /* c8 ignore start - just junk to comply with NodeJS.WritableStream */\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, typeof encoding === 'string' ? encoding : 'utf8');\n        }\n        /* c8 ignore stop */\n        if (this.blockRemain < chunk.length) {\n            const er = Object.assign(new Error('writing more data than expected'), {\n                path: this.absolute,\n            });\n            return this.emit('error', er);\n        }\n        this.remain -= chunk.length;\n        this.blockRemain -= chunk.length;\n        this.pos += chunk.length;\n        this.offset += chunk.length;\n        return super.write(chunk, null, cb);\n    }\n    [ONDRAIN]() {\n        if (!this.remain) {\n            if (this.blockRemain) {\n                super.write(Buffer.alloc(this.blockRemain));\n            }\n            return this[CLOSE](er => er ? this.emit('error', er) : this.end());\n        }\n        /* c8 ignore start */\n        if (!this.buf) {\n            throw new Error('buffer lost somehow in ONDRAIN');\n        }\n        /* c8 ignore stop */\n        if (this.offset >= this.length) {\n            // if we only have a smaller bit left to read, alloc a smaller buffer\n            // otherwise, keep it the same length it was before.\n            this.buf = Buffer.allocUnsafe(Math.min(this.blockRemain, this.buf.length));\n            this.offset = 0;\n        }\n        this.length = this.buf.length - this.offset;\n        this[READ]();\n    }\n}\nexports.WriteEntry = WriteEntry;\nclass WriteEntrySync extends WriteEntry {\n    sync = true;\n    [LSTAT]() {\n        this[ONLSTAT](fs_1.default.lstatSync(this.absolute));\n    }\n    [SYMLINK]() {\n        this[ONREADLINK](fs_1.default.readlinkSync(this.absolute));\n    }\n    [OPENFILE]() {\n        this[ONOPENFILE](fs_1.default.openSync(this.absolute, 'r'));\n    }\n    [READ]() {\n        let threw = true;\n        try {\n            const { fd, buf, offset, length, pos } = this;\n            /* c8 ignore start */\n            if (fd === undefined || buf === undefined) {\n                throw new Error('fd and buf must be set in READ method');\n            }\n            /* c8 ignore stop */\n            const bytesRead = fs_1.default.readSync(fd, buf, offset, length, pos);\n            this[ONREAD](bytesRead);\n            threw = false;\n        }\n        finally {\n            // ignoring the error from close(2) is a bad practice, but at\n            // this point we already have an error, don't need another one\n            if (threw) {\n                try {\n                    this[CLOSE](() => { });\n                }\n                catch (er) { }\n            }\n        }\n    }\n    [AWAITDRAIN](cb) {\n        cb();\n    }\n    /* c8 ignore start */\n    [CLOSE](cb = () => { }) {\n        /* c8 ignore stop */\n        if (this.fd !== undefined)\n            fs_1.default.closeSync(this.fd);\n        cb();\n    }\n}\nexports.WriteEntrySync = WriteEntrySync;\nclass WriteEntryTar extends minipass_1.Minipass {\n    blockLen = 0;\n    blockRemain = 0;\n    buf = 0;\n    pos = 0;\n    remain = 0;\n    length = 0;\n    preservePaths;\n    portable;\n    strict;\n    noPax;\n    noMtime;\n    readEntry;\n    type;\n    prefix;\n    path;\n    mode;\n    uid;\n    gid;\n    uname;\n    gname;\n    header;\n    mtime;\n    atime;\n    ctime;\n    linkpath;\n    size;\n    onWriteEntry;\n    warn(code, message, data = {}) {\n        return (0, warn_method_js_1.warnMethod)(this, code, message, data);\n    }\n    constructor(readEntry, opt_ = {}) {\n        const opt = (0, options_js_1.dealias)(opt_);\n        super();\n        this.preservePaths = !!opt.preservePaths;\n        this.portable = !!opt.portable;\n        this.strict = !!opt.strict;\n        this.noPax = !!opt.noPax;\n        this.noMtime = !!opt.noMtime;\n        this.onWriteEntry = opt.onWriteEntry;\n        this.readEntry = readEntry;\n        const { type } = readEntry;\n        /* c8 ignore start */\n        if (type === 'Unsupported') {\n            throw new Error('writing entry that should be ignored');\n        }\n        /* c8 ignore stop */\n        this.type = type;\n        if (this.type === 'Directory' && this.portable) {\n            this.noMtime = true;\n        }\n        this.prefix = opt.prefix;\n        this.path = (0, normalize_windows_path_js_1.normalizeWindowsPath)(readEntry.path);\n        this.mode =\n            readEntry.mode !== undefined ?\n                this[MODE](readEntry.mode)\n                : undefined;\n        this.uid = this.portable ? undefined : readEntry.uid;\n        this.gid = this.portable ? undefined : readEntry.gid;\n        this.uname = this.portable ? undefined : readEntry.uname;\n        this.gname = this.portable ? undefined : readEntry.gname;\n        this.size = readEntry.size;\n        this.mtime =\n            this.noMtime ? undefined : opt.mtime || readEntry.mtime;\n        this.atime = this.portable ? undefined : readEntry.atime;\n        this.ctime = this.portable ? undefined : readEntry.ctime;\n        this.linkpath =\n            readEntry.linkpath !== undefined ?\n                (0, normalize_windows_path_js_1.normalizeWindowsPath)(readEntry.linkpath)\n                : undefined;\n        if (typeof opt.onwarn === 'function') {\n            this.on('warn', opt.onwarn);\n        }\n        let pathWarn = false;\n        if (!this.preservePaths) {\n            const [root, stripped] = (0, strip_absolute_path_js_1.stripAbsolutePath)(this.path);\n            if (root && typeof stripped === 'string') {\n                this.path = stripped;\n                pathWarn = root;\n            }\n        }\n        this.remain = readEntry.size;\n        this.blockRemain = readEntry.startBlockSize;\n        this.onWriteEntry?.(this);\n        this.header = new header_js_1.Header({\n            path: this[PREFIX](this.path),\n            linkpath: this.type === 'Link' && this.linkpath !== undefined ?\n                this[PREFIX](this.linkpath)\n                : this.linkpath,\n            // only the permissions and setuid/setgid/sticky bitflags\n            // not the higher-order bits that specify file type\n            mode: this.mode,\n            uid: this.portable ? undefined : this.uid,\n            gid: this.portable ? undefined : this.gid,\n            size: this.size,\n            mtime: this.noMtime ? undefined : this.mtime,\n            type: this.type,\n            uname: this.portable ? undefined : this.uname,\n            atime: this.portable ? undefined : this.atime,\n            ctime: this.portable ? undefined : this.ctime,\n        });\n        if (pathWarn) {\n            this.warn('TAR_ENTRY_INFO', `stripping ${pathWarn} from absolute path`, {\n                entry: this,\n                path: pathWarn + this.path,\n            });\n        }\n        if (this.header.encode() && !this.noPax) {\n            super.write(new pax_js_1.Pax({\n                atime: this.portable ? undefined : this.atime,\n                ctime: this.portable ? undefined : this.ctime,\n                gid: this.portable ? undefined : this.gid,\n                mtime: this.noMtime ? undefined : this.mtime,\n                path: this[PREFIX](this.path),\n                linkpath: this.type === 'Link' && this.linkpath !== undefined ?\n                    this[PREFIX](this.linkpath)\n                    : this.linkpath,\n                size: this.size,\n                uid: this.portable ? undefined : this.uid,\n                uname: this.portable ? undefined : this.uname,\n                dev: this.portable ? undefined : this.readEntry.dev,\n                ino: this.portable ? undefined : this.readEntry.ino,\n                nlink: this.portable ? undefined : this.readEntry.nlink,\n            }).encode());\n        }\n        const b = this.header?.block;\n        /* c8 ignore start */\n        if (!b)\n            throw new Error('failed to encode header');\n        /* c8 ignore stop */\n        super.write(b);\n        readEntry.pipe(this);\n    }\n    [PREFIX](path) {\n        return prefixPath(path, this.prefix);\n    }\n    [MODE](mode) {\n        return (0, mode_fix_js_1.modeFix)(mode, this.type === 'Directory', this.portable);\n    }\n    write(chunk, encoding, cb) {\n        /* c8 ignore start - just junk to comply with NodeJS.WritableStream */\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, typeof encoding === 'string' ? encoding : 'utf8');\n        }\n        /* c8 ignore stop */\n        const writeLen = chunk.length;\n        if (writeLen > this.blockRemain) {\n            throw new Error('writing more to entry than is appropriate');\n        }\n        this.blockRemain -= writeLen;\n        return super.write(chunk, cb);\n    }\n    end(chunk, encoding, cb) {\n        if (this.blockRemain) {\n            super.write(Buffer.alloc(this.blockRemain));\n        }\n        /* c8 ignore start - just junk to comply with NodeJS.WritableStream */\n        if (typeof chunk === 'function') {\n            cb = chunk;\n            encoding = undefined;\n            chunk = undefined;\n        }\n        if (typeof encoding === 'function') {\n            cb = encoding;\n            encoding = undefined;\n        }\n        if (typeof chunk === 'string') {\n            chunk = Buffer.from(chunk, encoding ?? 'utf8');\n        }\n        if (cb)\n            this.once('finish', cb);\n        chunk ? super.end(chunk, cb) : super.end(cb);\n        /* c8 ignore stop */\n        return this;\n    }\n}\nexports.WriteEntryTar = WriteEntryTar;\nconst getType = (stat) => stat.isFile() ? 'File'\n    : stat.isDirectory() ? 'Directory'\n        : stat.isSymbolicLink() ? 'SymbolicLink'\n            : 'Unsupported';\n//# sourceMappingURL=write-entry.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Node = exports.Yallist = void 0;\nclass Yallist {\n    tail;\n    head;\n    length = 0;\n    static create(list = []) {\n        return new Yallist(list);\n    }\n    constructor(list = []) {\n        for (const item of list) {\n            this.push(item);\n        }\n    }\n    *[Symbol.iterator]() {\n        for (let walker = this.head; walker; walker = walker.next) {\n            yield walker.value;\n        }\n    }\n    removeNode(node) {\n        if (node.list !== this) {\n            throw new Error('removing node which does not belong to this list');\n        }\n        const next = node.next;\n        const prev = node.prev;\n        if (next) {\n            next.prev = prev;\n        }\n        if (prev) {\n            prev.next = next;\n        }\n        if (node === this.head) {\n            this.head = next;\n        }\n        if (node === this.tail) {\n            this.tail = prev;\n        }\n        this.length--;\n        node.next = undefined;\n        node.prev = undefined;\n        node.list = undefined;\n        return next;\n    }\n    unshiftNode(node) {\n        if (node === this.head) {\n            return;\n        }\n        if (node.list) {\n            node.list.removeNode(node);\n        }\n        const head = this.head;\n        node.list = this;\n        node.next = head;\n        if (head) {\n            head.prev = node;\n        }\n        this.head = node;\n        if (!this.tail) {\n            this.tail = node;\n        }\n        this.length++;\n    }\n    pushNode(node) {\n        if (node === this.tail) {\n            return;\n        }\n        if (node.list) {\n            node.list.removeNode(node);\n        }\n        const tail = this.tail;\n        node.list = this;\n        node.prev = tail;\n        if (tail) {\n            tail.next = node;\n        }\n        this.tail = node;\n        if (!this.head) {\n            this.head = node;\n        }\n        this.length++;\n    }\n    push(...args) {\n        for (let i = 0, l = args.length; i < l; i++) {\n            push(this, args[i]);\n        }\n        return this.length;\n    }\n    unshift(...args) {\n        for (var i = 0, l = args.length; i < l; i++) {\n            unshift(this, args[i]);\n        }\n        return this.length;\n    }\n    pop() {\n        if (!this.tail) {\n            return undefined;\n        }\n        const res = this.tail.value;\n        const t = this.tail;\n        this.tail = this.tail.prev;\n        if (this.tail) {\n            this.tail.next = undefined;\n        }\n        else {\n            this.head = undefined;\n        }\n        t.list = undefined;\n        this.length--;\n        return res;\n    }\n    shift() {\n        if (!this.head) {\n            return undefined;\n        }\n        const res = this.head.value;\n        const h = this.head;\n        this.head = this.head.next;\n        if (this.head) {\n            this.head.prev = undefined;\n        }\n        else {\n            this.tail = undefined;\n        }\n        h.list = undefined;\n        this.length--;\n        return res;\n    }\n    forEach(fn, thisp) {\n        thisp = thisp || this;\n        for (let walker = this.head, i = 0; !!walker; i++) {\n            fn.call(thisp, walker.value, i, this);\n            walker = walker.next;\n        }\n    }\n    forEachReverse(fn, thisp) {\n        thisp = thisp || this;\n        for (let walker = this.tail, i = this.length - 1; !!walker; i--) {\n            fn.call(thisp, walker.value, i, this);\n            walker = walker.prev;\n        }\n    }\n    get(n) {\n        let i = 0;\n        let walker = this.head;\n        for (; !!walker && i < n; i++) {\n            walker = walker.next;\n        }\n        if (i === n && !!walker) {\n            return walker.value;\n        }\n    }\n    getReverse(n) {\n        let i = 0;\n        let walker = this.tail;\n        for (; !!walker && i < n; i++) {\n            // abort out of the list early if we hit a cycle\n            walker = walker.prev;\n        }\n        if (i === n && !!walker) {\n            return walker.value;\n        }\n    }\n    map(fn, thisp) {\n        thisp = thisp || this;\n        const res = new Yallist();\n        for (let walker = this.head; !!walker;) {\n            res.push(fn.call(thisp, walker.value, this));\n            walker = walker.next;\n        }\n        return res;\n    }\n    mapReverse(fn, thisp) {\n        thisp = thisp || this;\n        var res = new Yallist();\n        for (let walker = this.tail; !!walker;) {\n            res.push(fn.call(thisp, walker.value, this));\n            walker = walker.prev;\n        }\n        return res;\n    }\n    reduce(fn, initial) {\n        let acc;\n        let walker = this.head;\n        if (arguments.length > 1) {\n            acc = initial;\n        }\n        else if (this.head) {\n            walker = this.head.next;\n            acc = this.head.value;\n        }\n        else {\n            throw new TypeError('Reduce of empty list with no initial value');\n        }\n        for (var i = 0; !!walker; i++) {\n            acc = fn(acc, walker.value, i);\n            walker = walker.next;\n        }\n        return acc;\n    }\n    reduceReverse(fn, initial) {\n        let acc;\n        let walker = this.tail;\n        if (arguments.length > 1) {\n            acc = initial;\n        }\n        else if (this.tail) {\n            walker = this.tail.prev;\n            acc = this.tail.value;\n        }\n        else {\n            throw new TypeError('Reduce of empty list with no initial value');\n        }\n        for (let i = this.length - 1; !!walker; i--) {\n            acc = fn(acc, walker.value, i);\n            walker = walker.prev;\n        }\n        return acc;\n    }\n    toArray() {\n        const arr = new Array(this.length);\n        for (let i = 0, walker = this.head; !!walker; i++) {\n            arr[i] = walker.value;\n            walker = walker.next;\n        }\n        return arr;\n    }\n    toArrayReverse() {\n        const arr = new Array(this.length);\n        for (let i = 0, walker = this.tail; !!walker; i++) {\n            arr[i] = walker.value;\n            walker = walker.prev;\n        }\n        return arr;\n    }\n    slice(from = 0, to = this.length) {\n        if (to < 0) {\n            to += this.length;\n        }\n        if (from < 0) {\n            from += this.length;\n        }\n        const ret = new Yallist();\n        if (to < from || to < 0) {\n            return ret;\n        }\n        if (from < 0) {\n            from = 0;\n        }\n        if (to > this.length) {\n            to = this.length;\n        }\n        let walker = this.head;\n        let i = 0;\n        for (i = 0; !!walker && i < from; i++) {\n            walker = walker.next;\n        }\n        for (; !!walker && i < to; i++, walker = walker.next) {\n            ret.push(walker.value);\n        }\n        return ret;\n    }\n    sliceReverse(from = 0, to = this.length) {\n        if (to < 0) {\n            to += this.length;\n        }\n        if (from < 0) {\n            from += this.length;\n        }\n        const ret = new Yallist();\n        if (to < from || to < 0) {\n            return ret;\n        }\n        if (from < 0) {\n            from = 0;\n        }\n        if (to > this.length) {\n            to = this.length;\n        }\n        let i = this.length;\n        let walker = this.tail;\n        for (; !!walker && i > to; i--) {\n            walker = walker.prev;\n        }\n        for (; !!walker && i > from; i--, walker = walker.prev) {\n            ret.push(walker.value);\n        }\n        return ret;\n    }\n    splice(start, deleteCount = 0, ...nodes) {\n        if (start > this.length) {\n            start = this.length - 1;\n        }\n        if (start < 0) {\n            start = this.length + start;\n        }\n        let walker = this.head;\n        for (let i = 0; !!walker && i < start; i++) {\n            walker = walker.next;\n        }\n        const ret = [];\n        for (let i = 0; !!walker && i < deleteCount; i++) {\n            ret.push(walker.value);\n            walker = this.removeNode(walker);\n        }\n        if (!walker) {\n            walker = this.tail;\n        }\n        else if (walker !== this.tail) {\n            walker = walker.prev;\n        }\n        for (const v of nodes) {\n            walker = insertAfter(this, walker, v);\n        }\n        return ret;\n    }\n    reverse() {\n        const head = this.head;\n        const tail = this.tail;\n        for (let walker = head; !!walker; walker = walker.prev) {\n            const p = walker.prev;\n            walker.prev = walker.next;\n            walker.next = p;\n        }\n        this.head = tail;\n        this.tail = head;\n        return this;\n    }\n}\nexports.Yallist = Yallist;\n// insertAfter undefined means \"make the node the new head of list\"\nfunction insertAfter(self, node, value) {\n    const prev = node;\n    const next = node ? node.next : self.head;\n    const inserted = new Node(value, prev, next, self);\n    if (inserted.next === undefined) {\n        self.tail = inserted;\n    }\n    if (inserted.prev === undefined) {\n        self.head = inserted;\n    }\n    self.length++;\n    return inserted;\n}\nfunction push(self, item) {\n    self.tail = new Node(item, self.tail, undefined, self);\n    if (!self.head) {\n        self.head = self.tail;\n    }\n    self.length++;\n}\nfunction unshift(self, item) {\n    self.head = new Node(item, undefined, self.head, self);\n    if (!self.tail) {\n        self.tail = self.head;\n    }\n    self.length++;\n}\nclass Node {\n    list;\n    next;\n    prev;\n    value;\n    constructor(value, prev, next, list) {\n        this.list = list;\n        this.value = value;\n        if (prev) {\n            prev.next = this;\n            this.prev = prev;\n        }\n        else {\n            this.prev = undefined;\n        }\n        if (next) {\n            next.prev = this;\n            this.next = next;\n        }\n        else {\n            this.next = undefined;\n        }\n    }\n}\nexports.Node = Node;\n//# sourceMappingURL=index.js.map","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\tvar threw = true;\n\ttry {\n\t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\tthrew = false;\n\t} finally {\n\t\tif(threw) delete __webpack_module_cache__[moduleId];\n\t}\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","\nif (typeof __webpack_require__ !== 'undefined') __webpack_require__.ab = __dirname + \"/\";","/**\n * The entrypoint for the action.\n */\nconst { run } = require('./main')\n\nrun()\n"],"names":[],"sourceRoot":""}